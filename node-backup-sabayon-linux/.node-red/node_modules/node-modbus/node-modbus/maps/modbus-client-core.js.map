{"version":3,"sources":["modbus-client-core.js"],"names":["stampit","require","logger","StateMachine","ExceptionMessage","1","2","3","4","5","6","8","10","11","module","exports","refs","logLabel","logLevel","compose","currentRequest","init","reqFifo","responseHandler","this","endianType","log","info","onClosed","on","onData","flush","onTimeout","bind","length","debug","pdu","setState","emit","setRequestTimeout","timeout","setTimeout","err","error","clearTimeout","shift","reject","handleErrorPDU","defer","JSON","stringify","errorCode","readUInt8","message","exceptionCode","handler","fc","Error","queueRequest","req","push","warn","getState","inState"],"mappings":"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","file":"../modbus-client-core.js","sourcesContent":["/**\n * Modbus client core.\n * @module ModbusCoreClient\n */\n'use strict'\n\nvar stampit = require('stampit')\nvar logger = require('stampit-log')\nvar StateMachine = require('stampit-state-machine')\n\nlet ExceptionMessage = {\n  0x01: 'ILLEGAL FUNCTION',\n  0x02: 'ILLEGAL DATA ADDRESS',\n  0x03: 'ILLEGAL DATA VALUE',\n  0x04: 'SLAVE DEVICE FAILURE',\n  0x05: 'ACKNOWLEDGE',\n  0x06: 'SLAVE DEVICE BUSY',\n  0x08: 'MEMORY PARITY ERROR',\n  0x0A: 'GATEWAY PATH UNAVAILABLE',\n  0x0B: 'GATEWAY TARGET DEVICE FAILED TO RESPOND'\n}\n\nmodule.exports = stampit()\n  .refs({\n    'logLabel': 'ModbusCoreClient',\n    'logLevel': 'info',\n    'logEnabled': true\n  })\n  .compose(StateMachine)\n  .compose(logger)\n  .init(function () {\n    let responseHandler = {}\n    let currentRequest = null\n\n    this.reqFifo = []\n\n    let init = function () {\n      if (!this.timeout) {\n        this.timeout = 2000 // ms\n      }\n\n      if (!this.endianType) {\n        this.endianType = 'LITTLE'\n      }\n\n      if (this.logLevel) {\n        this.log.logLevel = this.logLevel\n      }\n      this.log.info('log level: ' + this.log.logLevel)\n\n      this.on('data', onData)\n      this.on('timeout', onTimeout)\n      this.on('newState_closed', onClosed)\n    }.bind(this)\n\n    let flush = function () {\n      if (this.reqFifo.length === 0) {\n        this.log.debug('Nothing in request pipe.')\n        return\n      } else {\n        this.log.debug(this.reqFifo.length + ' requests in request pipe.')\n      }\n\n      currentRequest = this.reqFifo.shift()\n\n      if (currentRequest && currentRequest.pdu) {\n        this.setState('waiting')\n        this.emit('send', currentRequest.pdu, setRequestTimeout)\n        this.log.debug('Data flushed.')\n      }\n    }.bind(this)\n\n    let setRequestTimeout = function () {\n      currentRequest.timeout = setTimeout(function () {\n        currentRequest.defer.reject({err: 'timeout'})\n        this.emit('trashCurrentRequest')\n        this.log.error('Request timed out after ' + this.timeout / 1000 + ' sec')\n        this.emit('timeout')\n      }.bind(this), this.timeout)\n      this.log.debug('set timeout of ' + this.timeout + ' ms on send to wait for data')\n    }.bind(this)\n\n    let onTimeout = function () {\n      // TODO: may here is something to be done\n      this.setState('ready')\n    }.bind(this)\n\n    let onClosed = function () {\n      if (currentRequest) {\n        this.log.debug('Clearing timeout of the current request.')\n        clearTimeout(currentRequest.timeout)\n      }\n      this.log.debug('Cleaning up request fifo.')\n      while (this.reqFifo.length) {\n        this.reqFifo.shift().defer.reject({err: 'Fifo cleanup'})\n      }\n    }.bind(this)\n\n    let handleErrorPDU = function (pdu) {\n      let errorCode = pdu.readUInt8(0)\n\n      // if error code is smaller than 0x80\n      // ths pdu describes no error\n\n      if (errorCode < 0x80) {\n        return false\n      }\n\n      // pdu describes an error\n      if (pdu.length < 2) {\n        currentRequest.defer.reject('PDU length ' + pdu.length + ' invalid')\n        return true\n      }\n\n      let exceptionCode = pdu.readUInt8(1)\n      let message = ExceptionMessage[exceptionCode]\n\n      let err = {\n        errorCode: errorCode,\n        exceptionCode: exceptionCode,\n        message: message\n      }\n\n      // call the desired deferred\n      currentRequest.defer.reject(err)\n\n      return true\n    }\n\n    /**\n     *  Handle the incoming data, cut out the mbap\n     *  packet and send the pdu to the listener\n     */\n    let onData = function (pdu) {\n      if (!currentRequest) {\n        this.log.debug('No current request.')\n        return\n      }\n      clearTimeout(currentRequest.timeout)\n      this.log.debug('received data and clean timeout PDU: ' + JSON.stringify(pdu))\n\n      // check pdu for error\n      if (handleErrorPDU(pdu)) {\n        this.log.debug('Received pdu describes an error.')\n        currentRequest = null\n        this.setState('ready')\n        return\n      }\n\n      // handle pdu\n      let handler = responseHandler[currentRequest.fc]\n      if (!handler) {\n        this.log.debug('Found not handler for fc', currentRequest.fc)\n        throw new Error('No handler implemented for fc ' + currentRequest.fc)\n      }\n      // TODO: here is may a problem - if we set here error it stay on error, but it should become ready again later\n\n      handler(pdu, currentRequest)\n      this.setState('ready')\n    }.bind(this)\n\n    this.addResponseHandler = function (fc, handler) {\n      responseHandler[fc] = handler\n      return this\n    }.bind(this)\n\n    this.queueRequest = function (fc, pdu, defer) {\n      let req = {\n        fc: fc,\n        defer: defer,\n        pdu: pdu\n      }\n\n      if (this.inState('ready')) {\n        /* fill reqFifo just in ready state\n         - think about running machines\n         - recorded data sending later and very fast - because it is in queue - can damage machines\n         */\n        this.reqFifo.push(req)\n        flush()\n      } else {\n        this.log.warn('not ready to transport data state:' + this.getState())\n        if (this.inState('closed')) {\n          this.emit('error', 'connection closed')\n        }\n        defer.reject({err: 'modbus client not in \"ready\" state'})\n      }\n    }\n\n    init()\n  })\n"]}