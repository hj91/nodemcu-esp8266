{"version":3,"sources":["modbus-serial-client.js"],"names":["stampit","require","ModbusCore","module","exports","compose","init","logLabel","SerialPort","serialport","receiveBuffer","alloc","receivedBytes","expectedBytes","crcBytes","Buffer","minLength","exeptionMessageLength","this","connectionDelay","process","connectionType","portName","Error","baudRate","dataBits","stopBits","parity","injectedSerialport","log","debug","setTimeout","openSerialPort","on","onSend","bind","parser","endianType","parsers","byteDelimiter","JSON","stringify","options","onDisconnect","onClose","onOpen","emit","err","setState","pdu","length","resetReceiveBuffer","copy","slice","crc","crc16modbus","onError","setRequestTimeout","base","allocUnsafe","writeUInt8","concat","crcModbus","buf","crcBufModbus","writeUInt16LE","bufWithCRC","Math","floor","readInt16BE","inState","write","error","close"],"mappings":"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","file":"../modbus-serial-client.js","sourcesContent":["/**\n * Modbus Serial client.\n * @module ModbusSerialClient\n */\n'use strict'\n\nlet stampit = require('stampit')\nlet ModbusCore = require('./modbus-client-core.js')\n\nmodule.exports = stampit()\n  .compose(ModbusCore)\n  .refs({\n    'logLabel': 'ModbusSerialClient'\n  })\n  .init(function () {\n    let SerialPort = require('serialport')\n    let crc = require('crc')\n    let serialport\n    let receiveBuffer = Buffer.alloc(256)\n    let receivedBytes = 0\n    let expectedBytes = 0\n    let crcBytes = 2\n    let minLength = 0x80\n    let exeptionMessageLength = 5\n\n    if (!this.connectionDelay) {\n      if (process.platform === 'win32') {\n        this.connectionDelay = 500 // ms\n      } else {\n        this.connectionDelay = 250 // ms\n      }\n    }\n\n    let init = function () {\n      this.setState('init')\n\n      if (!this.connectionType) { this.connectionType = 'RTU' }\n      if (!this.portName) { throw new Error('No portname.') }\n      if (!this.baudRate) { this.baudRate = 9600 }\n      if (!this.dataBits) { this.dataBits = 8 }\n      if (!this.stopBits) { this.stopBits = 1 }\n      if (!this.parity) { this.parity = 'none' }\n      // TODO: flowControl - ['xon', 'xoff', 'xany', 'rtscts']\n      // TODO: settings - ['brk', 'cts', 'dtr', 'dts', 'rts']\n\n      if (this.injectedSerialport) {\n        serialport = this.injectedSerialport\n        this.log.debug('we are working on a mockup serialport')\n      } else {\n        setTimeout(openSerialPort, this.connectionDelay)\n      }\n\n      this.log.debug('set on send method')\n      this.on('send', onSend)\n    }.bind(this)\n\n    let openSerialPort = function () {\n      // some delay needed on windows systems serial reconnect\n      if (this.connectionType === 'ASCII') {\n        serialport = new SerialPort(this.portName, {\n          baudRate: this.baudRate,\n          parity: this.parity,\n          dataBits: this.dataBits,\n          stopBits: this.stopBits,\n          parser: (this.endianType === 'BIG') ? SerialPort.parsers.byteDelimiter([13, 10]) : SerialPort.parsers.byteDelimiter([10, 13])\n        })\n      } else {\n        serialport = new SerialPort(this.portName, {\n          baudRate: this.baudRate,\n          parity: this.parity,\n          dataBits: this.dataBits,\n          stopBits: this.stopBits\n        })\n      }\n\n      this.log.debug('serialport settings: ' + JSON.stringify(serialport.options))\n      serialport.on('open', onOpen)\n      serialport.on('disconnect', onDisconnect)\n      serialport.on('close', onClose)\n      serialport.on('data', onData)\n      serialport.on('error', onError)\n    }.bind(this)\n\n    let onOpen = function () {\n      this.setState('ready')\n    }.bind(this)\n\n    let onDisconnect = function (err) {\n      this.setState('disconnected')\n      if (err) {\n        this.emit('error', err)\n      }\n    }.bind(this)\n\n    let onClose = function () {\n      this.setState('closed')\n    }.bind(this)\n\n    let onData = function (pdu) {\n      if (pdu.length !== 0) { // at least one byte has been received\n        this.log.debug('received serial data ' + JSON.stringify(pdu))\n\n        if ((pdu.length + receivedBytes) <= receiveBuffer.length) {\n          if (receivedBytes === 0 && pdu && pdu[0] === 0) {\n            this.log.debug('we got a broadcast from master')\n            this.resetReceiveBuffer()\n            return\n          }\n\n          pdu.copy(receiveBuffer, receivedBytes, 0)\n          receivedBytes += pdu.length\n\n          if (receivedBytes >= exeptionMessageLength) {\n            if (receivedBytes === exeptionMessageLength) {\n              if (receiveBuffer[1] >= minLength &&\n                crc.crc16modbus(receiveBuffer.slice(0, receivedBytes)) === 0) {\n                this.emit('data', receiveBuffer.slice(1, receivedBytes - crcBytes))\n                this.resetReceiveBuffer()\n              }\n            } else {\n              if (expectedBytes > 0) {\n                if (receivedBytes === expectedBytes) {\n                  if (crc.crc16modbus(receiveBuffer.slice(0, receivedBytes)) === 0) {\n                    this.emit('data', receiveBuffer.slice(1, receivedBytes - crcBytes))\n                    this.resetReceiveBuffer()\n                  }\n                } else {\n                  this.log.debug('received bytes ' + expectedBytes + ' differ from expected bytes ' + receivedBytes)\n                }\n              } else {\n                this.log.debug('none expected bytes: ' + expectedBytes)\n                this.emit('data', pdu)\n              }\n            }\n          } else {\n            this.log.debug('received bytes to less to do more -> receivedBytes: ' + receivedBytes)\n          }\n        } else {\n          this.log.debug('received bytes to less to do more -> receivedBytes: ' + receivedBytes)\n        }\n      } else {\n        this.log.debug('received bytes to less to do more -> pdu.length is empty')\n      }\n    }.bind(this)\n\n    this.resetReceiveBuffer = function () {\n      receivedBytes = 0\n      receiveBuffer = null\n      receiveBuffer = Buffer.alloc(256)\n    }\n\n    let onError = function (err) {\n      this.emit('error', err)\n    }.bind(this)\n\n    let onSend = function (pdu, setRequestTimeout) {\n      this.log.debug('PDU data' + JSON.stringify(pdu))\n\n      let base = Buffer.allocUnsafe(1)\n      base.writeUInt8(1)\n      let buf = Buffer.concat([base, pdu])\n\n      let crcModbus = crc.crc16modbus(buf)\n      let crcBufModbus = Buffer.allocUnsafe(2)\n      crcBufModbus.writeUInt16LE(crcModbus, 0)\n      this.log.debug('crcModbus: ' + JSON.stringify(crcModbus) + ' crcModbus Buffer:' + JSON.stringify(crcBufModbus))\n\n      let bufWithCRC = Buffer.concat([buf, crcBufModbus])\n      this.log.debug('Endian-Type: ' + this.endianType)\n      this.log.debug('Buffer with CR16LE ' + this.connectionType + ' : ' + JSON.stringify(bufWithCRC))\n\n      receivedBytes = 0\n\n      switch (pdu[0]) { // check for the function code that is requested\n        case 1:\n        case 2:\n          // expected response length is crc+adr+fc+len=5 + (number of coils/8)+1 to be requested\n          expectedBytes = 5 + (Math.floor(pdu.readInt16BE(3) / 8)) + 1\n          break\n\n        case 3:\n        case 4:\n          // expected response length is crc+adr+fc+len=5 + number of bytes to be requested\n          expectedBytes = 5 + pdu.readInt16BE(3) * 2\n          break\n\n        case 5:\n        case 6:\n        case 15:\n        case 16:\n          expectedBytes = 8\n          break\n\n        default:\n          expectedBytes = 0\n          break\n      }\n\n      if (this.inState('waiting') &&\n        serialport.isOpen()) {\n        serialport.write(bufWithCRC, function (err) {\n          if (err) {\n            this.log.error('error on write to serial:' + JSON.stringify(err))\n            this.emit('error', err)\n          } else {\n            this.log.debug('package written to serialport')\n          }\n        }.bind(this))\n      }\n      setRequestTimeout()\n    }.bind(this)\n\n    this.close = function () {\n      serialport.close()\n    }\n\n    init()\n  })\n"]}