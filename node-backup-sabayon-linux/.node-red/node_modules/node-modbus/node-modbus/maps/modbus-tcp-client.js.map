{"version":3,"sources":["modbus-tcp-client.js"],"names":["stampit","require","ModbusCore","module","exports","compose","init","logLabel","closedOnPurpose","reconnect","trashRequestId","buffer","alloc","socket","closed","Buffer","unitId","this","protocolVersion","port","host","autoReconnect","reconnectTimeout","onSend","on","onError","onTrashCurrentRequest","log","debug","bind","connect","callback","setState","injectedSocket","Socket","onSocketConnect","onSocketClose","onSocketError","onSocketData","onSocketTimeout","err","error","emit","hadErrors","setTimeout","logError","data","concat","length","id","readUInt16BE","len","pdu","slice","destroy","reqId","allocUnsafe","writeUInt16BE","head","setRequestTimeout","pkt","write","currentRequestId","inState","end","env","DEBUG","getSocket","setCurrentRequestId","registerOnSend","_onSend","removeListener","process"],"mappings":"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","file":"../modbus-tcp-client.js","sourcesContent":["/**\n * Modbus TCP client.\n * @module ModbusTCPClient\n */\n'use strict'\n\nlet stampit = require('stampit')\nlet ModbusCore = require('./modbus-client-core.js')\n\nmodule.exports = stampit()\n  .compose(ModbusCore)\n  .refs({\n    'logLabel': 'ModbusTCPClient'\n  })\n  .init(function () {\n    let reqId = 0\n    let currentRequestId = reqId\n    let closedOnPurpose = false\n    let reconnect = false\n    let trashRequestId\n    let buffer = Buffer.alloc(0)\n    let socket\n    let closed = true\n\n    let init = function () {\n      this.setState('init')\n\n      if (!this.unitId) { this.unitId = 0 }\n      if (!this.protocolVersion) { this.protocolVersion = 0 }\n      if (!this.port) { this.port = 502 }\n      if (!this.host) { this.host = 'localhost' }\n      if (!this.autoReconnect) { this.autoReconnect = false }\n      if (!this.reconnectTimeout) { this.reconnectTimeout = 0 }\n\n      this.on('send', onSend)\n      this.on('newState_error', onError)\n      this.on('trashCurrentRequest', onTrashCurrentRequest)\n\n      this.on('stateChanged', this.log.debug)\n    }.bind(this)\n\n    let connect = function (callback) {\n      this.setState('connect')\n\n      if (!socket) {\n        /* for testing you are able to inject a mocking object\n         * a simple event object should do the trick */\n        if (this.injectedSocket) {\n          socket = this.injectedSocket\n        } else {\n          socket = require('net').Socket()\n        }\n        socket.on('connect', onSocketConnect)\n        socket.on('close', onSocketClose)\n        socket.on('error', onSocketError)\n        socket.on('data', onSocketData)\n        socket.on('timeout', onSocketTimeout)\n      }\n\n      try {\n        socket.connect(this.port, this.host)\n        this.log.debug('socket connected')\n        if (typeof callback === 'function') {\n          callback()\n        }\n      } catch (err) {\n        this.log.error(err + ' on socket connect')\n        if (typeof callback === 'function') {\n          callback(err)\n        }\n      }\n    }.bind(this)\n\n    let onSocketConnect = function () {\n      closed = false\n      this.setState('ready')\n      this.emit('connect')\n    }.bind(this)\n\n    let onSocketClose = function (hadErrors) {\n      this.log.debug('Socket closed with error', hadErrors)\n\n      this.setState('closed')\n      this.emit('close')\n\n      if (!closedOnPurpose && (this.autoReconnect || reconnect)) {\n        setTimeout(function () {\n          reconnect = false\n          connect()\n        }, this.reconnectTimeout || 0)\n      }\n    }.bind(this)\n\n    let onSocketError = function (err) {\n      this.logError('Socket Error', err)\n\n      this.setState('error')\n      this.emit('error', err)\n    }.bind(this)\n\n    let onSocketTimeout = function () {\n      this.logError('Socket Timeout, setting state to error')\n\n      this.setState('error')\n      this.emit('error', 'timeout')\n    }.bind(this)\n\n    let onSocketData = function (data) {\n      this.log.debug('received data')\n\n      buffer = Buffer.concat([buffer, data])\n\n      while (buffer.length > 7) {\n        // 1. extract mbap\n        let id = buffer.readUInt16BE(0)\n        let len = buffer.readUInt16BE(4)\n\n        if (id === trashRequestId) {\n          this.log.debug('current mbap contains trashed request id.')\n\n          return\n        }\n\n        /* Not all data received yet. */\n        if (buffer.length < 7 + len - 1) {\n          break\n        }\n        this.log.debug('MBAP extracted')\n\n        // 2. extract pdu\n        let pdu = buffer.slice(7, 7 + len - 1)\n        this.log.debug('PDU extracted')\n\n        // emit data event and let the\n        // listener handle the pdu\n        this.emit('data', pdu)\n\n        buffer = buffer.slice(pdu.length + 7, buffer.length)\n      }\n    }.bind(this)\n\n    let onError = function () {\n      this.log.error('Client in error state.')\n      socket.destroy()\n    }.bind(this)\n\n    let onSend = function (pdu, setRequestTimeout) {\n      this.log.debug('Sending pdu to the socket.')\n\n      reqId = (reqId + 1) % 0xffff\n\n      let head = Buffer.allocUnsafe(7)\n\n      head.writeUInt16BE(reqId, 0)\n      head.writeUInt16BE(this.protocolVersion, 2)\n      head.writeUInt16BE(pdu.length + 1, 4)\n      head.writeUInt8(this.unitId, 6)\n      let pkt = Buffer.concat([head, pdu])\n      currentRequestId = reqId\n\n      setRequestTimeout()\n      socket.write(pkt)\n    }.bind(this)\n\n    let onTrashCurrentRequest = function () {\n      trashRequestId = currentRequestId\n    }\n\n    this.connect = function (callback) {\n      this.setState('connect')\n\n      connect(callback)\n\n      return this\n    }\n\n    this.reconnect = function () {\n      if (!this.inState('closed')) {\n        return this\n      }\n\n      closedOnPurpose = false\n      reconnect = true\n\n      this.log.debug('Reconnecting client.')\n\n      socket.end()\n\n      return this\n    }\n\n    this.close = function (callback) {\n      if (closed) {\n        if (typeof callback === 'function') {\n          callback()\n        }\n        return this\n      }\n\n      closed = true\n      closedOnPurpose = true\n      this.log.debug('Closing client on purpose.')\n      socket.end()\n      if (typeof callback === 'function') {\n        callback()\n      }\n      return this\n    }\n\n    // following is required to test of stream processing\n    // and is only during test active\n    if (process.env.DEBUG) {\n      this.getSocket = function () {\n        return socket\n      }\n      this.setCurrentRequestId = function (id) {\n        currentRequestId = id\n      }\n      this.registerOnSend = function (_onSend) {\n        this.removeListener(onSend)\n        this.on('send', _onSend.bind(this))\n      }\n    }\n\n    init()\n  })\n"]}