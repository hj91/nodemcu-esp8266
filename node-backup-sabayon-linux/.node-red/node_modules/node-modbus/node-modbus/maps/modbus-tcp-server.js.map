{"version":3,"sources":["modbus-tcp-server.js"],"names":["stampit","require","ModbusServerCore","StateMachine","ClientSocket","module","exports","compose","init","refs","logLabel","server","fifo","clients","socketList","this","hostname","netInject","net","createServer","log","socket","end","address","whiteListIPs","indexOf","initiateSocket","debug","push","bind","err","listen","port","setState","flush","error","length","onData","current","shift","pdu","response","head","writeUInt16BE","request","trans_id","pkt","concat","write","unit_id","removeHandler","cur","undefined","i","splice","socketId","onEnd","req","close","cb","unref","destroy"],"mappings":"AAIA,aAEA,IAAIA,QAAUC,QAAQ,WAClBC,iBAAmBD,QAAQ,2BAC3BE,aAAeF,QAAQ,yBACvBG,aAAeH,QAAQ,iCAE3BI,OAAOC,QAAUN,UAIbO,QAAAL,kBAEDM,QAAKL,cACJM,MACAC,SAAIC,oBAEJH,KAAII,WACJ,IAAIC,EAAAA,QAAJ,OAHIF,OAAAA,EAKJG,KAHIF,KACAC,KAKAL,EAAO,WAKJO,KAAKC,OACRD,KAAKC,KAAL,KAGED,KAAKE,WACPC,KAAMF,SAAKC,WAGbN,KAASO,YAHPA,EAAMH,KAAKE,YAGbN,EAASO,EAAIC,gBAMJC,GAAL,aAAe,SAAAC,GAGhB,GAFCA,KAAAA,IAAOC,MAAP,iBAAAD,EAAAE,WAEDR,KAAAS,cAAAT,KAAAS,aAAAC,QAAAJ,EAAAE,WAAA,EAGDG,OANEX,KAAKK,IAAIO,MAAM,6BAA8BN,EAAOE,WAKtDV,EAAQe,OACRF,EAGEb,EAAAe,KAAAP,GACFV,EAAcU,IACZQ,KAAIC,OAEF,IACDnB,EAAAoB,OAAAhB,KAAAiB,KAAAjB,KAAAC,SAAA,SAAAc,GACIA,IAHHf,KAAKK,IAAIO,MAAM,wBAAyBG,GAKvCV,KAAIO,KAAM,QAAAG,KAEfD,KAAQd,OAERA,KAAOe,IAAPH,MAAY,8BAAAZ,KAAAC,SAAA,IAAAD,KAAAiB,MAEZjB,KAAKkB,GAAAA,iBAALC,GACDnB,KAAAkB,SAAA,SA3CQ,MAAXH,GAyCIf,KAAKK,IAAIe,MAAM,6BAA+BL,EAAM,WAAYf,KAAKC,SAAW,IAAMD,KAAKiB,MAK/FjB,KAAAkB,SAAA,WAFEJ,KAAKd,MAKHmB,EAAQ,WAKV,IAAItB,KAAKwB,QAAL,eAIU,IAATH,EAAAA,OAAL,CAIAlB,KAAKsB,SAAOC,cAFZ,IAAIA,EAAU1B,EAAK2B,QAEnBxB,KAAKsB,OAAOC,EAAQE,IAAK,SAAUC,GAKjCC,KAAKC,IAAAA,MAAAA,oBAELD,IAAKC,EAAAA,OAAcF,YAASL,GAF5BM,EAAKC,cAAcL,EAAQM,QAAQC,SAAU,GAK7CH,EAAII,cAAaC,EAAOH,QAAOH,aAA/B,GAHAC,EAAKC,cAAcF,EAASL,OAAS,EAAG,GAKxCE,EAAAA,WAAeU,EAAfJ,QAAAK,QAAA,GAEA,IAAKhB,EAAAA,OAASc,QAAdL,EAAAD,IA3BQH,EAAZjB,OAAA2B,MAAAF,GA+BA/B,KAAAkB,SAAA,UAHIJ,KAAKd,SACPc,KAAKd,MASHH,EAAA,SAAAS,GACAa,IAAAA,EAAAA,EAAAA,OAOEgB,EAAUpC,WACVA,EAAIqC,QAAmBC,EAEtB,IAAA,IAAAC,EAAAvC,EAAAsB,OAAA,EAAAiB,GAAA,EAAAA,GAAA,EAAA,CAEF,QAAAD,IADYE,EAAXD,GAEGjC,MAFHN,EAAWwC,OAAOD,EAAG,GAMvBhC,KAAAA,IAAQA,MADsB,gDAAAP,EAAAsB,SAE9BmB,KAAAA,MAEAC,EAAON,cAJT7B,OAAAA,EAEEkC,SAAUA,EAKZzC,UAzBqB,SAAU2C,GAK3BP,EAAAA,KAAAA,GACFpC,KATiB0C,MAArBN,IAgCEpC,EAAAc,KAAcf,IACZA,KAAAA,MAFJE,KAAK2C,MAAQ,SAAUC,GAKrBhD,IAAO+C,IAAAA,KAAM7C,EACXF,EAAOiD,GAAPC,UACgBlD,EAAA+C,MAAA,WAFlB/C,EAAAiD,QALFD,GAAAA,OAWAnD","file":"../modbus-tcp-server.js","sourcesContent":["/**\n * Modbus TCP server.\n * @module ModbusTCPServer\n */\n'use strict'\n\nlet stampit = require('stampit')\nlet ModbusServerCore = require('./modbus-server-core.js')\nlet StateMachine = require('stampit-state-machine')\nlet ClientSocket = require('./modbus-tcp-server-client.js')\n\nmodule.exports = stampit()\n  .compose(ModbusServerCore)\n  .compose(StateMachine)\n  .refs({\n    'logLabel': 'ModbusTCPServer'\n  })\n  .init(function () {\n    let net = require('net')\n    let server\n    let socketList = []\n    let fifo = []\n    let clients = []\n\n    /**\n     * Initialization of the modbus TCP server.\n     */\n    let init = function () {\n      if (!this.port) {\n        this.port = 502\n      }\n\n      if (!this.hostname) {\n        this.hostname = '0.0.0.0'\n      }\n\n      if (this.netInject) {\n        net = this.netInject\n      }\n\n      server = net.createServer()\n\n      server.on('connection', function (socket) {\n        this.log.debug('new connection', socket.address())\n\n        if (this.whiteListIPs && this.whiteListIPs.indexOf(socket.address()) < 0) {\n          this.log.debug('client connection REJECTED', socket.address())\n          socket.end()\n          return false\n        }\n\n        clients.push(socket)\n        initiateSocket(socket)\n      }.bind(this))\n\n      try {\n        server.listen(this.port, this.hostname, function (err) {\n          if (err) {\n            this.log.debug('error while listening', err)\n            this.emit('error', err)\n          }\n        }.bind(this))\n\n        this.log.debug('server is listening on port', this.hostname + ':' + this.port)\n\n        this.on('newState_ready', flush)\n        this.setState('ready')\n      } catch (err) {\n        this.log.error('server is listening error ' + err + ' on port', this.hostname + ':' + this.port)\n        this.setState('error')\n      }\n    }.bind(this)\n\n    /**\n     * Flush incoming data.\n     */\n    let flush = function () {\n      if (this.inState('processing')) {\n        return\n      }\n\n      if (fifo.length === 0) {\n        return\n      }\n\n      this.setState('processing')\n\n      let current = fifo.shift()\n\n      this.onData(current.pdu, function (response) {\n        this.log.debug('sending tcp data')\n\n        let head = Buffer.allocUnsafe(7)\n\n        head.writeUInt16BE(current.request.trans_id, 0)\n        head.writeUInt16BE(current.request.protocol_ver, 2)\n        head.writeUInt16BE(response.length + 1, 4)\n        head.writeUInt8(current.request.unit_id, 6)\n\n        let pkt = Buffer.concat([head, response])\n\n        current.socket.write(pkt)\n\n        this.setState('ready')\n      }.bind(this))\n    }.bind(this)\n\n    /**\n     * Initiate socket on client requests.\n     */\n    let initiateSocket = function (socket) {\n      let socketId = socketList.length\n\n      let requestHandler = function (req) {\n        fifo.push(req)\n        flush()\n      }\n\n      let removeHandler = function () {\n        socketList[socketId] = undefined\n        /* remove undefined on the end of the array */\n        for (let i = socketList.length - 1; i >= 0; i -= 1) {\n          let cur = socketList[i]\n          if (cur !== undefined) {\n            break\n          }\n          socketList.splice(i, 1)\n        }\n        this.log.debug('Client connection closed, remaining clients. ', socketList.length)\n      }.bind(this)\n\n      let clientSocket = ClientSocket({\n        socket: socket,\n        socketId: socketId,\n        onRequest: requestHandler,\n        onEnd: removeHandler\n      })\n\n      socketList.push(clientSocket)\n    }.bind(this)\n\n    this.close = function (cb) {\n      for (let c in clients) {\n        clients[c].destroy()\n      }\n\n      server.close(function () {\n        server.unref()\n        if (cb) { cb() }\n      })\n    }\n\n    init()\n  })\n"]}