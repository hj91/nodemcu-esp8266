{"version":3,"sources":["core/modbus-io-core.js"],"names":["require","install","de","biancoroyal","modbus","io","core","internalDebug","nameValuesFromIOFile","msg","ioFileConfig","values","response","readingOffset","valueNames","configData","mapping","forEach","valueAddress","startsWith","buildInputAddressMapping","Number","addressOffset","buildOutputAddressMapping","ioCore","insertValues","convertValuesByType","allValueNamesFromIOFile","ioNode","getDataTypeFromFirstCharType","type","registerName","offset","addressStart","coilStart","bits","name","substring","registerType","split","addressType","Math","floor","bitAddress","addressStartIO","addressOffsetIO","registerAddress","Bit","dataType","error","register","index","item","hasOwnProperty","JSON","stringify","isRegisterSizeWrong","value","pow","getValueFromBufferByDataType","bufferOffset","responseBuffer","registerLength","length","readUInt16BE","readInt8","readInt16BE","convertedValue","readInt32BE","readIntBE","readFloatBE","readDoubleBE","readUInt8","readUInt32BE","readUIntBE","sixteenBitBufferLength","Buffer","buffer","filterValueNames","fc","adr","quantity","functionType","startRegister","endRegister","valueName","filter","start","sizeDivisor","module","exports"],"mappings":"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","file":"../../core/modbus-io-core.js","sourcesContent":["/**\n Copyright 2016,2017 - Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\nvar de = de || {biancoroyal: {modbus: {io: {core: {}}}}} // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.internalDebug = de.biancoroyal.modbus.io.core.internalDebug || require('debug')('contribModbus:io:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.LineByLineReader = de.biancoroyal.modbus.io.core.LineByLineReader || require('line-by-line') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.io.core.nameValuesFromIOFile = function (msg, ioFileConfig, values, response, readingOffset) {\n  let valueNames = []\n  let ioCore = de.biancoroyal.modbus.io.core\n\n  if (ioFileConfig.configData) {\n    ioFileConfig.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(ioFileConfig.addressOffset), Number(readingOffset)))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(ioFileConfig.addressOffset), Number(readingOffset)))\n      }\n    })\n  }\n\n  valueNames = ioCore.insertValues(valueNames, values)\n\n  return ioCore.convertValuesByType(valueNames, values, response)\n}\n\nde.biancoroyal.modbus.io.core.allValueNamesFromIOFile = function (ioNode) {\n  let valueNames = []\n  let ioCore = de.biancoroyal.modbus.io.core\n\n  if (ioNode && ioNode.configData) {\n    ioNode.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n    })\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getDataTypeFromFirstCharType = function (type) {\n  switch (type) {\n    case 'w':\n      return 'Word'\n    case 'd':\n      return 'Double'\n    case 'r':\n      return 'Real'\n    case 'f':\n      return 'Float'\n    case 'i':\n      return 'Integer'\n    case 'l':\n      return 'Long'\n    case 'b':\n      return 'Boolean'\n    default:\n      return 'Unsigned Integer'\n  }\n}\n\nde.biancoroyal.modbus.io.core.buildInputAddressMapping = function (registerName, mapping, offset, readingOffset) {\n  let ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  let type = mapping.name.substring(0, 1)\n  let registerType = mapping.valueAddress.substring(2, 3)\n  let addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%IX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      ioCore.internalDebug('unknown input type ' + type)\n      bits = 0\n  }\n\n  if (bits) {\n    let addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      'register': registerName,\n      'name': mapping.name,\n      'addressStart': addressStart,\n      'addressOffset': addressOffset,\n      'addressOffsetIO': Number(offset) || 0,\n      'addressStartIO': addressStartIO,\n      'registerAddress': addressStartIO - Number(readingOffset),\n      'coilStart': coilStart,\n      'bitAddress': bitAddress,\n      'Bit': (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      'bits': bits,\n      'dataType': ioCore.getDataTypeFromFirstCharType(type),\n      'type': 'input'\n    }\n  }\n\n  return {'name': mapping.name, 'type': type, 'mapping': mapping, 'error': 'variable name does not match input mapping'}\n}\n\nde.biancoroyal.modbus.io.core.buildOutputAddressMapping = function (registerName, mapping, offset, readingOffset) {\n  let ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  let type = mapping.name.substring(0, 1)\n  let registerType = mapping.valueAddress.substring(2, 3)\n  let addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%QX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      ioCore.internalDebug('unknown output type ' + type)\n      bits = 0\n  }\n\n  if (bits) {\n    let addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      'register': registerName,\n      'name': mapping.name,\n      'addressStart': addressStart,\n      'addressOffset': addressOffset,\n      'addressOffsetIO': Number(offset) || 0,\n      'addressStartIO': addressStartIO,\n      'registerAddress': addressStartIO - Number(readingOffset),\n      'coilStart': coilStart,\n      'bitAddress': bitAddress,\n      'Bit': (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      'bits': bits,\n      'dataType': ioCore.getDataTypeFromFirstCharType(type),\n      'type': 'output'\n    }\n  }\n\n  return {'name': mapping.name, 'type': type, 'mapping': mapping, 'error': 'variable name does not match output mapping'}\n}\n\nde.biancoroyal.modbus.io.core.insertValues = function (valueNames, register) {\n  let ioCore = de.biancoroyal.modbus.io.core\n\n  let index = 0\n  for (index in valueNames) {\n    let item = valueNames[index]\n\n    if (!item || !item.hasOwnProperty('registerAddress') || item.registerAddress < 0) {\n      ioCore.internalDebug('Item Not Valid To Insert Value ' + JSON.stringify(item))\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      break\n    }\n\n    switch (Number(item.bits)) {\n      case 1:\n        item.value = !!((register[item.registerAddress] & Math.pow(item.bitAddress[1], 2)))\n        break\n      case 16:\n        item.value = register[item.registerAddress]\n        break\n      case 32:\n        item.value = register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 64:\n        item.value = register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 80:\n        item.value = register[item.registerAddress + 4] << 64 |\n          register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      default:\n        item.value = null\n        break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getValueFromBufferByDataType = function (item, bufferOffset, responseBuffer) {\n  let ioCore = de.biancoroyal.modbus.io.core\n  let registerLength = responseBuffer.length / 2\n\n  if (bufferOffset < 0 || bufferOffset > responseBuffer.length) {\n    ioCore.internalDebug('Wrong Buffer Access Parameter Type:' + item.dataType + ' Register-Length: ' + registerLength +\n      ' Buffer-Length:' + responseBuffer.length + ' Address-Buffer-Offset:' + bufferOffset)\n    ioCore.internalDebug(JSON.stringify(item))\n    return item\n  }\n\n  ioCore.internalDebug('Get Value From Buffer By Data Type:' + item.dataType + ' Register:' + item.registerAddress + ' Bits:' + Number(item.bits))\n\n  switch (item.dataType) {\n    case 'Boolean':\n      item.value = !!(responseBuffer.readUInt16BE(bufferOffset) & Math.pow(item.bitAddress[1], 2))\n      break\n    case 'Word':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset) // DWord\n          item.convertedValue = false\n      }\n      break\n    case 'Integer':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset)\n      }\n      break\n    case 'Real':\n    case 'Float':\n      item.value = responseBuffer.readFloatBE(bufferOffset, 4)\n      break\n    case 'Double':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 8)\n      break\n    case 'Long':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 10)\n      break\n    default:\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readUInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readUInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readUIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readUInt16BE(bufferOffset)\n          item.convertedValue = false\n      }\n      break\n  }\n\n  return item\n}\n\nde.biancoroyal.modbus.io.core.convertValuesByType = function (valueNames, register, responseBuffer) {\n  let ioCore = de.biancoroyal.modbus.io.core\n  let bufferOffset = 0\n  let sixteenBitBufferLength = 2\n\n  let index = 0\n  for (index in valueNames) {\n    let item = valueNames[index]\n\n    if (!item || !item.hasOwnProperty('dataType') || !item.hasOwnProperty('registerAddress') || item.registerAddress < 0) {\n      ioCore.internalDebug('Item Not Valid To Convert ' + JSON.stringify(item))\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      break\n    }\n\n    if (responseBuffer.buffer instanceof Buffer) {\n      bufferOffset = Number(item.registerAddress) * sixteenBitBufferLength\n      try {\n        item = ioCore.getValueFromBufferByDataType(item, bufferOffset, responseBuffer.buffer)\n      } catch (err) {\n        ioCore.internalDebug(err.message)\n      }\n    } else {\n      ioCore.internalDebug('Response Buffer Is Not A Buffer ' + JSON.stringify(responseBuffer))\n      break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.filterValueNames = function (valueNames, fc, adr, quantity) {\n  let ioCore = de.biancoroyal.modbus.io.core\n  let functionType = 'input'\n\n  if (fc === 2 || fc === 4) {\n    functionType = 'output'\n  }\n\n  let startRegister = adr\n  let endRegister = Number(adr) + Number(quantity) - 1\n\n  ioCore.internalDebug('adr:' + adr + ' quantity:' + quantity + ' startRegister:' + startRegister + ' endRegister:' + endRegister + ' functionType:' + functionType)\n\n  return valueNames.filter((valueName) => {\n    return (valueName.registerAddress >= 0 &&\n      valueName.addressStartIO >= startRegister &&\n      valueName.addressStartIO <= endRegister &&\n      valueName.type === functionType)\n  })\n}\n\nde.biancoroyal.modbus.io.core.isRegisterSizeWrong = function (register, start, bits) {\n  let sizeDivisor = Number(bits) || 16\n  let startRegister = Number(start)\n  let endRegister = startRegister\n\n  if (sizeDivisor > 16) {\n    endRegister = startRegister + (sizeDivisor / 16) - 1\n  }\n\n  return (startRegister < 0 || register.length < startRegister || endRegister > register.length)\n}\n\nmodule.exports = de.biancoroyal.modbus.io.core\n"]}