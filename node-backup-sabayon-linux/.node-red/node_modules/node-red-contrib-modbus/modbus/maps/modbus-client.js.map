{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","install","coreModbusClient","require","nodes","registerType","config","createNode","this","timeoutTimeMS","clienttype","reconnectTimeMS","bufferCommands","stateLogEnabled","tcpType","tcpPort","parseInt","serialBaudrate","serialDatabits","serialPort","serialStopbits","serialConnectionDelay","serialType","clientTimeout","minCommandDelayMilliseconds","unit_id","reconnectTimeout","node","verboseWarn","logMessage","settings","verbose","serverInfo","verboseLog","stateLog","queueLog","client","Map","sendAllowed","bufferCommandList","messagesAllowedStates","messageAllowedStates","createStatelyMachine","statlyMachine","clear","initQueue","step","unitSendingAllowed","set","checkUnitId","unitid","setUnitIdFromPayload","msg","unit","payload","queueUnitId","defaultUnitId","Number","isNaN","command","noneCommandSent","sequentialDequeueCommand","shift","serialUnit","JSON","stringify","type","get","length","sendAllowedForNext","queueLength","push","callModbus","cb","cberr","empty","dequeueCommand","state","getMachineState","indexOf","commandDelay","checkQueuesAreEmpty","queueIsEmpty","updateServerinfo","tcpHost","onINIT","event","oldState","newState","setTimeout","connectClient","onCONNECTED","activate","onACTIVATED","emit","queue","onQUEUEING","onOPENED","onCLOSED","break","onFAILED","onBROKEN","init","close","err","message","ModbusRTU","Error","failure","connectC701","port","autoOpen","setTCPConnected","then","setTCPConnectionOptions","connectTelnet","catch","modbusTcpErrorHandling","connectTCP","error","baudRate","dataBits","stopBits","parity","serialParity","setSerialConnectionOptions","connectRTU","connectRTUBuffered","modbusSerialDebug","connect","openSerialClient","modbusErrorHandling","networkErrors","includes","errno","_port","on","onModbusClose","getQueueNumber","isInteger","pushToQueueByUnitId","info","queueUnit","queueNumber","readModbus","timeout","getTimeout","fc","readCoils","address","quantity","resp","activateSending","readDiscreteInputs","readHoldingRegisters","internalDebug","writeModbus","write","writeCoils","value","writeRegister","setMaxListeners","connectorType","unitId","done","stop","httpAdmin","auth","needsPermission","req","res","list","ports","console","log","json"],"mappings":"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","file":"../modbus-client.js","sourcesContent":["/**\n Copyright 2016,2017 - Klaus Landsdorf (http://bianco-royal.de/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let coreModbusClient = require('./core/modbus-client-core')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    let ModbusRTU = require('modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n\n    this.clienttype = config.clienttype\n    this.bufferCommands = config.bufferCommands\n    this.stateLogEnabled = config.stateLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n\n    this.unit_id = parseInt(config.unit_id) || defaultUnitId\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n\n    let node = this\n\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messagesAllowedStates\n    node.serverInfo = ''\n\n    node.statlyMachine = null\n    node.statlyMachine = coreModbusClient.createStatelyMachine()\n\n    node.initQueue = function () {\n      node.bufferCommandList.clear()\n      node.sendAllowed.clear()\n      node.unitSendingAllowed = []\n\n      for (let step = 0; step <= 255; step++) {\n        node.bufferCommandList.set(step, [])\n        node.sendAllowed.set(step, true)\n      }\n    }\n\n    node.checkUnitId = function (unitid) {\n      if (node.clienttype === 'tcp') {\n        return unitid >= 0 && unitid <= 255\n      } else {\n        return unitid >= 1 && unitid <= 247\n      }\n    }\n\n    node.setUnitIdFromPayload = function (msg) {\n      let unit = parseInt(msg.payload.unitid)\n\n      if (Number.isInteger(unit)) {\n        node.client.setID(unit)\n        msg.queueUnitId = unit\n      } else {\n        if (!node.checkUnitId(node.unit_id)) {\n          node.unit_id = defaultUnitId\n        }\n        node.client.setID(node.unit_id)\n        msg.queueUnitId = node.unit_id\n      }\n    }\n\n    if (Number.isNaN(node.unit_id) || !node.checkUnitId(node.unit_id)) {\n      node.unit_id = defaultUnitId\n    }\n\n    node.sequentialDequeueCommand = function () {\n      let command = null\n      let noneCommandSent = true\n      let serialUnit = parseInt(node.unitSendingAllowed.shift())\n\n      if (Number.isInteger(serialUnit) &&\n        node.bufferCommandList.get(serialUnit).length > 0) {\n        queueLog(JSON.stringify({\n          type: 'queue check',\n          unitid: serialUnit,\n          sendAllowed: node.sendAllowed.get(serialUnit),\n          queueLength: node.bufferCommandList.get(serialUnit).length\n        }))\n\n        if (node.sendAllowed.get(serialUnit)) {\n          command = node.bufferCommandList.get(serialUnit).shift()\n          if (command) {\n            node.sendAllowed.set(serialUnit, false)\n            queueLog(JSON.stringify({\n              type: 'serial sending and wait',\n              unitid: serialUnit,\n              // commandData: command,\n              queueLength: node.bufferCommandList.get(serialUnit).length,\n              sendAllowedForNext: node.sendAllowed.get(serialUnit),\n              delay: node.commandDelay\n            }))\n\n            if (node.bufferCommandList.get(serialUnit).length > 0) {\n              node.unitSendingAllowed.push(serialUnit)\n            }\n            noneCommandSent = false\n            command.callModbus(command.msg, command.cb, command.cberr)\n          }\n        }\n      } else {\n        queueLog(JSON.stringify({\n          type: 'queue check is not a unit',\n          unitid: serialUnit\n        }))\n      }\n\n      if (noneCommandSent) {\n        node.statlyMachine.empty()\n      }\n    }\n\n    node.dequeueCommand = function () {\n      let state = node.statlyMachine.getMachineState()\n\n      if (node.messageAllowedStates.indexOf(state) === -1) {\n        queueLog(JSON.stringify({\n          state: state,\n          message: 'dequeue command disallowed state',\n          delay: node.commandDelay\n        }))\n      } else {\n        queueLog(JSON.stringify({\n          state: state,\n          message: 'dequeue command ' + node.clienttype,\n          delay: node.commandDelay\n        }))\n\n        node.sequentialDequeueCommand()\n      }\n\n      if (node.checkQueuesAreEmpty()) {\n        node.statlyMachine.empty()\n      }\n    }\n\n    node.checkQueuesAreEmpty = function () {\n      let queueIsEmpty = true\n      for (let step = 0; step <= 255; step++) {\n        queueIsEmpty &= (node.bufferCommandList.get(step).length > 0)\n      }\n      return queueIsEmpty\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    function queueLog (logMessage) {\n      if (node.bufferCommands) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.statlyMachine.onINIT = function (event, oldState, newState) {\n      node.updateServerinfo()\n      node.initQueue()\n      setTimeout(node.connectClient, node.reconnectTimeout)\n      verboseWarn('reconnect in ' + node.reconnectTimeout + ' ms')\n      verboseLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbinit')\n    }\n\n    node.statlyMachine.onCONNECTED = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbconnected')\n      node.statlyMachine.activate()\n    }\n\n    node.statlyMachine.onACTIVATED = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbactive')\n      if (node.bufferCommands) {\n        node.statlyMachine.queue()\n      }\n    }\n\n    node.statlyMachine.onQUEUEING = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      setTimeout(node.dequeueCommand, node.commandDelay)\n      node.emit('mbqueue')\n    }\n\n    node.statlyMachine.onOPENED = function (event, oldState, newState) {\n      verboseLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbopen')\n    }\n\n    node.statlyMachine.onCLOSED = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbclosed')\n      node.statlyMachine.break()\n    }\n\n    node.statlyMachine.onFAILED = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mberror', 'FSM Reset On State ' + oldState)\n      node.statlyMachine.break()\n    }\n\n    node.statlyMachine.onBROKEN = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbbroken')\n      if (node.reconnectTimeout <= 0) {\n        node.reconnectTimeout = reconnectTimeMS\n      }\n      verboseWarn('try to reconnect by init in ' + node.reconnectTimeout + ' ms')\n      setTimeout(node.statlyMachine.init, node.reconnectTimeout)\n    }\n\n    node.connectClient = function () {\n      if (node.client) {\n        try {\n          node.client.close(function () {\n            verboseLog('connection closed')\n          })\n        } catch (err) {\n          verboseLog(err.message)\n        }\n      }\n      node.client = null\n      node.client = new ModbusRTU()\n\n      if (!node.clientTimeout) {\n        node.clientTimeout = timeoutTimeMS\n      }\n      if (!node.reconnectTimeout) {\n        node.reconnectTimeout = reconnectTimeMS\n      }\n\n      if (node.clienttype === 'tcp') {\n        if (!node.checkUnitId(node.unit_id)) {\n          node.error(new Error('wrong unit-id (0..255)'), {payload: node.unit_id})\n          node.statlyMachine.failure()\n          return\n        }\n\n        switch (node.tcpType) {\n          case 'C701':\n            verboseLog('C701 port UDP bridge')\n            node.client.connectC701(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .then(node.setTCPConnected)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TELNET':\n            verboseLog('Telnet port')\n            node.client.connectTelnet(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TPC-RTU-BUFFERED':\n            verboseLog('TCP RTU buffered port')\n            node.client.connectTcpRTUBuffered(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          default:\n            verboseLog('TCP port')\n            node.client.connectTCP(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n        }\n      } else {\n        if (!node.checkUnitId(node.unit_id)) {\n          node.error(new Error('wrong unit-id serial (1..247)'), {payload: node.unit_id})\n          node.statlyMachine.failure()\n          return\n        }\n\n        if (!node.serialConnectionDelay) {\n          node.serialConnectionDelay = serialConnectionDelayTimeMS\n        }\n\n        if (!node.serialPort) {\n          node.error(new Error('wrong serial port'), {payload: node.serialPort})\n          node.statlyMachine.failure()\n        }\n\n        switch (node.serialType) {\n          case 'ASCII':\n            verboseLog('ASCII port serial')\n            node.client.connectAsciiSerial(node.serialPort, {\n              baudRate: parseInt(node.serialBaudrate),\n              dataBits: parseInt(node.serialDatabits),\n              stopBits: parseInt(node.serialStopbits),\n              parity: node.serialParity,\n              autoOpen: false\n            }).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          case 'RTU':\n            verboseLog('RTU port serial')\n            node.client.connectRTU(node.serialPort, {\n              baudRate: parseInt(node.serialBaudrate),\n              dataBits: parseInt(node.serialDatabits),\n              stopBits: parseInt(node.serialStopbits),\n              parity: node.serialParity,\n              autoOpen: false\n            }).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          default:\n            verboseLog('RTU buffered port serial')\n            node.client.connectRTUBuffered(node.serialPort, {\n              baudRate: parseInt(node.serialBaudrate),\n              dataBits: parseInt(node.serialDatabits),\n              stopBits: parseInt(node.serialStopbits),\n              parity: node.serialParity,\n              autoOpen: false\n            }).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n        }\n      }\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.statlyMachine.connect()\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.statlyMachine.openserial()\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.statlyMachine.failure()\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.statlyMachine.failure()\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n      }\n      node.statlyMachine.failure()\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.statlyMachine.getMachineState() === 'OPENED') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.statlyMachine.connect()\n      } else {\n        verboseLog('wrong state on connect serial ' + node.statlyMachine.getMachineState())\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.statlyMachine.getMachineState())\n        node.statlyMachine.failure()\n      }\n    }\n\n    node.onModbusClose = function () {\n      verboseWarn('modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.statlyMachine.close()\n    }\n\n    node.getQueueNumber = function (msg) {\n      let unit = parseInt(msg.payload.unitid)\n\n      if (Number.isInteger(unit)) {\n        return node.bufferCommandList.get(unit).length\n      } else {\n        return node.bufferCommandList.get(node.unit_id).length\n      }\n    }\n\n    node.pushToQueueByUnitId = function (callModbus, msg, cb, cberr) {\n      let unit = parseInt(msg.payload.unitid)\n\n      if (Number.isInteger(unit)) {\n        msg.queueUnit = unit\n        queueLog(JSON.stringify({\n          info: 'push to Queue by Unit-Id',\n          message: msg.payload,\n          unit: unit\n        }))\n\n        if (node.unitSendingAllowed.indexOf(unit) === -1) {\n          node.unitSendingAllowed.push(unit)\n        }\n\n        node.bufferCommandList.get(unit).push({callModbus: callModbus, msg: msg, cb: cb, cberr: cberr})\n      } else {\n        msg.queueUnit = node.unit_id\n        queueLog(JSON.stringify({\n          info: 'push to Queue by default Unit-Id',\n          message: msg.payload,\n          unit: node.unit_id\n        }))\n\n        if (node.unitSendingAllowed.indexOf(node.unit_id) === -1) {\n          node.unitSendingAllowed.push(node.unit_id)\n        }\n\n        node.bufferCommandList.get(node.unit_id).push({callModbus: callModbus, msg: msg, cb: cb, cberr: cberr})\n      }\n    }\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      let state = node.statlyMachine.getMachineState()\n\n      if (node.messageAllowedStates.indexOf(state) === -1) {\n        cberr(new Error('FSM Not Ready To Read At State ' + state), msg)\n        return\n      }\n\n      if (node.bufferCommands) {\n        msg.queueNumber = node.getQueueNumber(msg)\n        node.pushToQueueByUnitId(node.readModbus, msg, cb, cberr)\n        node.statlyMachine.queue()\n\n        queueLog(JSON.stringify({\n          info: 'queue read msg',\n          message: msg.payload,\n          state: state,\n          queueLength: node.bufferCommandList.get(msg.queueUnit).length\n        }))\n      } else {\n        node.readModbus(msg, cb, cberr)\n      }\n    })\n\n    node.readModbus = function (msg, cb, cberr) {\n      if (!node.client) {\n        return\n      }\n\n      if (!node.bufferCommands) {\n        node.statlyMachine.read()\n      }\n\n      node.setUnitIdFromPayload(msg)\n      node.client.setTimeout(node.clientTimeout)\n\n      queueLog(JSON.stringify({\n        info: 'read msg',\n        message: msg.payload,\n        unitid: msg.queueUnitId,\n        timeout: node.client.getTimeout(),\n        state: node.statlyMachine.getMachineState()\n      }))\n\n      switch (parseInt(msg.payload.fc)) {\n        case 1: // FC: 1\n          node.client.readCoils(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n            node.activateSending(msg)\n            cb(resp, msg)\n          }).catch(function (err) {\n            node.activateSending(msg)\n            cberr(err, msg)\n            node.modbusErrorHandling(err)\n          })\n          break\n        case 2: // FC: 2\n          node.client.readDiscreteInputs(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n            node.activateSending(msg)\n            cb(resp, msg)\n          }).catch(function (err) {\n            node.activateSending(msg)\n            cberr(err, msg)\n            node.modbusErrorHandling(err)\n          })\n          break\n        case 3: // FC: 3\n          node.client.readHoldingRegisters(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n            node.activateSending(msg)\n            cb(resp, msg)\n          }).catch(function (err) {\n            node.activateSending(msg)\n            cberr(err, msg)\n            node.modbusErrorHandling(err)\n          })\n          break\n        case 4: // FC: 4\n          node.client.readInputRegisters(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n            node.activateSending(msg)\n            cb(resp, msg)\n          }).catch(function (err) {\n            node.activateSending(msg)\n            cberr(err, msg)\n            node.modbusErrorHandling(err)\n          })\n          break\n        default:\n          node.activateSending(msg)\n          cberr(new Error('Function Code Unknown'), msg)\n          coreModbusClient.internalDebug('Function Code Unknown %s', msg.payload.fc)\n          break\n      }\n    }\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      let state = node.statlyMachine.getMachineState()\n\n      if (node.messageAllowedStates.indexOf(state) === -1) {\n        cberr(new Error('FSM Not Ready To Write At State ' + state), msg)\n        return\n      }\n\n      if (node.bufferCommands) {\n        msg.queueNumber = node.getQueueNumber(msg)\n        node.pushToQueueByUnitId(node.writeModbus, msg, cb, cberr)\n        node.statlyMachine.queue()\n\n        queueLog(JSON.stringify({\n          info: 'queue write msg',\n          message: msg.payload,\n          state: state,\n          queueLength: node.bufferCommandList.get(msg.queueUnit).length\n        }))\n      } else {\n        node.writeModbus(msg, cb, cberr)\n      }\n    })\n\n    node.writeModbus = function (msg, cb, cberr) {\n      if (!node.client) {\n        return\n      }\n\n      if (!node.bufferCommands) {\n        node.statlyMachine.write()\n      }\n\n      node.setUnitIdFromPayload(msg)\n      node.client.setTimeout(node.clientTimeout)\n\n      queueLog(JSON.stringify({\n        info: 'write msg',\n        message: msg.payload,\n        unitid: msg.queueUnitId,\n        timeout: node.client.getTimeout(),\n        state: node.statlyMachine.getMachineState()\n      }))\n\n      switch (parseInt(msg.payload.fc)) {\n        case 15: // FC: 15\n          if (parseInt(msg.payload.value.length) !== parseInt(msg.payload.quantity)) {\n            node.activateSending(msg)\n            cberr(new Error('Quantity should be less or equal to coil payload array length: ' +\n              msg.payload.value.length + ' Addr: ' + msg.payload.address + ' Q: ' + msg.payload.quantity), msg)\n          } else {\n            node.client.writeCoils(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n              node.activateSending(msg)\n              cb(resp, msg)\n            }).catch(function (err) {\n              node.activateSending(msg)\n              cberr(err, msg)\n              node.modbusErrorHandling(err)\n            })\n          }\n          break\n        case 5: // FC: 5\n          node.client.writeCoil(parseInt(msg.payload.address), (msg.payload.value === true)).then(function (resp) {\n            node.activateSending(msg)\n            cb(resp, msg)\n          }).catch(function (err) {\n            node.activateSending(msg)\n            cberr(err, msg)\n            node.modbusErrorHandling(err)\n          })\n          break\n        case 16: // FC: 16\n          if (parseInt(msg.payload.value.length) !== parseInt(msg.payload.quantity)) {\n            node.activateSending(msg)\n            cberr(new Error('Quantity should be less or equal to register payload array length: ' +\n              msg.payload.value.length + ' Addr: ' + msg.payload.address + ' Q: ' + msg.payload.quantity), msg)\n          } else {\n            node.client.writeRegisters(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n              node.activateSending(msg)\n              cb(resp, msg)\n            }).catch(function (err) {\n              node.activateSending(msg)\n              cberr(err, msg)\n              node.modbusErrorHandling(err)\n            })\n          }\n          break\n        case 6: // FC: 6\n          node.client.writeRegister(parseInt(msg.payload.address), parseInt(msg.payload.value)).then(function (resp) {\n            node.activateSending(msg)\n            cb(resp, msg)\n          }).catch(function (err) {\n            node.activateSending(msg)\n            cberr(err, msg)\n            node.modbusErrorHandling(err)\n          })\n          break\n        default:\n          node.activateSending(msg)\n          cberr(new Error('Function Code Unknown'), msg)\n          coreModbusClient.internalDebug('Function Code Unknown %s', msg.payload.fc)\n          break\n      }\n    }\n\n    node.activateSending = function (msg) {\n      if (node.bufferCommands) {\n        node.sendAllowed.set(msg.queueUnit, true)\n\n        queueLog(JSON.stringify({\n          info: 'queue response activate sending',\n          message: msg.payload,\n          queueLength: node.bufferCommandList.length\n        }))\n      }\n      node.statlyMachine.activate()\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n    node.statlyMachine.init()\n\n    node.on('reconnect', function () {\n      node.statlyMachine.failure().close()\n    })\n\n    node.on('dynamicReconnect', function (msg) {\n      if (!msg || !msg.payload) {\n        throw new Error('Message Payload not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n\n      switch (msg.payload.connectorType) {\n        case 'TCP':\n          node.tcpHost = msg.payload.tcpHost || node.tcpHost\n          node.tcpPort = msg.payload.tcpPort || node.tcpPort\n          node.tcpType = msg.payload.tcpType || node.tcpType\n\n          coreModbusClient.internalDebug('New Connection Data ' + node.tcpHost + ' ' + node.tcpPort + ' ' + node.tcpType)\n          break\n        case 'SERIAL':\n          if (msg.payload.serialPort) {\n            node.serialPort = parseInt(msg.payload.serialPort) || node.serialPort\n          }\n\n          if (msg.payload.serialBaudrate) {\n            node.serialBaudrate = parseInt(msg.payload.serialBaudrate) || node.serialBaudrate\n          }\n\n          node.serialDatabits = msg.payload.serialDatabits || node.serialDatabits\n          node.serialStopbits = msg.payload.serialStopbits || node.serialStopbits\n          node.serialParity = msg.payload.serialParity || node.serialParity\n          node.serialType = msg.payload.serialType || node.serialType\n\n          if (msg.payload.serialConnectionDelay) {\n            node.serialConnectionDelay = parseInt(msg.payload.serialConnectionDelay) || node.serialConnectionDelay\n          }\n          coreModbusClient.internalDebug('New Connection Data ' + node.serialPort + ' ' + node.serialBaudrate + ' ' + node.serialType)\n          break\n        default:\n          coreModbusClient.internalDebug('Unknown Dynamic Reconnect Type ' + msg.payload.connectorType)\n      }\n\n      if (msg.payload.unitId) {\n        node.unit_id = parseInt(msg.payload.unitId) || node.unit_id\n      }\n\n      if (msg.payload.commandDelay) {\n        node.commandDelay = parseInt(msg.payload.commandDelay) || node.commandDelay\n      }\n\n      if (msg.payload.clientTimeout) {\n        node.clientTimeout = parseInt(msg.payload.clientTimeout) || node.clientTimeout\n      }\n\n      if (msg.payload.reconnectTimeout) {\n        node.reconnectTimeout = parseInt(msg.payload.reconnectTimeout) || node.reconnectTimeout\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts')\n      node.statlyMachine.failure().close()\n    })\n\n    node.on('close', function (done) {\n      node.statlyMachine.failure().stop()\n      verboseLog('close node')\n      if (node.client) {\n        node.client.close(function () {\n          verboseLog('connection closed')\n          done()\n        }).catch(function (err) {\n          verboseLog(err.message)\n          done()\n        })\n      } else {\n        done()\n      }\n    })\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    let SerialPort = require('serialport')\n    SerialPort.list(function (err, ports) {\n      if (err) console.log(err)\n      res.json(ports)\n    })\n  })\n}\n"]}