{"version":3,"sources":["modbus-flex-connector.js"],"names":["module","exports","RED","install","mbBasics","require","internalDebugLog","nodes","registerType","config","this","name","ModbusFlexConnector","maxReconnectsPerMinute","emptyQueue","showStatusActivities","node","showErrors","modbusClient","getNode","server","setNodeStatusTo","statusValue","statusOptions","setNodeStatusProperties","status","fill","shape","onModbusInit","failureMsg","onModbusError","onModbusClose","reconnectTimeout","on","onModbusConnect","onModbusActive","msg","logMessage","client","payload","statlyMachine","getMachineState","settings","verbose","JSON","stringify","verboseLog","connectorType","emit","error","Error","onModbusReconnectDone","resp","onModbusReconnectError","err","message","setModbusError"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAA3BF,QAAOC,sBAAyBE,UAC9B,IAAAC,EAAAC,QAAA,mBAGIC,EAAmBD,QAAQ,QAARA,CAAiB,gCAuGrCH,EAAAK,MAAAC,aAAA,wBAxGH,SAAuBC,GACvBP,EAAII,MAAAA,WAAmBD,KAAAA,GAEvBK,KAAAC,KAASC,EAAAA,KACPV,KAAIK,uBAAJ,EAA2BE,EAA3BI,uBAIAH,KAAKI,WAAaL,EAAOK,WAFzBJ,KAAKC,qBAALF,EAAAM,qBACAL,KAAKG,WAAAA,EAAAA,WACLH,KAAKI,WAAaL,KAElB,IAAAO,EAAKC,KACLC,EAAkBhB,EAAlBK,MAAAY,QAAAV,EAAAW,QAkFG,SAAAC,EAAAC,GACF,IAAAC,EAAAnB,EAAAoB,wBAAAF,EAAAN,EAAAD,sBAEDC,EAAAS,OAASJ,CACPK,KAAIH,EAAgBnB,KAIlBuB,MAAOJ,EAAcI,MAFvBX,KAAKS,EAAOA,SAtFdJ,EAAA,WAKAL,EAAKY,aAAe,WAFpBP,EAAgB,eAGdA,EAAAA,gBAAgB,WADlBA,EAAA,cAKEA,EAAAA,eAAgB,WADlBA,EAAA,WAKEA,EAAAA,cAAgB,SAAhBQ,GADFR,EAAA,WAMML,EAAKC,YAFXD,EAAKc,KAAAA,IAIFd,EAAAe,cAAA,WAJHV,EAAA,WAQEA,EAAAA,eAAgB,WADlBA,EAAA,sBAAAH,EAAAc,iBAAA,WAKEX,EAAAA,GAAAA,SAAgBL,EAAAY,cACjBV,EAFDe,GAAA,cAAAjB,EAAAkB,iBAMAhB,EAAae,GAAG,WAAYjB,EAAKmB,gBAFjCjB,EAAae,GAAG,UAAUjB,EAAKY,eAC/BV,EAAae,GAAG,WAAAjB,EAAeA,gBAC/BE,EAAae,GAAG,WAAYjB,EAAKmB,eAEjCjB,EAAAA,GAAAA,QAAgB,SAAhBkB,GAsCEf,IAAgBgB,EArClBnB,EAAgBoB,SAIZF,GAAAA,EAAAG,SACDvB,EAAAD,uBAIGM,EAAgBH,EAAasB,cAAcC,mBA4B/BJ,EA9BDE,EA6BjBrC,EAAAwC,SAAAC,SAMIrC,EAAwC,iBAAf+B,EAA2BA,EAAaO,KAAKC,UAAUR,KAhC9ES,EAAAA,QAAAC,eACDzC,EAAA,qBAAAsC,KAAAC,UAAAT,EAAAG,UAICH,EAAIG,QAAQzB,WAAaE,EAAKF,WAFhCI,EAAI8B,KAAYD,mBAAeX,IAE7BA,EAAIG,MAAJ,IAAYzB,MAAAA,sCAAZsB,IAGApB,EAAAA,MAAKiC,IAAMC,MAAIA,qBAAMd,MAIxBpB,EAAAmC,sBAAA,SAAAC,EAAAhB,GApBHpB,EAAAD,sBAyBIM,EAAgB,iBACjBL,EAAAqC,uBAAA,SAAAC,EAAAlB,GAHH9B,EAAAgD,EAAAC,SAQEnD,EAASoD,eAAexC,EAAME,EAAcoC,EAAKlB,EAAKf,IAAtDjB,EAAAA,GAAAA,QAASoD,WAFXnC,EAAA","file":"../modbus-flex-connector.js","sourcesContent":["/**\n Copyright (c) 2017, Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let internalDebugLog = require('debug')('contribModbus:flex:connector')\n\n  function ModbusFlexConnector (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.maxReconnectsPerMinute = config.maxReconnectsPerMinute | 4\n    this.emptyQueue = config.emptyQueue\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    let node = this\n    let modbusClient = RED.nodes.getNode(config.server)\n\n    setNodeStatusTo('waiting')\n\n    node.onModbusInit = function () {\n      setNodeStatusTo('initialize')\n    }\n\n    node.onModbusConnect = function () {\n      setNodeStatusTo('connected')\n    }\n\n    node.onModbusActive = function () {\n      setNodeStatusTo('active')\n    }\n\n    node.onModbusError = function (failureMsg) {\n      setNodeStatusTo('failure')\n      if (node.showErrors) {\n        node.warn(failureMsg)\n      }\n    }\n\n    node.onModbusClose = function () {\n      setNodeStatusTo('closed')\n    }\n\n    node.onModbusBroken = function () {\n      setNodeStatusTo('reconnecting after ' + modbusClient.reconnectTimeout + ' msec.')\n    }\n\n    modbusClient.on('mbinit', node.onModbusInit)\n    modbusClient.on('mbconnected', node.onModbusConnect)\n    modbusClient.on('mbactive', node.onModbusActive)\n    modbusClient.on('mberror', node.onModbusError)\n    modbusClient.on('mbbroken', node.onModbusBroken)\n    modbusClient.on('mbclosed', node.onModbusClose)\n\n    node.on('input', function (msg) {\n      if (!modbusClient.client) {\n        return\n      }\n\n      if (msg && msg.payload) {\n        if (node.showStatusActivities) {\n          setNodeStatusTo(modbusClient.statlyMachine.getMachineState())\n          verboseLog(msg)\n        }\n\n        if (msg.payload.connectorType) {\n          internalDebugLog('dynamicReconnect: ' + JSON.stringify(msg.payload))\n          msg.payload.emptyQueue = node.emptyQueue\n          modbusClient.emit('dynamicReconnect', msg)\n        } else {\n          node.error(new Error('Payload Not Valid - Connector Type'), msg)\n        }\n      } else {\n        node.error(new Error('Payload Not Valid'), msg)\n      }\n    })\n\n    node.onModbusReconnectDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        setNodeStatusTo('reading done')\n      }\n    }\n\n    node.onModbusReconnectError = function (err, msg) {\n      internalDebugLog(err.message)\n      mbBasics.setModbusError(node, modbusClient, err, msg, setNodeStatusTo)\n    }\n\n    node.on('close', function () {\n      setNodeStatusTo('closed')\n    })\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        internalDebugLog((typeof logMessage === 'string') ? logMessage : JSON.stringify(logMessage))\n      }\n    }\n\n    function setNodeStatusTo (statusValue) {\n      let statusOptions = mbBasics.setNodeStatusProperties(statusValue, node.showStatusActivities)\n\n      node.status({\n        fill: statusOptions.fill,\n        shape: statusOptions.shape,\n        text: statusOptions.status\n      })\n    }\n  }\n\n  RED.nodes.registerType('modbus-flex-connector', ModbusFlexConnector)\n}\n"]}