{"version":3,"sources":["modbus-flex-getter.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","internalDebugLog","this","name","ModbusFlexGetter","showStatusActivities","showErrors","connection","getNode","ioFile","useIOForPayload","node","modbusClient","shape","text","statusOptions","status","fill","bufferMessageList","Map","setNodeStatusTo","onModbusInit","failureMsg","onModbusError","onModbusClose","reconnectTimeout","on","onModbusConnect","onModbusActive","msg","logMessage","client","payload","JSON","parse","set","messageId","parseInt","address","fc","quantity","Number","isInteger","error","value","unitid","_msgid","emit","onModbusReadDone","onModbusReadError","err","statlyMachine","getMachineState","settings","verbose","stringify","resp","origMsg","topic","response","responseBuffer","input","rawMsg","assign","useIOFile","allValueNames","lastUpdatedAt","nameValuesFromIOFile","values","mbIOCore","valueNames","data","message","setModbusError","getOriginalMessage","verboseLog"],"mappings":"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","file":"../modbus-flex-getter.js","sourcesContent":["/**\n Copyright (c) 2016,2017, Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let mbCore = require('./core/modbus-core')\n  let mbIOCore = require('./core/modbus-io-core')\n  let internalDebugLog = require('debug')('contribModbus:flex:getter')\n\n  function ModbusFlexGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n\n    let node = this\n    let modbusClient = RED.nodes.getNode(config.server)\n    node.bufferMessageList = new Map()\n\n    setNodeStatusTo('waiting')\n\n    node.onModbusInit = function () {\n      setNodeStatusTo('initialize')\n    }\n\n    node.onModbusConnect = function () {\n      setNodeStatusTo('connected')\n    }\n\n    node.onModbusActive = function () {\n      setNodeStatusTo('active')\n    }\n\n    node.onModbusError = function (failureMsg) {\n      setNodeStatusTo('failure')\n      if (node.showErrors) {\n        node.warn(failureMsg)\n      }\n    }\n\n    node.onModbusClose = function () {\n      setNodeStatusTo('closed')\n    }\n\n    node.onModbusBroken = function () {\n      setNodeStatusTo('reconnecting after ' + modbusClient.reconnectTimeout + ' msec.')\n    }\n\n    modbusClient.on('mbinit', node.onModbusInit)\n    modbusClient.on('mbconnected', node.onModbusConnect)\n    modbusClient.on('mbactive', node.onModbusActive)\n    modbusClient.on('mberror', node.onModbusError)\n    modbusClient.on('mbbroken', node.onModbusBroken)\n    modbusClient.on('mbclosed', node.onModbusClose)\n\n    node.on('input', function (msg) {\n      if (!modbusClient.client) {\n        return\n      }\n\n      if (msg.payload) {\n        try {\n          if (typeof msg.payload === 'string') {\n            msg.payload = JSON.parse(msg.payload)\n          }\n\n          msg.messageId = mbCore.getObjectId()\n          node.bufferMessageList.set(msg.messageId, msg)\n          internalDebugLog('Add Message ' + msg.messageId)\n\n          msg.payload.fc = parseInt(msg.payload.fc) || 3\n          msg.payload.unitid = parseInt(msg.payload.unitid)\n          msg.payload.address = parseInt(msg.payload.address) || 0\n          msg.payload.quantity = parseInt(msg.payload.quantity) || 1\n\n          if (!(Number.isInteger(msg.payload.fc) &&\n              msg.payload.fc >= 1 &&\n              msg.payload.fc <= 4)) {\n            node.error('FC Not Valid', msg)\n            return\n          }\n\n          if (!(Number.isInteger(msg.payload.address) &&\n              msg.payload.address >= 0 &&\n              msg.payload.address <= 65535)) {\n            node.error('Address Not Valid', msg)\n            return\n          }\n\n          if (!(Number.isInteger(msg.payload.quantity) &&\n              msg.payload.quantity >= 1 &&\n              msg.payload.quantity <= 65535)) {\n            node.error('Quantity Not Valid', msg)\n            return\n          }\n\n          msg = {\n            topic: msg.topic || node.id,\n            payload: {\n              value: msg.payload.value || msg.value,\n              unitid: msg.payload.unitid,\n              fc: msg.payload.fc,\n              address: msg.payload.address,\n              quantity: msg.payload.quantity,\n              messageId: msg.messageId\n            },\n            _msgid: msg._msgid\n          }\n\n          modbusClient.emit('readModbus', msg, node.onModbusReadDone, node.onModbusReadError)\n        } catch (err) {\n          node.error(err, msg)\n        }\n\n        if (node.showStatusActivities) {\n          setNodeStatusTo(modbusClient.statlyMachine.getMachineState())\n          verboseLog(msg)\n        }\n      } else {\n        node.error('Payload Not Valid', msg)\n      }\n    })\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        setNodeStatusTo('reading done')\n      }\n      node.send(buildMessage(resp.data, resp, msg))\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      internalDebugLog(err.message)\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg) || msg, setNodeStatusTo)\n    }\n\n    node.on('close', function () {\n      setNodeStatusTo('closed')\n    })\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        internalDebugLog((typeof logMessage === 'string') ? logMessage : JSON.stringify(logMessage))\n      }\n    }\n\n    function buildMessage (values, response, msg) {\n      let origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg) || msg\n      origMsg.payload = values\n      origMsg.topic = msg.topic\n      origMsg.responseBuffer = response\n      origMsg.input = msg\n\n      let rawMsg = Object.assign({}, origMsg)\n      rawMsg.payload = response\n      rawMsg.values = values\n      delete rawMsg['responseBuffer']\n\n      if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n        let allValueNames = mbIOCore.nameValuesFromIOFile(msg, node.ioFile, values, response, parseInt(msg.payload.address) || 0)\n        let valueNames = mbIOCore.filterValueNames(allValueNames, parseInt(msg.payload.fc) || 3,\n          parseInt(msg.payload.address) || 0,\n          parseInt(msg.payload.quantity) || 1)\n\n        if (node.useIOForPayload) {\n          origMsg.payload = valueNames\n          origMsg.values = values\n        } else {\n          origMsg.payload = values\n          origMsg.valueNames = valueNames\n        }\n\n        rawMsg.valueNames = valueNames\n        return [origMsg, rawMsg]\n      } else {\n        return [origMsg, rawMsg]\n      }\n    }\n\n    function setNodeStatusTo (statusValue) {\n      let statusOptions = mbBasics.setNodeStatusProperties(statusValue, node.showStatusActivities)\n\n      node.status({\n        fill: statusOptions.fill,\n        shape: statusOptions.shape,\n        text: statusOptions.status\n      })\n    }\n  }\n\n  RED.nodes.registerType('modbus-flex-getter', ModbusFlexGetter)\n}\n"]}