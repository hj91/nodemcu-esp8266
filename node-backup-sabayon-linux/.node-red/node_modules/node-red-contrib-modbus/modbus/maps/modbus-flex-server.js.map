{"version":3,"sources":["modbus-flex-server.js"],"names":["module","exports","RED","install","ModbusRTU","require","mbBasics","nodes","registerType","config","internalDebugLog","_require","VM","VMScript","createNode","this","logEnabled","serverAddress","serverPort","parseInt","responseDelay","delayUnit","name","compile","funcGetInputRegister","unitId","funcGetHoldingRegister","splitAddress","funcSetCoil","funcSetRegister","node","registers","Buffer","settings","verbose","server","logMessage","verboseWarn","JSON","stringify","verboseLog","fillValue","shapeValue","setNodeStatusTo","statusValue","shape","text","bufferFactor","alloc","coilsBufferSize","registersBufferSize","vector","vm","sandbox","funcGetCoil","run","startServer","ServerTCP","port","debug","host","err","unitID","close","msg","modbusHolding","modbusCoils","modbusInput","send","slice","buildMessage","type","message","payload","on","_server"],"mappings":"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","file":"../modbus-flex-server.js","sourcesContent":["/**\n Copyright (c) 2017, Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Server node.\n * @module NodeRedModbusServer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let ModbusRTU = require('modbus-serial')\n  let mbBasics = require('./modbus-basics')\n  let internalDebugLog = require('debug')('contribModbus:flex:server')\n\n  function ModbusFlexServer (config) {\n    RED.nodes.createNode(this, config)\n    const {VM, VMScript} = require('vm2')\n\n    this.name = config.name\n    this.logEnabled = config.logEnabled\n    this.serverAddress = config.serverAddress || '0.0.0.0'\n    this.serverPort = parseInt(config.serverPort)\n    this.responseDelay = parseInt(config.responseDelay)\n    this.delayUnit = config.delayUnit\n    this.unitId = config.unitId\n    this.minAddress = config.minAddress\n    this.splitAddress = config.splitAddress\n\n    this.funcGetCoil = new VMScript(config.funcGetCoil).compile()\n    this.funcGetInputRegister = new VMScript(config.funcGetInputRegister).compile()\n    this.funcGetHoldingRegister = new VMScript(config.funcGetHoldingRegister).compile()\n\n    this.funcSetCoil = new VMScript(config.funcSetCoil).compile()\n    this.funcSetRegister = new VMScript(config.funcSetRegister).compile()\n\n    let node = this\n    node.bufferFactor = 8\n\n    node.coilsBufferSize = parseInt(config.coilsBufferSize * node.bufferFactor)\n    node.registersBufferSize = parseInt(config.registersBufferSize * node.bufferFactor)\n\n    node.coils = Buffer.alloc(node.coilsBufferSize, 0)\n    node.registers = Buffer.alloc(node.registersBufferSize, 0)\n\n    node.server = null\n\n    setNodeStatusTo('initialized')\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn((node.name) ? node.name + ': ' + logMessage : 'Modbus response: ' + logMessage)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        internalDebugLog((typeof logMessage === 'string') ? logMessage : JSON.stringify(logMessage))\n      }\n    }\n\n    function setNodeStatusTo (statusValue) {\n      if (mbBasics.statusLog) {\n        verboseLog('server status: ' + statusValue)\n      }\n\n      let fillValue = 'red'\n      let shapeValue = 'dot'\n\n      switch (statusValue) {\n        case 'initialized':\n          fillValue = 'green'\n          shapeValue = 'ring'\n          break\n\n        case 'active':\n          fillValue = 'green'\n          shapeValue = 'dot'\n          break\n\n        default:\n          if (!statusValue || statusValue === 'waiting') {\n            fillValue = 'blue'\n            statusValue = 'waiting ...'\n          }\n          break\n      }\n\n      node.status({fill: fillValue, shape: shapeValue, text: statusValue})\n    }\n\n    //     1...10000*  address - 1      Coils (outputs)    0   Read/Write\n    // 10001...20000*  address - 10001  Discrete Inputs    01  Read\n    // 30001...40000*  address - 30001  Input Registers    04  Read\n    // 40001...50000*  address - 40001  Holding Registers  03  Read/Write\n\n    node.vector = {}\n\n    const vm = new VM({\n      sandbox: {node}\n    })\n\n    vm.run('node.vector.getCoil = ' + config.funcGetCoil)\n    vm.run('node.vector.getInputRegister = ' + config.funcGetInputRegister)\n    vm.run('node.vector.getHoldingRegister = ' + config.funcGetHoldingRegister)\n    vm.run('node.vector.setCoil = ' + config.funcSetCoil)\n    vm.run('node.vector.setRegister = ' + config.funcSetRegister)\n\n    node.startServer = function () {\n      verboseLog('starting modbus flex server')\n\n      try {\n        internalDebugLog('ModbusTCP flex server listening on modbus://' + node.serverAddress + ':' + node.serverPort)\n        if (node.server === null) {\n          node.server = new ModbusRTU.ServerTCP(node.vector, {\n            host: node.serverAddress,\n            port: node.serverPort,\n            debug: node.logEnabled,\n            unitID: node.unitId\n          })\n\n          node.server.on('socketError', function (err) {\n            verboseWarn(err)\n            setNodeStatusTo('error')\n            internalDebugLog(err.message)\n\n            node.server.close(function () {\n              verboseLog('closed modbus flex server by socket error and restart now')\n              node.startServer()\n            })\n          })\n        }\n      } catch (err) {\n        verboseWarn(err)\n        setNodeStatusTo('error')\n      }\n\n      if (node.server != null) {\n        verboseLog('modbus flex server started')\n        setNodeStatusTo('active')\n      } else {\n        verboseWarn('modbus flex server isn\\'t ready')\n        setNodeStatusTo('error')\n      }\n    }\n\n    node.startServer()\n\n    node.on('input', function (msg) {\n      verboseLog('Input:' + msg)\n\n      node.send(buildMessage(msg, node.registers.slice((node.splitAddress + 1) * node.bufferFactor),\n        node.coils, node.registers.slice(0, node.splitAddress * node.bufferFactor)))\n    })\n\n    function buildMessage (msg, modbusHolding, modbusCoils, modbusInput) {\n      return [\n        {type: 'holding', message: msg, payload: modbusHolding},\n        {type: 'coils', message: msg, payload: modbusCoils},\n        {type: 'input', message: msg, payload: modbusInput}\n      ]\n    }\n\n    node.on('close', function () {\n      setNodeStatusTo('closed')\n      if (node.server._server) {\n        node.server._server.close()\n      }\n      node.server = null\n    })\n  }\n\n  RED.nodes.registerType('modbus-flex-server', ModbusFlexServer)\n}\n"]}