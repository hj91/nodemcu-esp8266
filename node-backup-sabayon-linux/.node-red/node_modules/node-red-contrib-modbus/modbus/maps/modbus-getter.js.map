{"version":3,"sources":["modbus-getter.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","internalDebugLog","this","name","ModbusGetter","createNode","unitid","dataType","quantity","adr","showStatusActivities","msgThruput","connection","getNode","ioFile","useIOForPayload","node","modbusClient","setNodeStatusTo","statusValue","statusOptions","setNodeStatusProperties","status","fill","shape","bufferMessageList","Map","onModbusInit","failureMsg","showErrors","onModbusError","onModbusClose","reconnectTimeout","on","onModbusConnect","onModbusActive","msg","logMessage","client","payload","messageId","getObjectId","set","id","value","topic","functionCodeModbus","fc","_msgid","statlyMachine","onModbusReadDone","settings","verbose","JSON","stringify","resp","values","response","origMsg","getOriginalMessage","buildMessage","responseBuffer","rawMsg","lastUpdatedAt","allValueNames","mbIOCore","nameValuesFromIOFile","valueNames","filterValueNames","err","message","setModbusError"],"mappings":"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","file":"../modbus-getter.js","sourcesContent":["/**\n Copyright (c) 2016,2017, Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus Getter node.\n * @module NodeRedModbusGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let mbCore = require('./core/modbus-core')\n  let mbIOCore = require('./core/modbus-io-core')\n  let internalDebugLog = require('debug')('contribModbus:getter')\n\n  function ModbusGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.unitid = config.unitid\n\n    this.dataType = config.dataType\n    this.adr = config.adr\n    this.quantity = config.quantity\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.msgThruput = config.msgThruput\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n\n    let node = this\n    let modbusClient = RED.nodes.getNode(config.server)\n    node.bufferMessageList = new Map()\n\n    setNodeStatusTo('waiting')\n\n    node.onModbusInit = function () {\n      setNodeStatusTo('initialize')\n    }\n\n    node.onModbusConnect = function () {\n      setNodeStatusTo('connected')\n    }\n\n    node.onModbusActive = function () {\n      setNodeStatusTo('active')\n    }\n\n    node.onModbusError = function (failureMsg) {\n      setNodeStatusTo('failure')\n      if (node.showErrors) {\n        node.warn(failureMsg)\n      }\n    }\n\n    node.onModbusClose = function () {\n      setNodeStatusTo('closed')\n    }\n\n    node.onModbusBroken = function () {\n      setNodeStatusTo('reconnecting after ' + modbusClient.reconnectTimeout + ' msec.')\n    }\n\n    modbusClient.on('mbinit', node.onModbusInit)\n    modbusClient.on('mbconnected', node.onModbusConnect)\n    modbusClient.on('mbactive', node.onModbusActive)\n    modbusClient.on('mberror', node.onModbusError)\n    modbusClient.on('mbbroken', node.onModbusBroken)\n    modbusClient.on('mbclosed', node.onModbusClose)\n\n    node.on('input', function (msg) {\n      if (!modbusClient.client) {\n        return\n      }\n\n      if (msg.payload) {\n        msg.messageId = mbCore.getObjectId()\n        node.bufferMessageList.set(msg.messageId, msg)\n        internalDebugLog('Add Message ' + msg.messageId)\n\n        msg = {\n          topic: msg.topic || node.id,\n          payload: {\n            value: msg.payload.value || msg.payload,\n            unitid: node.unitid,\n            fc: mbCore.functionCodeModbus(node.dataType),\n            address: node.adr,\n            quantity: node.quantity,\n            messageId: msg.messageId\n          },\n          _msgid: msg._msgid\n        }\n\n        modbusClient.emit('readModbus', msg, node.onModbusReadDone, node.onModbusReadError)\n\n        if (node.showStatusActivities) {\n          setNodeStatusTo(modbusClient.statlyMachine.getMachineState())\n          verboseLog(msg)\n        }\n      }\n    })\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        setNodeStatusTo('reading done')\n      }\n      node.send(buildMessage(resp.data, resp, msg))\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      internalDebugLog(err.message)\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg) || msg, setNodeStatusTo)\n    }\n\n    node.on('close', function () {\n      setNodeStatusTo('closed')\n    })\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        internalDebugLog((typeof logMessage === 'string') ? logMessage : JSON.stringify(logMessage))\n      }\n    }\n\n    function buildMessage (values, response, msg) {\n      let origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg) || msg\n      origMsg.payload = values\n      origMsg.topic = msg.topic\n      origMsg.responseBuffer = response\n      origMsg.input = msg\n\n      let rawMsg = Object.assign({}, origMsg)\n      rawMsg.payload = response\n      rawMsg.values = values\n      delete rawMsg['responseBuffer']\n\n      if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n        let allValueNames = mbIOCore.nameValuesFromIOFile(msg, node.ioFile, values, response, node.adr)\n        let valueNames = mbIOCore.filterValueNames(allValueNames, mbCore.functionCodeModbus(node.dataType), node.adr, node.quantity)\n\n        if (node.useIOForPayload) {\n          origMsg.payload = valueNames\n          origMsg.values = values\n        } else {\n          origMsg.payload = values\n          origMsg.valueNames = valueNames\n        }\n\n        rawMsg.valueNames = valueNames\n        return [origMsg, rawMsg]\n      } else {\n        return [origMsg, rawMsg]\n      }\n    }\n\n    function setNodeStatusTo (statusValue) {\n      let statusOptions = mbBasics.setNodeStatusProperties(statusValue, node.showStatusActivities)\n\n      node.status({\n        fill: statusOptions.fill,\n        shape: statusOptions.shape,\n        text: statusOptions.status\n      })\n    }\n  }\n\n  RED.nodes.registerType('modbus-getter', ModbusGetter)\n}\n"]}