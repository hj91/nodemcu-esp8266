{"version":3,"sources":["modbus-queue-info.js"],"names":["module","exports","RED","install","internalDebugLog","require","nodes","registerType","config","this","name","ModbusQueueInfo","createNode","topic","unitid","parseInt","lowLowLevel","lowLevel","node","highHighLevel","modbusClient","getNode","server","setNodeStatusTo","statusValue","status","fill","shape","queueReadInterval","settings","verbose","resetStates","lowLevelReached","lowLowLevelReached","readFromQueue","bufferCommands","unit","bufferCommandList","get","length","items","msg","payload","state","send","highLevel","highLevelReached","error","Error","errorOnHighLevel","warn","highHighLevelReached","modbusClientName","fillColor","text","onModbusInit","on","onModbusQueue","onModbusActive","setInterval","isInteger","queueEnabled","queue","resetQueue","initQueue","result","now","lowlowLevel","clearInterval"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAA3BF,QAAOC,sBAAyBE,UAC9B,IAAAC,EAAAC,QAAA,QAAAA,CAAA,uBA0MAH,EAAII,MAAMC,aAAa,oBAzMvBF,SAAQG,GACRN,EAAIE,MAAAA,WAAmBC,KAAAA,GAEvBI,KAAAC,KAASC,EAAAA,KACPT,KAAII,MAAMM,EAAVC,MAIAJ,KAAKK,OAASC,SAASP,EAAOM,QAF9BL,KAAKC,YAAcA,SAAnBF,EAAAQ,aACAP,KAAKI,SAAQL,SAAbA,EAAAS,UACAR,KAAKK,UAASC,SAASP,EAAOM,WAC9BL,KAAKO,cAAcD,SAASP,EAAOQ,eACnCP,KAAKQ,iBAAWF,EAASP,iBAEzB,IAAAU,EAAKC,KAKDC,EAAelB,EAAII,MAAMe,QAAQb,EAAOc,QA+K5C,SAASC,EAAiBC,GAA1BN,EAAAO,OAASF,CACPL,KAAKO,QACHC,MAAM,OACNC,KAAAA,IAhLJT,EAAKU,kBAAoB,KAErB1B,EAAI2B,SAASC,UAFjBZ,EAAKU,SAAL,GAGExB,EAAAA,WAKFc,EAAKa,YAAc,WAFnBR,EAAAA,oBAAA,EAIEL,EAAKc,iBAAkB,EAFzBd,EAAKa,kBAAc,EACjBb,EAAKe,sBAAqB,GAG1Bf,EAAAA,cAKFA,EAAKgB,cAAgB,WAFrBhB,IAAKa,EAAAA,EAALjB,QAAA,EAEAI,GAAKgB,EAALC,eAAiC,EAC3BC,EAAOlB,GAAA,IAAKJ,KAIZsB,EAAO,GAAPA,IAAAA,EAAAhB,EAAAiB,kBAAAC,IAAAF,GAAAG,OAMArB,KADGsB,IAAWtB,EAAKe,oBAAsBO,EAAQtB,EAAKF,cAFxDE,EAAIsB,eAGFtB,EAAKa,iBAALS,EAAAtB,EAAAF,aAAAwB,EAAAtB,EAAAD,SAAA,CACDC,EAAAc,iBAAA,EAIC,IAAIS,EAAM,CAFRC,QAAMV,KAAAA,MACRd,MAAKc,EAAAA,MACLW,MAAIF,oBACFC,OAAAA,EACA7B,iBAFQO,EAAAV,KAGRiC,MAAOH,GAGPA,EAAOA,GANCtB,EAAV0B,KAAAH,GAUAvB,IAAAA,EAAK0B,kBAALJ,EAAAtB,EAAAD,UAAAuB,EAAAtB,EAAA2B,UAAA,CACD3B,EAAA4B,kBAAA,EAIC,IAAIL,EAAM,CAFRC,QAAMI,KAAAA,MACR5B,MAAK4B,EAAAA,MACLH,MAAIF,qBACFC,OAAAA,EACA7B,iBAFQO,EAAAV,KAGRiC,UAAOzB,EAAA2B,UACP/B,MAAAA,GAGA0B,EAAOA,iBAPTtB,EAAA6B,MAAA,IAAAC,MAAA,4BAAAP,GAUAvB,EAAIA,KAAK+B,GAGP/B,EAAAA,KAAKgC,GAGPhC,IAAAA,EAAK0B,sBAALJ,EAAAtB,EAAA2B,WAAAL,EAAAtB,EAAAC,cAAA,CACDD,EAAAiC,sBAAA,EAIC,IAAIV,EAAM,CAFRC,QAAMS,KAAAA,MACRjC,MAAKiC,EAAAA,MACLR,MAAIF,0BACFC,OAAAA,EACA7B,iBAFQO,EAAAV,KAGRiC,UAAOzB,EAAA2B,UACP/B,cAJQI,EAAAC,cAKRiC,MAAAA,GAEAjC,EAAAA,MAAAA,IAAAA,MAAeD,iCAPPuB,GAQRD,EAAAA,KAAOA,GAGTtB,IAAAA,EAAUuB,OACXvB,EAAAc,kBAICqB,EAAY,SAAZA,EAAAA,mBAKEA,EAJHnC,EAAA+B,iBAIe,MADLA,UAIR/B,EAAAiC,uBACFE,EAAA,OAGCA,EAAAA,OAAAA,CACD3B,KAAA2B,EAIC1B,MAAO,OAFTT,KAAKO,eAAOW,EAAA,iBAAAI,SAGVc,EAAM,eAAwBlB,EAAA,mBAIjClB,EAAAqC,aAAA,WA1FHrC,EAAAgB,iBA8FEhB,EAAAA,eAAA,WADFA,EAAAgB,iBAKEhB,EAAAA,cAAA,WADFA,EAAAgB,iBAKEhB,EAAKgB,GAAAA,SAALhB,EAAAqC,cACDnC,EAFDoC,GAAA,UAAAtC,EAAAuC,eAMArC,EAAaoC,GAAG,WAAYtC,EAAKwC,gBADjCtC,EAAAA,kBAAAuC,YAAgCF,EAAAA,cAAhC,KAKAvC,EAAKsC,GAAG,QAAS,SAAUf,GAOvBA,GATJvB,EAAKU,aAAAA,EAAoB+B,eAEpBH,OAAGI,UAAS1C,EAAUuB,SACzBA,EAAIoB,MAAAA,EAAezC,kBAAae,IAAhCjB,EAAAJ,QAIE2B,EAAI3B,OAASI,EAAKJ,QADlB2B,EAAIqB,OAAQ1C,EAAaiB,kBAGzBI,GACDA,EAAAsB,YAIC3C,EAAae,eAAgB,CAF/Bf,EACM2C,YAEJ3C,EAAa4C,KAAAA,+BACb5C,EAAAA,cACAF,EAAKa,OAAAA,CACLb,KAAKO,OACHC,MAAM,OACNC,KAAAA,4BAIF,IAAIsC,EAAS,CAAbvB,QAAIuB,KAASC,MACXxB,MAAAA,mBACAC,OAAOF,EAAA3B,OACPA,iBAHWM,EAAAV,KAIX0C,YAAAA,EAAkBhC,YAClB+C,SAAAA,EAAajD,SACbD,UAAUC,EAAKD,UACf4B,cAAW3B,EAAK2B,eAIlB3B,EAAK0B,KAAKqB,MAId/C,EAAKsC,GAAG,QAAS,WAAjBtC,EAAiB,UACfK,EAAAA,mBACA6C,cAASxC,EAAAA,mBAERV,EAAAU,kBAAA","file":"../modbus-queue-info.js","sourcesContent":["/**\n Copyright (c) 2016,2017, Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let internalDebugLog = require('debug')('contribModbus:queue')\n\n  function ModbusQueueInfo (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = parseInt(config.unitid)\n    this.lowLowLevel = parseInt(config.lowLowLevel)\n    this.lowLevel = parseInt(config.lowLevel)\n    this.highLevel = parseInt(config.highLevel)\n    this.highHighLevel = parseInt(config.highHighLevel)\n    this.errorOnHighLevel = config.errorOnHighLevel\n\n    let node = this\n\n    let modbusClient = RED.nodes.getNode(config.server)\n\n    node.queueReadInterval = null\n\n    if (RED.settings.verbose) {\n      internalDebugLog.enabled = true\n    }\n\n    setNodeStatusTo('waiting')\n\n    node.resetStates = function () {\n      node.lowLowLevelReached = true\n      node.lowLevelReached = false\n      node.highLevelReached = false\n      node.highHighLevelReached = false\n    }\n\n    node.resetStates()\n\n    node.readFromQueue = function () {\n      let unit = node.unitid || 1\n\n      if (modbusClient.bufferCommands) {\n        if (unit < 0 || unit > 255) {\n          unit = 1\n        }\n\n        let items = modbusClient.bufferCommandList.get(unit).length\n\n        if (!items || (!node.lowLowLevelReached && items < node.lowLowLevel)) {\n          node.resetStates()\n        }\n\n        if (!node.lowLevelReached && items > node.lowLowLevel && items < node.lowLevel) {\n          node.lowLevelReached = true\n          let msg = {\n            payload: Date.now(),\n            topic: node.topic,\n            state: 'low level reached',\n            unitid: unit,\n            modbusClientName: modbusClient.name,\n            items: items\n          }\n\n          internalDebugLog(msg)\n          node.send(msg)\n        }\n\n        if (!node.highLevelReached && items > node.lowLevel && items > node.highLevel) {\n          node.highLevelReached = true\n          let msg = {\n            payload: Date.now(),\n            topic: node.topic,\n            state: 'high level reached',\n            unitid: unit,\n            modbusClientName: modbusClient.name,\n            highLevel: node.highLevel,\n            items: items\n          }\n\n          if (node.errorOnHighLevel) {\n            node.error(new Error('Queue High Level Reached'), msg)\n          } else {\n            node.warn(msg)\n          }\n\n          node.send(msg)\n        }\n\n        if (!node.highHighLevelReached && items > node.highLevel && items > node.highHighLevel) {\n          node.highHighLevelReached = true\n          let msg = {\n            payload: Date.now(),\n            topic: node.topic,\n            state: 'high high level reached',\n            unitid: unit,\n            modbusClientName: modbusClient.name,\n            highLevel: node.highLevel,\n            highHighLevel: node.highHighLevel,\n            items: items\n          }\n          node.error(new Error('Queue High High Level Reached'), msg)\n          node.send(msg)\n        }\n\n        let fillColor = 'blue'\n        if (node.lowLevelReached) {\n          fillColor = 'green'\n        }\n\n        if (node.highLevelReached) {\n          if (node.errorOnHighLevel) {\n            fillColor = 'red'\n          } else {\n            fillColor = 'yellow'\n          }\n        }\n\n        if (node.highHighLevelReached) {\n          fillColor = 'red'\n        }\n\n        node.status({\n          fill: fillColor,\n          shape: 'ring',\n          text: 'active unit ' + unit + ' queue items: ' + items\n        })\n      } else {\n        setNodeStatusTo('active unit ' + unit + ' without queue')\n      }\n    }\n\n    node.onModbusInit = function () {\n      node.readFromQueue()\n    }\n\n    node.onModbusActive = function () {\n      node.readFromQueue()\n    }\n\n    node.onModbusQueue = function () {\n      node.readFromQueue()\n    }\n\n    modbusClient.on('mbinit', node.onModbusInit)\n    modbusClient.on('mbqueue', node.onModbusQueue)\n    modbusClient.on('mbactive', node.onModbusActive)\n\n    node.queueReadInterval = setInterval(node.readFromQueue, 1000)\n\n    node.on('input', function (msg) {\n      msg.queueEnabled = modbusClient.bufferCommands\n\n      if (Number.isInteger(node.unitid)) {\n        msg.queue = modbusClient.bufferCommandList.get(node.unitid)\n        msg.unitid = node.unitid\n      } else {\n        msg.queues = modbusClient.bufferCommandList\n      }\n\n      if (msg &&\n        msg.resetQueue &&\n        modbusClient.bufferCommands) {\n        modbusClient.initQueue()\n        modbusClient.warn('Init Queue By External Node')\n        node.resetStates()\n        node.status({\n          fill: 'blue',\n          shape: 'ring',\n          text: 'active empty unit queue'\n        })\n\n        let result = {\n          payload: Date.now(),\n          state: 'queue reset done',\n          unitid: msg.unitid,\n          modbusClientName: modbusClient.name,\n          lowlowLevel: node.lowlowLevel,\n          lowLevel: node.lowLevel,\n          highLevel: node.highLevel,\n          highHighLevel: node.highHighLevel\n        }\n\n        node.send(result)\n      }\n    })\n\n    node.on('close', function () {\n      setNodeStatusTo('closed')\n      if (node.queueReadInterval) {\n        clearInterval(node.queueReadInterval)\n      }\n      node.queueReadInterval = null\n    })\n\n    function setNodeStatusTo (statusValue) {\n      node.status({\n        fill: 'green',\n        shape: 'ring',\n        text: statusValue\n      })\n    }\n  }\n\n  RED.nodes.registerType('modbus-queue-info', ModbusQueueInfo)\n}\n"]}