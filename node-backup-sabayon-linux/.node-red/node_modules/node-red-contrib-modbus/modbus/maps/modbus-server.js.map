{"version":3,"sources":["modbus-server.js"],"names":["module","exports","RED","install","stampit","require","modbus","console","nodes","registerType","config","internalDebugLog","createNode","this","bufferFactor","logEnabled","hostname","name","serverPort","responseDelay","parseInt","delayUnit","holdingBufferSize","inputBufferSize","node","verboseWarn","logMessage","setNodeStatusTo","verbose","warn","verboseLog","settings","JSON","stringify","statusValue","mbBasics","statusLog","shapeValue","fillValue","status","fill","shape","text","server","modbusLogLevel","ModbusServer","refs","logLabel","logLevel","port","coils","Buffer","coilsBufferSize","holding","input","alloc","calc_rateByUnit","compose","tcp","init","bind","err","on","msg","modbusHolding","modbusCoils","modbusInput","send","getHolding","getCoils","getInput","buildMessage","type","message","payload","close","log"],"mappings":"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","file":"../modbus-server.js","sourcesContent":["/**\n Copyright (c) 2016,2017, Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Server node.\n * @module NodeRedModbusServer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let stampit = require('stampit')\n  let modbus = require('node-modbus')\n  let mbBasics = require('./modbus-basics')\n  let internalDebugLog = require('debug')('contribModbus:server')\n\n  function ModbusServer (config) {\n    RED.nodes.createNode(this, config)\n    let bufferFactor = 8\n\n    this.name = config.name\n    this.logEnabled = config.logEnabled\n    this.hostname = config.hostname || '0.0.0.0'\n    this.serverPort = parseInt(config.serverPort)\n    this.responseDelay = parseInt(config.responseDelay)\n    this.delayUnit = config.delayUnit\n\n    this.coilsBufferSize = parseInt(config.coilsBufferSize * bufferFactor)\n    this.holdingBufferSize = parseInt(config.holdingBufferSize * bufferFactor)\n    this.inputBufferSize = parseInt(config.inputBufferSize * bufferFactor)\n\n    let node = this\n\n    node.server = null\n\n    setNodeStatusTo('initialized')\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn((node.name) ? node.name + ': ' + logMessage : 'Modbus response: ' + logMessage)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        internalDebugLog((typeof logMessage === 'string') ? logMessage : JSON.stringify(logMessage))\n      }\n    }\n\n    function setNodeStatusTo (statusValue) {\n      if (mbBasics.statusLog) {\n        verboseLog('server status: ' + statusValue)\n      }\n\n      let fillValue = 'red'\n      let shapeValue = 'dot'\n\n      switch (statusValue) {\n        case 'initialized':\n          fillValue = 'green'\n          shapeValue = 'ring'\n          break\n\n        case 'active':\n          fillValue = 'green'\n          shapeValue = 'dot'\n          break\n\n        default:\n          if (!statusValue || statusValue === 'waiting') {\n            fillValue = 'blue'\n            statusValue = 'waiting ...'\n          }\n          break\n      }\n\n      node.status({fill: fillValue, shape: shapeValue, text: statusValue})\n    }\n\n    let modbusLogLevel = 'warn'\n    if (RED.settings.verbose) {\n      modbusLogLevel = 'debug'\n    }\n\n    try {\n      let ModbusServer = stampit().refs({\n        'logLabel': 'ModbusServer',\n        'logLevel': modbusLogLevel,\n        'logEnabled': node.logEnabled,\n        'hostname': node.hostname,\n        'port': node.serverPort,\n        'responseDelay': mbBasics.calc_rateByUnit(node.responseDelay, node.delayUnit),\n        'coils': Buffer.alloc(node.coilsBufferSize, 0),\n        'holding': Buffer.alloc(node.holdingBufferSize, 0),\n        'input': Buffer.alloc(node.inputBufferSize, 0)\n      })\n        .compose(modbus.server.tcp.complete)\n        .init(function () {\n          let init = function () {\n            this.coils.fill(0)\n            this.holding.fill(0)\n            this.input.fill(0)\n          }.bind(this)\n          init()\n        })\n\n      verboseLog('starting modbus server')\n\n      node.server = ModbusServer()\n    } catch (err) {\n      verboseWarn(err)\n      setNodeStatusTo('error')\n    }\n\n    if (node.server != null) {\n      verboseLog('modbus server started')\n      setNodeStatusTo('active')\n    } else {\n      verboseWarn('modbus server isn\\'t ready')\n      setNodeStatusTo('error')\n    }\n\n    node.on('input', function (msg) {\n      verboseLog('Input:' + msg)\n\n      node.send(buildMessage(msg, node.server.getHolding(), node.server.getCoils(), node.server.getInput()))\n    })\n\n    function buildMessage (msg, modbusHolding, modbusCoils, modbusInput) {\n      return [\n        {type: 'holding', message: msg, payload: modbusHolding},\n        {type: 'coils', message: msg, payload: modbusCoils},\n        {type: 'input', message: msg, payload: modbusInput}\n      ]\n    }\n\n    node.on('close', function () {\n      setNodeStatusTo('closed')\n      node.server.close()\n      node.server = null\n    })\n  }\n\n  try {\n    RED.nodes.registerType('modbus-server', ModbusServer)\n  } catch (err) {\n    console.log(err.message)\n  }\n}\n"]}