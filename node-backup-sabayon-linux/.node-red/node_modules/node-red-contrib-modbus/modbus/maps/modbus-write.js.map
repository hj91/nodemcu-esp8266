{"version":3,"sources":["modbus-write.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","internalDebugLog","this","name","ModbusWrite","showStatusActivities","showErrors","adr","Number","unitid","node","modbusClient","quantity","server","setNodeStatusTo","logMessage","settings","verbose","JSON","stringify","statusValue","statusOptions","setNodeStatusProperties","statusLog","verboseLog","fill","shape","status","bufferMessageList","Map","onModbusInit","failureMsg","onModbusError","onModbusClose","reconnectTimeout","on","onModbusConnect","onModbusActive","msg","hasOwnProperty","payload","error","Error","client","value","indexOf","messageId","getObjectId","set","functionCodeModbus","dataType","fc","_msgid","statlyMachine","onModbusWriteDone","resp","values","response","origMsg","getOriginalMessage","buildMessage","responseBuffer","rawMsg","err","message","setModbusError"],"mappings":"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","file":"../modbus-write.js","sourcesContent":["/**\n Copyright 2016,2017 - Klaus Landsdorf (http://bianco-royal.de/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Write node.\n * @module NodeRedModbusWrite\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let mbCore = require('./core/modbus-core')\n  let internalDebugLog = require('debug')('contribModbus:write')\n\n  function ModbusWrite (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n\n    this.unitid = config.unitid\n    this.dataType = config.dataType\n    this.adr = Number(config.adr)\n    this.quantity = config.quantity\n\n    let node = this\n    let modbusClient = RED.nodes.getNode(config.server)\n    node.bufferMessageList = new Map()\n\n    setNodeStatusTo('waiting')\n\n    node.onModbusInit = function () {\n      setNodeStatusTo('initialize')\n    }\n\n    node.onModbusConnect = function () {\n      setNodeStatusTo('connected')\n    }\n\n    node.onModbusActive = function () {\n      setNodeStatusTo('active')\n    }\n\n    node.onModbusError = function (failureMsg) {\n      setNodeStatusTo('failure')\n      if (node.showErrors) {\n        node.warn(failureMsg)\n      }\n    }\n\n    node.onModbusClose = function () {\n      setNodeStatusTo('closed')\n    }\n\n    node.onModbusBroken = function () {\n      setNodeStatusTo('reconnecting after ' + modbusClient.reconnectTimeout + ' msec.')\n    }\n\n    modbusClient.on('mbinit', node.onModbusInit)\n    modbusClient.on('mbconnected', node.onModbusConnect)\n    modbusClient.on('mbactive', node.onModbusActive)\n    modbusClient.on('mberror', node.onModbusError)\n    modbusClient.on('mbbroken', node.onModbusBroken)\n    modbusClient.on('mbclosed', node.onModbusClose)\n\n    node.on('input', function (msg) {\n      if (!(msg && msg.hasOwnProperty('payload'))) return\n\n      if (msg.payload == null) {\n        setNodeStatusTo('payload error')\n        node.error(new Error('Invalid msg.payload'), msg)\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      /* HTTP requests for boolean and multiple data string [1,2,3,4,5] */\n      if (msg.payload.hasOwnProperty('value') && typeof msg.payload.value === 'string') {\n        if (msg.payload.value === 'true' || msg.payload.value === 'false') {\n          msg.payload.value = (msg.payload.value === 'true')\n        } else {\n          if (msg.payload.value.indexOf(',') > -1) {\n            msg.payload.value = JSON.parse(msg.payload.value)\n          }\n        }\n      }\n\n      msg.messageId = mbCore.getObjectId()\n      node.bufferMessageList.set(msg.messageId, msg)\n      internalDebugLog('Add Message ' + msg.messageId)\n\n      msg = {\n        payload: {\n          value: msg.payload.value || msg.payload,\n          unitid: node.unitid,\n          fc: node.functionCodeModbus(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId: msg.messageId\n        },\n        _msgid: msg._msgid\n      }\n\n      modbusClient.emit('writeModbus', msg, node.onModbusWriteDone, node.onModbusWriteError)\n\n      if (node.showStatusActivities) {\n        setNodeStatusTo(modbusClient.statlyMachine.getMachineState())\n        verboseLog(msg)\n      }\n    })\n\n    node.functionCodeModbus = function (dataType) {\n      switch (dataType) {\n        case 'Coil':\n          return 5\n        case 'HoldingRegister':\n          return 6\n        case 'MCoils':\n          return 15\n        case 'MHoldingRegisters':\n          return 16\n        default:\n          return dataType\n      }\n    }\n\n    node.onModbusWriteDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        setNodeStatusTo('write done')\n      }\n      node.send(buildMessage(msg.payload, resp, msg))\n    }\n\n    node.onModbusWriteError = function (err, msg) {\n      internalDebugLog(err.message)\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg) || msg, setNodeStatusTo)\n    }\n\n    node.on('close', function () {\n      setNodeStatusTo('closed')\n    })\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        internalDebugLog((typeof logMessage === 'string') ? logMessage : JSON.stringify(logMessage))\n      }\n    }\n\n    function buildMessage (values, response, msg) {\n      let origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg) || msg\n      origMsg.payload = values\n      origMsg.topic = msg.topic\n      origMsg.responseBuffer = response\n      origMsg.input = msg\n\n      let rawMsg = Object.assign({}, origMsg)\n      rawMsg.payload = response\n      rawMsg.values = values\n      delete rawMsg['responseBuffer']\n\n      return [origMsg, rawMsg]\n    }\n\n    function setNodeStatusTo (statusValue) {\n      let statusOptions = mbBasics.setNodeStatusProperties(statusValue, node.showStatusActivities)\n      if (mbBasics.statusLog) {\n        verboseLog('status options: ' + JSON.stringify(statusOptions))\n      }\n      node.status({\n        fill: statusOptions.fill,\n        shape: statusOptions.shape,\n        text: statusOptions.status\n      })\n    }\n  }\n\n  RED.nodes.registerType('modbus-write', ModbusWrite)\n}\n"]}