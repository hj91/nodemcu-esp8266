"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// ---------------------------------------------------------------------------------------------------------------------
// node-opcua
// ---------------------------------------------------------------------------------------------------------------------
// Copyright (c) 2014-2018 - Etienne Rossignon - etienne.rossignon (at) gadz.org
// ---------------------------------------------------------------------------------------------------------------------
//
// This  project is licensed under the terms of the MIT license.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so,  subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ---------------------------------------------------------------------------------------------------------------------
// tslint:disable:no-shadowed-variable
const assert = require("assert");
const async = require("async");
const chalk_1 = require("chalk");
const fs = require("fs");
const path = require("path");
const _ = require("underscore");
const toolbox_1 = require("./toolbox");
const config = {
    certificateDir: "INVALID",
    forceCA: false,
    pkiDir: "INVALID",
};
const n = toolbox_1.make_path;
const q = toolbox_1.quote;
function construct_CertificateAuthority(cauthority, callback) {
    // create the CA directory store
    // create the CA directory store
    //
    // PKI/CA
    //     |
    //     +-+> private
    //     |
    //     +-+> public
    //     |
    //     +-+> certs
    //     |
    //     +-+> crl
    //     |
    //     +-+> conf
    //     |
    //     +-f: serial
    //     +-f: crlnumber
    //     +-f: index.txt
    //
    const caRootDir = cauthority.rootDir;
    function make_folders() {
        toolbox_1.mkdir(caRootDir);
        toolbox_1.mkdir(path.join(caRootDir, "private"));
        toolbox_1.mkdir(path.join(caRootDir, "public"));
        // xx execute("chmod 700 private");
        toolbox_1.mkdir(path.join(caRootDir, "certs"));
        toolbox_1.mkdir(path.join(caRootDir, "crl"));
        toolbox_1.mkdir(path.join(caRootDir, "conf"));
    }
    make_folders();
    function construct_default_files() {
        const serial = path.join(caRootDir, "serial");
        if (!fs.existsSync(serial)) {
            fs.writeFileSync(serial, "1000");
        }
        const crlnumber = path.join(caRootDir, "crlnumber");
        if (!fs.existsSync(crlnumber)) {
            fs.writeFileSync(crlnumber, "1000");
        }
        const indexFile = path.join(caRootDir, "index.txt");
        if (!fs.existsSync(indexFile)) {
            fs.writeFileSync(indexFile, "");
        }
    }
    construct_default_files();
    if (fs.existsSync(path.join(caRootDir, "private/cakey.pem")) && !config.forceCA) {
        // certificate already exists => do not overwrite
        toolbox_1.debugLog("CA private key already exists ... skipping");
        return callback();
    }
    // tslint:disable:no-empty
    toolbox_1.displayTitle("Create Certificate Authority (CA)", (err) => {
    });
    const indexFileAttr = path.join(caRootDir, "index.txt.attr");
    if (!fs.existsSync(indexFileAttr)) {
        fs.writeFileSync(indexFileAttr, "unique_subject = no");
    }
    const caConfigFile = cauthority.configFile;
    if (1 || !fs.existsSync(caConfigFile)) {
        let data = toolbox_1.configurationFileTemplate; // inlineText(configurationFile);
        data = data.replace(/%%ROOT_FOLDER%%/, toolbox_1.make_path(caRootDir));
        fs.writeFileSync(caConfigFile, data);
    }
    // http://www.akadia.com/services/ssh_test_certificate.html
    const subject = "/C=FR/ST=IDF/L=Paris/O=Local NODE-OPCUA Certificate Authority/CN=NodeOPCUA-CA";
    const options = { cwd: caRootDir };
    toolbox_1.processAltNames({});
    const configFile = toolbox_1.generateStaticConfig("conf/caconfig.cnf", options);
    const configOption = " -config " + q(n(configFile));
    const keySize = cauthority.keySize;
    const tasks = [
        (callback) => toolbox_1.displayTitle("Generate the CA private Key - " + keySize, callback),
        // The first step is to create your RSA Private Key.
        // This key is a 1025,2048,3072 or 2038 bit RSA key which is encrypted using
        // Triple-DES and stored in a PEM format so that it is readable as ASCII text.
        (callback) => toolbox_1.execute_openssl("genrsa " +
            " -out  private/cakey.pem" +
            (toolbox_1.useRandFile() ? " -rand random.rnd" : "") +
            " " + keySize, options, callback),
        (callback) => toolbox_1.displayTitle("Generate a certificate request for the CA key", callback),
        // Once the private key is generated a Certificate Signing Request can be generated.
        // The CSR is then used in one of two ways. Ideally, the CSR will be sent to a Certificate Authority, such as
        // Thawte or Verisign who will verify the identity of the requestor and issue a signed certificate.
        // The second option is to self-sign the CSR, which will be demonstrated in the next section
        (callback) => toolbox_1.execute_openssl("req -new" +
            " -sha256 " +
            " -text " +
            " -extensions v3_ca" +
            configOption +
            " -key private/cakey.pem " +
            " -out private/cakey.csr " +
            " -subj \"" + subject + "\"", options, callback),
        // xx // Step 3: Remove Passphrase from Key
        // xx execute("cp private/cakey.pem private/cakey.pem.org");
        // xx execute(openssl_path + " rsa -in private/cakey.pem.org -out private/cakey.pem -passin pass:"+paraphrase);
        (callback) => toolbox_1.displayTitle("Generate CA Certificate (self-signed)", callback),
        (callback) => toolbox_1.execute_openssl(" x509 -sha256 -req -days 3650 " +
            " -text " +
            " -extensions v3_ca" +
            " -extfile " + q(n(configFile)) +
            " -in private/cakey.csr " +
            " -signkey private/cakey.pem " +
            " -out public/cacert.pem", options, callback),
        (callback) => toolbox_1.displaySubtitle("generate initial CRL (Certificate Revocation List)", callback),
        (callback) => toolbox_1.execute_openssl("ca -gencrl " +
            configOption + " -out crl/revocation_list.crl", options, callback),
        // produce CRL in DER format
        (callback) => toolbox_1.displaySubtitle("Produce initial CRL in DER form ", callback),
        (callback) => toolbox_1.execute_openssl("crl " +
            " -in " + q(n(cauthority.revocationList)) +
            " -out  crl/revocation_list.der " +
            " -outform der", options, callback),
        (callback) => toolbox_1.displayTitle("Create Certificate Authority (CA) ---> DONE", callback)
    ];
    async.series(tasks, callback);
}
class CertificateAuthority {
    constructor(options) {
        assert(options.hasOwnProperty("location"));
        assert(options.hasOwnProperty("keySize"));
        this.location = options.location;
        this.keySize = options.keySize || 2048;
    }
    get rootDir() {
        return this.location;
    }
    get configFile() {
        return path.normalize(path.join(this.rootDir, "./conf/caconfig.cnf"));
    }
    get caCertificate() {
        // the Certificate Authority Certificate
        return toolbox_1.make_path(this.rootDir, "./public/cacert.pem");
    }
    get revocationList() {
        return toolbox_1.make_path(this.rootDir, "./crl/revocation_list.crl");
    }
    get caCertificateWithCrl() {
        return toolbox_1.make_path(this.rootDir, "./public/cacertificate_with_crl.pem");
    }
    initialize(callback) {
        assert(_.isFunction(callback));
        construct_CertificateAuthority(this, callback);
    }
    constructCACertificateWithCRL(callback) {
        assert(_.isFunction(callback));
        const cacertWithCRL = this.caCertificateWithCrl;
        // note : in order to check if the certificate is revoked,
        // you need to specify -crl_check and have both the CA cert and the (applicable) CRL in your truststore.
        // There are two ways to do that:
        // 1. concatenate cacert.pem and crl.pem into one file and use that for -CAfile.
        // 2. use some linked
        // ( from http://security.stackexchange.com/a/58305/59982)
        if (fs.existsSync(this.revocationList)) {
            fs.writeFileSync(cacertWithCRL, fs.readFileSync(this.caCertificate, "utf8") +
                fs.readFileSync(this.revocationList, "utf8"));
        }
        else {
            // there is no revocation list yet
            fs.writeFileSync(cacertWithCRL, fs.readFileSync(this.caCertificate));
        }
        callback();
    }
    constructCertificateChain(certificate, callback) {
        assert(_.isFunction(callback));
        assert(fs.existsSync(certificate));
        assert(fs.existsSync(this.caCertificate));
        toolbox_1.debugLog(chalk_1.default.yellow("        certificate file :"), chalk_1.default.cyan(certificate));
        // append
        fs.writeFileSync(certificate, fs.readFileSync(certificate, "utf8")
            + fs.readFileSync(this.caCertificate, "utf8")
        //   + fs.readFileSync(this.revocationList)
        );
        callback();
    }
    createSelfSignedCertificate(certificateFile, privateKey, params, callback) {
        assert(typeof privateKey === "string");
        assert(fs.existsSync(privateKey));
        assert(_.isFunction(callback));
        if (!toolbox_1.check_certificate_filename(certificateFile)) {
            return callback();
        }
        toolbox_1.adjustDate(params);
        toolbox_1.adjustApplicationUri(params);
        toolbox_1.processAltNames(params);
        const csrFile = certificateFile + "_csr";
        assert(csrFile);
        const configFile = toolbox_1.generateStaticConfig(this.configFile);
        const options = {
            cwd: this.rootDir,
            openssl_conf: toolbox_1.make_path(configFile)
        };
        const configOption = "";
        const tasks = [];
        tasks.push((callback) => toolbox_1.displaySubtitle("- the certificate signing request", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("req " +
            " -new -sha256 -text " + configOption +
            " -batch -key " + q(n(privateKey)) + " -out " + q(n(csrFile)), options, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- creating the self-signed certificate", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("ca " +
            " -selfsign " +
            " -keyfile " + q(n(privateKey)) +
            " -startdate " + toolbox_1.x509Date(params.startDate) +
            " -enddate " + toolbox_1.x509Date(params.endDate) +
            " -batch -out " + q(n(certificateFile)) + " -in " + q(n(csrFile)), options, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- dump the certificate for a check", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("x509 -in " + q(n(certificateFile)) + "  -dates -fingerprint -purpose -noout", {}, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- verify self-signed certificate", callback));
        tasks.push((callback) => toolbox_1.execute_openssl_no_failure("verify -verbose -CAfile " + q(n(certificateFile)) + " " + q(n(certificateFile)), options, callback));
        tasks.push((callback) => fs.unlink(csrFile, callback));
        async.series(tasks, (err) => {
            callback(err);
        });
    }
    /**
     * revoke a certificate and update the CRL
     *
     * @method revokeCertificate
     * @param certificate {String} the certificate to revoke
     * @param params {Object}
     * @paral [params.reason = "keyCompromise" {String}]
     * @param callback {Function}
     * @async
     */
    revokeCertificate(certificate, params, callback) {
        assert(_.isFunction(callback));
        const crlReasons = [
            "unspecified", "keyCompromise", "CACompromise",
            "affiliationChanged", "superseded", "cessationOfOperation",
            "certificateHold", "removeFromCRL"
        ];
        const configFile = toolbox_1.generateStaticConfig("conf/caconfig.cnf", { cwd: this.rootDir });
        const options = {
            cwd: this.rootDir,
            openssl_conf: toolbox_1.make_path(configFile)
        };
        // tslint:disable-next-line:no-string-literal
        assert(fs.existsSync(process.env["OPENSSL_CONF"]));
        const configOption = " -config " + q(n(configFile));
        const reason = params.reason || "keyCompromise";
        assert(crlReasons.indexOf(reason) >= 0);
        const tasks = [
            (callback) => toolbox_1.displayTitle("Revoking certificate  " + certificate, callback),
            (callback) => toolbox_1.displaySubtitle("Revoke certificate", callback),
            // -crl_reason reason
            (callback) => toolbox_1.execute_openssl_no_failure("ca " + configOption + " -revoke " + q(certificate) +
                " -crl_reason " + reason, options, callback),
            // regenerate CRL (Certificate Revocation List)
            (callback) => toolbox_1.displaySubtitle("regenerate CRL (Certificate Revocation List)", callback),
            (callback) => toolbox_1.execute_openssl("ca -gencrl " + configOption + " -out crl/revocation_list.crl", options, callback),
            (callback) => toolbox_1.displaySubtitle("Display (Certificate Revocation List)", callback),
            (callback) => toolbox_1.execute_openssl("crl " +
                " -in " +
                q(n(this.revocationList)) +
                " -text " +
                " -noout", options, callback),
            (callback) => toolbox_1.displaySubtitle("Verify that certificate is revoked  ", callback),
            (callback) => {
                toolbox_1.execute_openssl_no_failure("verify -verbose" +
                    // configOption +
                    " -CRLfile " +
                    q(n(this.revocationList)) +
                    " -CAfile " + q(n(this.caCertificate)) + " -crl_check " + q(n(certificate)), options, (err, output) => {
                    callback();
                });
            },
            // produce CRL in DER format
            (callback) => toolbox_1.displaySubtitle("Produce CRL in DER form ", callback),
            (callback) => toolbox_1.execute_openssl("crl " +
                " -in " +
                q(n(this.revocationList)) +
                " -out " +
                "crl/revocation_list.der " +
                " -outform der", options, callback),
            (callback) => toolbox_1.displaySubtitle("Produce CRL in PEM form ", callback),
            (callback) => toolbox_1.execute_openssl("crl " +
                " -in " +
                q(n(this.revocationList)) +
                " -out " +
                "crl/revocation_list.pem " +
                " -outform pem", options, callback)
        ];
        async.series(tasks, callback);
    }
    /**
     *
     * @param certificate            {String} the certificate filename to generate
     * @param certificateSigningRequestFilename               {String} the certificate signing request
     * @param params                 {Object}
     * @param params.applicationUri  {String} the applicationUri
     * @param params.startDate       {Date}   startDate of the certificate
     * @param params.validity        {Number} number of day of validity of the cerificate
     * @param callback               {Function}
     */
    signCertificateRequest(certificate, certificateSigningRequestFilename, params, callback) {
        assert(fs.existsSync(certificateSigningRequestFilename));
        assert(_.isFunction(callback));
        if (!toolbox_1.check_certificate_filename(certificate)) {
            return callback(null);
        }
        toolbox_1.adjustDate(params);
        toolbox_1.adjustApplicationUri(params);
        toolbox_1.processAltNames(params);
        const options = { cwd: this.rootDir };
        const configFile = toolbox_1.generateStaticConfig("conf/caconfig.cnf", options);
        const configOption = " -config " + configFile;
        const tasks = [];
        tasks.push((callback) => toolbox_1.displaySubtitle("- then we ask the authority to sign the certificate signing request", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("ca " +
            configOption +
            " -startdate " + toolbox_1.x509Date(params.startDate) +
            " -enddate " + toolbox_1.x509Date(params.endDate) +
            " -batch -out " + q(n(certificate)) + " -in " + q(n(certificateSigningRequestFilename)), options, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- dump the certificate for a check", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("x509 -in " + q(n(certificate)) + "  -dates -fingerprint -purpose -noout", options, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- construct CA certificate with CRL", callback));
        tasks.push((callback) => {
            this.constructCACertificateWithCRL(callback);
        });
        // construct certificate chain
        //   concatenate certificate with CA Certificate and revocation list
        tasks.push((callback) => toolbox_1.displaySubtitle("- construct certificate chain", callback));
        tasks.push((callback) => {
            this.constructCertificateChain(certificate, callback);
        });
        // todo
        tasks.push((callback) => toolbox_1.displaySubtitle("- verify certificate against the root CA", callback));
        tasks.push((callback) => {
            this.verifyCertificate(certificate, callback);
        });
        async.series(tasks, (err) => {
            // istanbul ignore next
            if (err) {
                return callback(err);
            }
            callback(null, certificate);
        });
    }
    verifyCertificate(certificate, callback) {
        // openssl verify crashes on windows! we cannot use it reliably
        // istanbul ignore next
        const isImplemented = false;
        // istanbul ignore next
        if (isImplemented) {
            const options = { cwd: this.rootDir };
            const configFile = toolbox_1.generateStaticConfig("conf/caconfig.cnf", options);
            toolbox_1.setEnv("OPENSSL_CONF", toolbox_1.make_path(configFile));
            const configOption = " -config " + configFile;
            toolbox_1.execute_openssl_no_failure("verify -verbose " +
                " -CAfile " + q(n(this.caCertificateWithCrl)) +
                " " + q(n(certificate)), options, (err) => {
                callback(err ? err : undefined);
            });
        }
        else {
            return callback();
        }
    }
}
exports.CertificateAuthority = CertificateAuthority;
//# sourceMappingURL=certificate_authority.js.map