"use strict";
// ---------------------------------------------------------------------------------------------------------------------
// node-opcua
// ---------------------------------------------------------------------------------------------------------------------
// Copyright (c) 2014-2018 - Etienne Rossignon - etienne.rossignon (at) gadz.org
// ---------------------------------------------------------------------------------------------------------------------
//
// This  project is licensed under the terms of the MIT license.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so,  subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ---------------------------------------------------------------------------------------------------------------------
// tslint:disable:no-shadowed-variable
// tslint:disable:member-ordering
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const async = require("async");
const chalk_1 = require("chalk");
const fs = require("fs");
const path = require("path");
const _ = require("underscore");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const toolbox_1 = require("./toolbox");
// tslint:disable-next-line:no-var-requires
const walk = require("walk");
class CertificateManager {
    constructor(options) {
        options.keySize = options.keySize || 2048;
        assert(options.hasOwnProperty("location"));
        assert(options.hasOwnProperty("keySize"));
        this.location = toolbox_1.make_path(options.location, "");
        this.keySize = options.keySize;
        toolbox_1.mkdir(options.location);
        // istanbul ignore next
        if (!fs.existsSync(this.location)) {
            throw new Error("CertificateManager cannot access location " + this.location);
        }
        this._thumbs = {
            rejected: {},
            trusted: {},
        };
    }
    get configFile() {
        return path.join(this.rootDir, "own/openssl.cnf");
    }
    get rootDir() {
        return this.location;
    }
    get privateKey() {
        return path.join(this.rootDir, "own/private/private_key.pem");
    }
    get randomFile() {
        return path.join(this.rootDir, "own/private/random.rnd");
    }
    getCertificateStatus(certificate, ...args) {
        const callback = args[0];
        this.initialize(() => {
            this._getCertificateStatus(certificate, (err, status) => {
                if (err) {
                    return callback(err);
                }
                if (status === "unknown") {
                    assert(certificate instanceof Buffer);
                    const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
                    const certificateName = path.join(this.rootDir, "rejected", thumbprint + ".pem");
                    const pem = node_opcua_crypto_1.toPem(certificate, "CERTIFICATE");
                    fs.writeFile(certificateName, pem, (err) => {
                        if (err) {
                            return callback(err);
                        }
                        status = "rejected";
                        return callback(null, status);
                    });
                    return;
                }
                return callback(null, status);
            });
        });
    }
    rejectCertificate(certificate, ...args) {
        const callback = args[0];
        this._moveCertificate(certificate, "rejected", callback);
    }
    trustCertificate(certificate, ...args) {
        const callback = args[0];
        this._moveCertificate(certificate, "trusted", callback);
    }
    /**
     * Verify certificate validity
     * @method verifyCertificate
     * @param certificate {Buffer}
     * @param callback  {Function}
     */
    verifyCertificate(certificate, callback) {
        // Is the  signature on the SoftwareCertificate valid .?
        if (!certificate) {
            // missing certificate
            return callback(new Error("BadSecurityChecksFailed"));
        }
        // -- var split_der = require("lib/misc/crypto_explore_certificate").split_der;
        // -- var chain = split_der(securityHeader.senderCertificate);
        // -- //xx console.log("xxx NB CERTIFICATE IN CHAIN = ".red,chain.length);
        // Has SoftwareCertificate passed its issue date and has it not expired ?
        // check dates
        const cert = node_opcua_crypto_1.exploreCertificateInfo(certificate);
        const now = new Date();
        async.series([
            // check that certificate is active
            (callback) => {
                if (cert.notBefore.getTime() > now.getTime()) {
                    // certificate is not active yet
                    toolbox_1.debugLog(chalk_1.default.red("certificate is invalid : certificate is not active yet !") +
                        "  not before date =" + cert.notBefore);
                    return callback(new Error("BadCertificateTimeInvalid"));
                }
                else {
                    return callback();
                }
            },
            //  check that certificate has not expired
            (callback) => {
                if (cert.notAfter.getTime() <= now.getTime()) {
                    // certificate is obsolete
                    toolbox_1.debugLog(chalk_1.default.red("certificate is invalid : certificate has expired !")
                        + " not after date =" + cert.notAfter);
                    return callback(new Error("BadCertificateTimeInvalid"));
                }
                else {
                    return callback();
                }
            },
            // check that certificate is not untrusted
            (callback) => {
                this._getCertificateStatus(certificate, (err, status) => {
                    // istanbul ignore next
                    if (err) {
                        return callback(err);
                    }
                    if (status === "rejected") {
                        return callback(new Error("BadCertificateUntrusted"));
                    }
                    else if (status === "trusted") {
                        return callback(); // OK
                    }
                    assert(status === "unknown");
                    return callback(new Error("BadCertificateUntrusted"));
                });
            },
            // _check_that_certificate_has_not_been_revoked_by_issuer
            (callback) => {
                // Has SoftwareCertificate has  been revoked by the issuer ?
                // TODO: check if certificate is revoked or not ...
                // BadCertificateRevoked
                return callback();
            },
            // check that issuer certificate has not been revoked by the CA authority
            (callback) => {
                // is issuer Certificate valid and has not been revoked by the CA that issued it. ?
                // TODO : check validity of issuer certificate
                // StatusCodes.BadCertificateIssuerRevoked
                return callback();
            },
            // check that ApplicationDescription matches URI in certificate
            (callback) => {
                // does the URI specified in the ApplicationDescription  match the URI in the Certificate ?
                // TODO : check ApplicationDescription of issuer certificate
                // return StatusCodes.BadCertificateUriInvalid
                return callback();
            }
        ], callback);
    }
    initialize(...args) {
        const callback = args[0];
        const pkiDir = this.location;
        toolbox_1.mkdir(pkiDir);
        toolbox_1.mkdir(path.join(pkiDir, "own"));
        toolbox_1.mkdir(path.join(pkiDir, "own/certs"));
        toolbox_1.mkdir(path.join(pkiDir, "own/private"));
        toolbox_1.mkdir(path.join(pkiDir, "trusted"));
        toolbox_1.mkdir(path.join(pkiDir, "rejected"));
        toolbox_1.ensure_openssl_installed(() => {
            // if (1 || !fs.existsSync(this.configFile)) {
            //    var data = toolbox.configurationFileTemplate;
            //    data = data.replace(/%%ROOT_FOLDER%%/, toolbox.make_path(pkiDir,"own"));
            //    fs.writeFileSync(this.configFile, data);
            // }
            //
            fs.writeFileSync(this.configFile, toolbox_1.configurationFileSimpleTemplate);
            fs.exists(this.privateKey, (exists) => {
                if (!exists) {
                    toolbox_1.debugLog("generating private key ...");
                    toolbox_1.setEnv("RANDFILE", this.randomFile);
                    toolbox_1.createPrivateKey(this.privateKey, this.keySize, (err) => {
                        return callback(err);
                    });
                }
                else {
                    toolbox_1.debugLog("private key already exists ... skipping");
                    return callback();
                }
            });
        });
    }
    createSelfSignedCertificate(params, ...args) {
        const callback = args[0];
        const self = this;
        assert(_.isString(params.applicationUri));
        if (!fs.existsSync(self.privateKey)) {
            return callback(new Error("Cannot find private key " + self.privateKey));
        }
        let certificateFilename = path.join(self.rootDir, "own/certs/self_signed_certificate.pem");
        certificateFilename = params.outputFile || certificateFilename;
        params.rootDir = self.rootDir;
        params.configFile = self.configFile;
        params.privateKey = self.privateKey;
        toolbox_1.createSelfSignCertificate(certificateFilename, params, callback);
    }
    createCertificateRequest(params, callback) {
        assert(_.isFunction(callback));
        if (params.rootDir) {
            throw new Error("rootDir should not be specified " + params.rootDir);
        }
        assert(params);
        assert(!params.rootDir);
        assert(!params.configFile);
        assert(!params.privateKey);
        params.rootDir = this.rootDir;
        params.configFile = this.configFile;
        params.privateKey = this.privateKey;
        // compose a file name for the request
        const now = new Date();
        const today = now.toISOString().slice(0, 10) + "_" + now.getTime();
        const certificateSigningRequestFilename = path.join(params.rootDir, "own/certs", "certificate_" + today + ".csr");
        // xx toolbox.processAltNames(params);
        toolbox_1.createCertificateSigningRequest(certificateSigningRequestFilename, params, (err) => {
            return callback(err, certificateSigningRequestFilename);
        });
    }
    /**
     * @internal
     * @param certificate
     * @param callback
     * @private
     */
    _getCertificateStatus(certificate, callback) {
        assert(certificate instanceof Buffer);
        const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
        toolbox_1.debugLog("thumbprint ", thumbprint);
        this._readCertificates((err) => {
            if (err) {
                return callback(err);
            }
            if (this._thumbs.rejected.hasOwnProperty(thumbprint)) {
                return callback(null, "rejected");
            }
            if (this._thumbs.trusted.hasOwnProperty(thumbprint)) {
                return callback(null, "trusted");
            }
            return callback(null, "unknown");
        });
    }
    _moveCertificate(certificate, newStatus, callback) {
        assert(certificate instanceof Buffer);
        const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
        this.getCertificateStatus(certificate, (err, status) => {
            if (err) {
                return callback(err);
            }
            if (status !== newStatus) {
                const certificateSrc = path.join(this.rootDir, status, thumbprint + ".pem");
                const certificateDest = path.join(this.rootDir, newStatus, thumbprint + ".pem");
                fs.rename(certificateSrc, certificateDest, (err) => {
                    delete this._thumbs[status][thumbprint];
                    this._thumbs[newStatus][thumbprint] = 1;
                    return callback(err);
                });
            }
            else {
                return callback();
            }
        });
    }
    _readCertificates(callback) {
        function readThumbprint(certificateFilename) {
            const certificate = node_opcua_crypto_1.readCertificate(certificateFilename);
            //noinspection UnnecessaryLocalVariableJS
            const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
            return thumbprint;
        }
        function _f(folder, index, callback) {
            const walker = walk.walk(folder, { followLinks: false });
            walker.on("file", (root, stat, next) => {
                const filename = path.join(root, stat.name);
                const thumbprint = readThumbprint(filename);
                index[thumbprint] = 1;
                next();
            });
            walker.on("end", () => {
                return callback();
            });
        }
        async.series([
            (callback) => {
                _f.bind(this, path.join(this.rootDir, "trusted"), this._thumbs.trusted)
                    .call(null, callback);
            },
            (callback) => {
                _f.bind(this, path.join(this.rootDir, "rejected"), this._thumbs.rejected)
                    .call(null, callback);
            }
        ], callback);
    }
}
exports.CertificateManager = CertificateManager;
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
const opts = { multiArgs: false };
CertificateManager.prototype.rejectCertificate = thenify.withCallback(CertificateManager.prototype.rejectCertificate, opts);
CertificateManager.prototype.trustCertificate = thenify.withCallback(CertificateManager.prototype.trustCertificate, opts);
CertificateManager.prototype.createSelfSignedCertificate = thenify.withCallback(CertificateManager.prototype.createSelfSignedCertificate, opts);
CertificateManager.prototype.initialize = thenify.withCallback(CertificateManager.prototype.initialize, opts);
CertificateManager.prototype.getCertificateStatus = thenify.withCallback(CertificateManager.prototype.getCertificateStatus, opts);
//# sourceMappingURL=certificate_manager.js.map