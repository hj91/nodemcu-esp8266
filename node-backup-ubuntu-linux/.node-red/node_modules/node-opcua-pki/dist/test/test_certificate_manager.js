"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
Error.stackTraceLimit = Infinity;
// tslint:disable:variable-name
// tslint:disable:no-shadowed-variable
const async = require("async");
const fs = require("fs");
const path = require("path");
const util_1 = require("util");
const helpers_1 = require("./helpers");
const should = require("should");
const pki = require("../lib");
const lib_1 = require("../lib");
const _should = should;
const q = lib_1.quote;
const n = lib_1.make_path;
describe("CertificateManager", function () {
    this.timeout(400000);
    const test = helpers_1.beforeTest(this);
    it("should create a certificateManager", (done) => {
        const options = {
            location: path.join(test.tmpFolder, "PKI")
        };
        const cm = new pki.CertificateManager(options);
        cm.initialize((err) => {
            fs.existsSync(path.join(options.location)).should.eql(true);
            fs.existsSync(path.join(options.location, "trusted")).should.eql(true);
            fs.existsSync(path.join(options.location, "rejected")).should.eql(true);
            fs.existsSync(path.join(options.location, "own")).should.eql(true);
            fs.existsSync(path.join(options.location, "own/certs")).should.eql(true);
            fs.existsSync(path.join(options.location, "own/private")).should.eql(true);
            fs.existsSync(path.join(options.location, "own/openssl.cnf")).should.eql(true);
            fs.existsSync(path.join(options.location, "own/private/private_key.pem")).should.eql(true);
            const data = fs.readFileSync(path.join(options.location, "own/openssl.cnf"), "ascii");
            // config file must have a distinguish name section
            helpers_1.grep(data, /distinguished_name/).should.match(/distinguished_name/);
            done(err);
        });
    });
    it("should create its own self-signed certificate", (done) => {
        function get_days(date1, date2) {
            const ms_in_one_day = 24 * 3600000;
            const diff = date1.getTime() - date2.getTime();
            return Math.round(diff / ms_in_one_day);
        }
        const options = {
            location: path.join(test.tmpFolder, "PKI1")
        };
        const cm = new pki.CertificateManager(options);
        cm.initialize((err) => {
            if (err) {
                return done(err);
            }
            const now = new Date();
            const endDate = new Date(now.getFullYear() + 7, 10, 10);
            const duration = get_days(endDate, now);
            const params = {
                applicationUri: "MY:APPLICATION:URI",
                dns: [
                    "localhost",
                    "my.domain.com"
                ],
                ip: [
                    "192.123.145.121"
                ],
                subject: "/CN=MyCommonName",
                // can only be TODAY due to openssl limitation : startDate: new Date(2010,2,2),
                validity: duration,
            };
            cm.createSelfSignedCertificate(params, (err) => {
                if (err) {
                    return done(err);
                }
                const expectedCertificate = path.join(options.location, "own/certs/self_signed_certificate.pem");
                fs.existsSync(expectedCertificate).should.eql(true);
                lib_1.dumpCertificate(expectedCertificate, (err, data) => {
                    if (err || !data) {
                        return done(err || new Error("No Data"));
                    }
                    fs.writeFileSync(path.join(test.tmpFolder, "dump_cert1.txt"), data);
                    helpers_1.grep(data, /URI/).should.match(/URI:MY:APPLICATION:URI/);
                    helpers_1.grep(data, /DNS/).should.match(/DNS:localhost/);
                    helpers_1.grep(data, /DNS/).should.match(/DNS:my.domain.com/);
                    if (lib_1.g_config.opensslVersion.match(/1.0.2/)) {
                        // note openssl version 1.0.1 does support sha256 signature
                        helpers_1.grep(data, /Signature Algorithm/).should.match(/Signature Algorithm: sha256WithRSAEncryption/);
                    }
                    helpers_1.grep(data, /SelfSigned/).should.match(/SelfSigned/);
                    const y = (new Date()).getFullYear();
                    helpers_1.grep(data, /Not Before/).should.match(new RegExp(y.toString() + " GMT"));
                    helpers_1.grep(data, /Not After/).should.match(new RegExp((y + 7).toString() + " GMT"));
                    done();
                });
            });
        });
    });
});
describe("CertificateManager managing certificate", function () {
    this.timeout(400000);
    const test = helpers_1.beforeTest(this);
    let cm;
    function createSampleCertificateDer(certificate, callback) {
        lib_1.processAltNames({ applicationUri: "T" });
        const defaultOpensslConfPath = path.join(__dirname, "../tmp/PKI2/own/openssl.cnf");
        const defaultOpensslConf = lib_1.generateStaticConfig(defaultOpensslConfPath);
        certificate = lib_1.make_path(certificate);
        // openssl req -x509 -days 365 -nodes -newkey rsa:1024 \
        //         -keyout private_key.pem -outform der -out certificate.der"
        lib_1.execute_openssl("req " +
            "-x509 -days 365 -nodes -newkey rsa:1024 " +
            "-batch -keyout private_key.pem " +
            "-outform der -out " + q(n(certificate)) +
            " -config " + q(n(defaultOpensslConf)), {}, (err) => {
            callback(err);
        });
    }
    const sample_certificate1_der = path.join(__dirname, "fixtures/sample_certificate1.der");
    const sample_certificate2_der = path.join(__dirname, "fixtures/sample_certificate2.der");
    const sample_certificate3_der = path.join(__dirname, "fixtures/sample_certificate3.der");
    const sample_certificate4_der = path.join(__dirname, "fixtures/sample_certificate4.der");
    before((done) => {
        const options = {
            location: path.join(test.tmpFolder, "PKI2")
        };
        cm = new pki.CertificateManager(options);
        async.series([
            (callback) => {
                cm.initialize(callback);
            },
            (callback) => {
                createSampleCertificateDer(sample_certificate1_der, (err) => callback(err));
            },
            (callback) => {
                createSampleCertificateDer(sample_certificate2_der, (err) => callback(err));
            },
            (callback) => {
                createSampleCertificateDer(sample_certificate3_der, (err) => callback(err));
            },
            (callback) => {
                createSampleCertificateDer(sample_certificate4_der, (err) => callback(err));
            },
        ], done);
    });
    it("Q1 - CertificateManager#_getCertificateStatus should return 'unknown' if the certificate is first seen", (done) => {
        const certificate = fs.readFileSync(sample_certificate1_der);
        certificate.should.be.instanceOf(Buffer);
        async.series([
            (callback) => {
                lib_1.execute_openssl("x509 -inform der -in " + q(n(sample_certificate1_der)) + " " +
                    "-fingerprint -noout ", {}, (err) => {
                    callback(err);
                });
            },
            (callback) => {
                cm._getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("unknown");
                    callback();
                });
            }
        ], done);
    });
    it("Q2 - CertificateManager#getCertificateStatus should store unknown certificate into the untrusted folder", (done) => {
        const certificate = fs.readFileSync(sample_certificate2_der);
        async.series([
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("rejected");
                    callback();
                });
            },
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("rejected");
                    callback();
                });
            }
        ], done);
    });
    it("Q3 - CertificateManager#trustCertificate  should store in trusted folder", (done) => {
        const certificate = fs.readFileSync(sample_certificate3_der);
        async.series([
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("rejected");
                    callback();
                });
            },
            (callback) => {
                cm.trustCertificate(certificate, (err) => {
                    should(err).eql(null);
                    callback();
                });
            },
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("trusted");
                    callback();
                });
            },
            (callback) => {
                cm.rejectCertificate(certificate, (err) => {
                    should(err).eql(null);
                    callback();
                });
            },
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("rejected");
                    callback();
                });
            },
            (callback) => {
                cm.rejectCertificate(certificate, (err) => {
                    // already rejectied
                    should(err).eql(undefined);
                    callback();
                });
            }
        ], done);
    });
    it("Q4 - Async CertificateManager#trustCertificate  should store in trusted folder", () => __awaiter(this, void 0, void 0, function* () {
        const fsReadFile = util_1.promisify(fs.readFile);
        const certificate = yield fsReadFile(sample_certificate3_der);
        const status = yield cm.getCertificateStatus(certificate);
        status.should.eql("rejected");
        yield cm.trustCertificate(certificate);
        const status1 = yield cm.getCertificateStatus(certificate);
        status1.should.eql("trusted");
        yield cm.rejectCertificate(certificate);
        const status2 = yield cm.getCertificateStatus(certificate);
        status2.should.eql("rejected");
        yield cm.rejectCertificate(certificate);
    }));
});
//# sourceMappingURL=test_certificate_manager.js.map