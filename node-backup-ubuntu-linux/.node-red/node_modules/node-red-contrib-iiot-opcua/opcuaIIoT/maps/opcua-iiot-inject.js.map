{"version":3,"sources":["opcua-iiot-inject.js"],"names":["require","RED","install","coreInject","cron","OPCUAIIoTInject","config","nodes","this","topic","payload","payloadType","repeat","crontab","once","startDelay","parseFloat","name","injectType","node","addressSpaceItems","cronjob","REPEAT_FACTOR","ONE_SECOND","INPUT_TIMEOUT_MILLISECONDS","repeaterSetup","internalDebugLog","intervalId","clearInterval","setInterval","emit","CronJob","on","msg","Object","nodetype","assign","Number","JSON","parse","Date","now","util","evaluateNodeProperty","send","err","verbose","timeout","parseInt","onceTimeout","setTimeout","registerType","close","clearTimeout","stop","httpAdmin","post","auth","needsPermission","req","res","getNode","params","id","receive","sendStatus","error","_","toString"],"mappings":"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","file":"../opcua-iiot-inject.js","sourcesContent":["/**\n The BSD 3-Clause License\n\n Copyright 2016,2017,2018 - Klaus Landsdorf (http://bianco-royal.de/)\n Copyright 2013, 2016 IBM Corp. (node-red)\n All rights reserved.\n node-red-contrib-iiot-opcua\n **/\n'use strict'\n\n/**\n * Inject Node-RED node for OPC UA IIoT nodes.\n *\n * @param RED\n */\n\nmodule.exports = function (RED) {\n  require('source-map-support').install()\n  let coreInject = require('./core/opcua-iiot-core-inject')\n  let cron = require('cron')\n\n  function OPCUAIIoTInject (config) {\n    RED.nodes.createNode(this, config)\n\n    this.topic = config.topic\n    this.payload = config.payload\n    this.payloadType = config.payloadType\n    this.repeat = config.repeat\n    this.crontab = config.crontab\n    this.once = config.once\n    this.startDelay = parseFloat(config.startDelay) || 10\n    this.name = config.name\n    this.injectType = config.injectType || 'inject'\n\n    this.addressSpaceItems = config.addressSpaceItems || []\n\n    let node = this\n    node.intervalId = null\n    node.cronjob = null\n    node.REPEAT_FACTOR = 1000.0\n    node.ONE_SECOND = 1000\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n\n    node.repeaterSetup = function () {\n      coreInject.internalDebugLog('Repeat Is ' + node.repeat)\n      coreInject.internalDebugLog('Crontab Is ' + node.crontab)\n\n      if (node.repeat !== '') {\n        node.repeat = parseFloat(config.repeat) * node.REPEAT_FACTOR\n\n        if (node.repeat === 0) {\n          node.repeat = node.ONE_SECOND\n        }\n\n        coreInject.internalDebugLog('Repeat Interval Start With ' + node.repeat + ' msec.')\n\n        if (node.intervalId) {\n          clearInterval(node.intervalId)\n        }\n\n        node.intervalId = setInterval(function () {\n          node.emit('input', {})\n        }, node.repeat)\n      } else if (node.crontab !== '') {\n        node.cronjob = new cron.CronJob(node.crontab,\n          function () {\n            node.emit('input', {})\n          },\n          null,\n          true)\n      }\n    }\n\n    node.on('input', function (msg) {\n      try {\n        msg.topic = node.topic\n        msg.nodetype = 'inject'\n        msg.injectType = node.injectType\n        msg.addressSpaceItems = []\n        Object.assign(msg.addressSpaceItems, node.addressSpaceItems)\n\n        switch (node.payloadType) {\n          case 'none':\n            msg.payload = ''\n            break\n          case 'str':\n            msg.payload = node.payload.toString()\n            break\n          case 'num':\n            msg.payload = Number(node.payload)\n            break\n          case 'bool':\n            msg.payload = (node.payload === true || node.payload === 'true')\n            break\n          case 'json':\n            msg.payload = JSON.parse(node.payload)\n            break\n          case 'date':\n            msg.payload = Date.now()\n            break\n          default:\n            if (node.payloadType === null) {\n              if (node.payload === '') {\n                msg.payload = Date.now()\n              } else {\n                msg.payload = node.payload\n              }\n            } else {\n              msg.payload = RED.util.evaluateNodeProperty(node.payload, node.payloadType, this, msg)\n            }\n        }\n\n        node.send(msg)\n      } catch (err) {\n        if (RED.settings.verbose) {\n          node.error(err, msg)\n        }\n      }\n    })\n\n    if (node.once) {\n      let timeout = parseInt(node.INPUT_TIMEOUT_MILLISECONDS * node.startDelay)\n      coreInject.internalDebugLog('injecting once at start delay timeout ' + timeout + ' msec.')\n      node.onceTimeout = setTimeout(function () {\n        coreInject.internalDebugLog('injecting once at start')\n        node.emit('input', {})\n        node.repeaterSetup()\n      }, timeout)\n    } else {\n      node.repeaterSetup()\n    }\n  }\n\n  RED.nodes.registerType('OPCUA-IIoT-Inject', OPCUAIIoTInject)\n\n  OPCUAIIoTInject.prototype.close = function () {\n    let node = this\n\n    if (node.onceTimeout) {\n      clearTimeout(node.onceTimeout)\n      node.onceTimeout = null\n    }\n\n    if (node.intervalId) {\n      clearInterval(node.intervalId)\n      node.intervalId = null\n    }\n\n    if (node.cronjob) {\n      node.cronjob.stop()\n      delete node['cronjob']\n    }\n  }\n\n  RED.httpAdmin.post('/opcuaIIoT/inject/:id', RED.auth.needsPermission('opcuaIIoT.inject.write'), function (req, res) {\n    let node = RED.nodes.getNode(req.params.id)\n\n    if (node) {\n      try {\n        node.receive()\n        res.sendStatus(200)\n      } catch (err) {\n        res.sendStatus(500)\n        node.error(RED._('opcuaiiotinject.failed', {error: err.toString()}))\n      }\n    } else {\n      res.sendStatus(404)\n    }\n  })\n}\n"]}