{"version":3,"sources":["opcua-iiot-response.js"],"names":["module","exports","RED","require","install","coreResponse","nodes","registerType","config","OPCUAIIoTResponse","createNode","this","name","compressStructure","showStatusActivities","showErrors","activateUnsetFilter","activateFilters","negateFilter","node","fill","shape","text","msg","analyzeBrowserResults","handleBrowserMsg","handleReadMsg","analyzeReadResults","compressReadMessageStructure","handleWriteMsg","compressWriteMessageStructure","analyzeWriteResults","analyzeListenerResults","handleMethodMsg","handleListenerMsg","compressMethodMessageStructure","handleDefaultMsg","payload","handlePayloadStatusCode","analyzeMethodResults","handleNodeTypeOfMsg","message","Object","assign","compressDefaultMessageStructure","extractEntries","filteredEntries","forEach","itemIsNotToFilter","item","push","length","on","filters","filterMsg","err","internalDebugLog","error","result","core","checkItemForUnsetState","element"],"mappings":"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","file":"../opcua-iiot-response.js","sourcesContent":["/*\n The BSD 3-Clause License\n\n Copyright 2017,2018 - Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-iiot-opcua\n */\n'use strict'\n\n/**\n * Response analyser Node-RED node for OPC UA IIoT nodes.\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  require('source-map-support').install()\n  let coreResponse = require('./core/opcua-iiot-core-response')\n\n  function OPCUAIIoTResponse (config) {\n    RED.nodes.createNode(this, config)\n    this.name = config.name\n    this.compressStructure = config.compressStructure\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.activateUnsetFilter = config.activateUnsetFilter\n    this.activateFilters = config.activateFilters\n    this.negateFilter = config.negateFilter\n    this.filters = config.filters\n\n    let node = this\n\n    node.status({fill: 'green', shape: 'ring', text: 'active'})\n\n    node.handleBrowserMsg = function (msg) {\n      coreResponse.analyzeBrowserResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressBrowseMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.handleReadMsg = function (msg) {\n      coreResponse.analyzeReadResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressReadMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.handleWriteMsg = function (msg) {\n      coreResponse.analyzeWriteResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressWriteMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.handleListenerMsg = function (msg) {\n      coreResponse.analyzeListenerResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressListenMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.handleMethodMsg = function (msg) {\n      coreResponse.analyzeMethodResults(node, msg)\n      if (node.compressStructure) {\n        coreResponse.compressMethodMessageStructure(msg)\n      }\n      return msg\n    }\n\n    node.handleDefaultMsg = function (msg) {\n      if (msg && msg.payload) {\n        coreResponse.handlePayloadStatusCode(node, msg)\n        if (node.compressStructure) {\n          coreResponse.compressDefaultMessageStructure(msg)\n        }\n      }\n      return msg\n    }\n\n    node.handleNodeTypeOfMsg = function (msg) {\n      let message = Object.assign({}, msg)\n\n      switch (msg.nodetype) {\n        case 'browse':\n          message = node.handleBrowserMsg(message)\n          break\n        case 'read':\n          message = node.handleReadMsg(message)\n          break\n        case 'write':\n          message = node.handleWriteMsg(message)\n          break\n        case 'listen':\n          message = node.handleListenerMsg(message)\n          break\n        case 'method':\n          message = node.handleMethodMsg(message)\n          break\n        default:\n          message = node.handleDefaultMsg(message)\n      }\n\n      return message\n    }\n\n    node.extractEntries = function (msg) {\n      let filteredEntries = []\n      msg.payload.forEach((item) => {\n        if (node.itemIsNotToFilter(item)) {\n          filteredEntries.push(item)\n        }\n      })\n      return filteredEntries\n    }\n\n    node.filterMsg = function (msg) {\n      if (msg.payload.length) {\n        let filteredEntries = node.extractEntries(msg)\n        if (filteredEntries.length) {\n          msg.payload = filteredEntries\n          return msg\n        }\n      } else {\n        if (node.itemIsNotToFilter(msg.payload)) {\n          return msg\n        }\n      }\n      return null\n    }\n\n    node.on('input', function (msg) {\n      try {\n        let message = node.handleNodeTypeOfMsg(msg)\n\n        if (node.activateFilters && node.filters && node.filters.length > 0) {\n          message = node.filterMsg(message)\n          if (message) {\n            node.send(message)\n          }\n        } else {\n          node.send(message)\n        }\n      } catch (err) {\n        coreResponse.internalDebugLog(err)\n        if (node.showErrors) {\n          node.error(err, msg)\n        }\n      }\n    })\n\n    node.itemIsNotToFilter = function (item) {\n      let result = coreResponse.core.checkItemForUnsetState(node, item)\n\n      node.filters.forEach((element) => {\n        result = coreResponse.core.checkResponseItemIsNotToFilter(node, item, element, result)\n      })\n\n      return (node.negateFilter) ? !result : result\n    }\n  }\n\n  RED.nodes.registerType('OPCUA-IIoT-Response', OPCUAIIoTResponse)\n}\n"]}