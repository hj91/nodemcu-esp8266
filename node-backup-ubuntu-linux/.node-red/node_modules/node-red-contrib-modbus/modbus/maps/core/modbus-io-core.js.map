{"version":3,"sources":["core/modbus-io-core.js"],"names":["require","install","de","biancoroyal","modbus","io","core","internalDebug","LineByLineReader","nameValuesFromIOFile","node","msg","values","response","readingOffset","valueNames","ioFile","configData","mapping","valueAddress","startsWith","buildInputAddressMapping","Number","addressOffset","logIOActivities","buildOutputAddressMapping","ioCore","insertValues","convertValuesByType","allValueNamesFromIOFile","ioNode","getDataTypeFromFirstCharType","type","registerName","offset","logging","addressStart","coilStart","bits","name","substring","registerType","split","addressType","Math","floor","bitAddress","addressStartIO","addressOffsetIO","registerAddress","Bit","dataType","register","error","index","item","hasOwnProperty","JSON","stringify","value","pow","getValueFromBufferByDataType","bufferOffset","responseBuffer","registerLength","length","readUInt16BE","readInt8","readInt16BE","convertedValue","readInt32BE","readIntBE","readFloatBE","readDoubleBE","readUInt8","readUInt32BE","readUIntBE","sixteenBitBufferLength","isRegisterSizeWrong","buffer","Buffer","err","filterValueNames","fc","adr","quantity","filter","functionType","startRegister","endRegister","valueName","start","sizeDivisor","buildMessageWithIO","bufferMessageList","origMsg","payload","topic","rawMsg","Object","assign","useIOFile","lastUpdatedAt","parseInt","address","allValueNames","module","exports"],"mappings":"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","file":"../../core/modbus-io-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018 Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\nvar de = de || {biancoroyal: {modbus: {io: {core: {}}}}} // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.internalDebug = de.biancoroyal.modbus.io.core.internalDebug || require('debug')('contribModbus:io:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.LineByLineReader = de.biancoroyal.modbus.io.core.LineByLineReader || require('line-by-line') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.core = de.biancoroyal.modbus.io.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.io.core.nameValuesFromIOFile = function (node, msg, values, response, readingOffset) {\n  let valueNames = []\n  let ioCore = de.biancoroyal.modbus.io.core\n\n  if (node.ioFile && node.ioFile.configData) {\n    node.ioFile.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n    })\n  }\n\n  valueNames = ioCore.insertValues(valueNames, values, node.logIOActivities)\n\n  return ioCore.convertValuesByType(valueNames, values, response, node.logIOActivities)\n}\n\nde.biancoroyal.modbus.io.core.allValueNamesFromIOFile = function (ioNode) {\n  let valueNames = []\n  let ioCore = de.biancoroyal.modbus.io.core\n\n  if (ioNode && ioNode.configData) {\n    ioNode.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n    })\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getDataTypeFromFirstCharType = function (type) {\n  switch (type) {\n    case 'w':\n      return 'Word'\n    case 'd':\n      return 'Double'\n    case 'r':\n      return 'Real'\n    case 'f':\n      return 'Float'\n    case 'i':\n      return 'Integer'\n    case 'l':\n      return 'Long'\n    case 'b':\n      return 'Boolean'\n    default:\n      return 'Unsigned Integer'\n  }\n}\n\nde.biancoroyal.modbus.io.core.buildInputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  let ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  let type = mapping.name.substring(0, 1)\n  let registerType = mapping.valueAddress.substring(2, 3)\n  let addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%IX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown input type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    let addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      'register': registerName,\n      'name': mapping.name,\n      'addressStart': addressStart,\n      'addressOffset': addressOffset,\n      'addressOffsetIO': Number(offset) || 0,\n      'addressStartIO': addressStartIO,\n      'registerAddress': addressStartIO - Number(readingOffset),\n      'coilStart': coilStart,\n      'bitAddress': bitAddress,\n      'Bit': (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      'bits': bits,\n      'dataType': ioCore.getDataTypeFromFirstCharType(type),\n      'type': 'input'\n    }\n  }\n\n  return {'name': mapping.name, 'type': type, 'mapping': mapping, 'error': 'variable name does not match input mapping'}\n}\n\nde.biancoroyal.modbus.io.core.buildOutputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  let ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  let type = mapping.name.substring(0, 1)\n  let registerType = mapping.valueAddress.substring(2, 3)\n  let addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%QX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown output type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    let addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      'register': registerName,\n      'name': mapping.name,\n      'addressStart': addressStart,\n      'addressOffset': addressOffset,\n      'addressOffsetIO': Number(offset) || 0,\n      'addressStartIO': addressStartIO,\n      'registerAddress': addressStartIO - Number(readingOffset),\n      'coilStart': coilStart,\n      'bitAddress': bitAddress,\n      'Bit': (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      'bits': bits,\n      'dataType': ioCore.getDataTypeFromFirstCharType(type),\n      'type': 'output'\n    }\n  }\n\n  return {'name': mapping.name, 'type': type, 'mapping': mapping, 'error': 'variable name does not match output mapping'}\n}\n\nde.biancoroyal.modbus.io.core.insertValues = function (valueNames, register, logging) {\n  let ioCore = de.biancoroyal.modbus.io.core\n\n  let index = 0\n  for (index in valueNames) {\n    let item = valueNames[index]\n\n    if (!item || !item.hasOwnProperty('registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Insert Value ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    switch (Number(item.bits)) {\n      case 1:\n        item.value = !!((register[item.registerAddress] & Math.pow(item.bitAddress[1], 2)))\n        break\n      case 16:\n        item.value = register[item.registerAddress]\n        break\n      case 32:\n        item.value = register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 64:\n        item.value = register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 80:\n        item.value = register[item.registerAddress + 4] << 64 |\n          register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      default:\n        item.value = null\n        break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getValueFromBufferByDataType = function (item, bufferOffset, responseBuffer, logging) {\n  let ioCore = de.biancoroyal.modbus.io.core\n  let registerLength = responseBuffer.length / 2\n\n  if (bufferOffset < 0 || bufferOffset > responseBuffer.length) {\n    if (logging) {\n      ioCore.internalDebug('Wrong Buffer Access Parameter Type:' + item.dataType + ' Register-Length: ' + registerLength +\n        ' Buffer-Length:' + responseBuffer.length + ' Address-Buffer-Offset:' + bufferOffset)\n      ioCore.internalDebug(JSON.stringify(item))\n    }\n    return item\n  }\n\n  if (logging) {\n    ioCore.internalDebug('Get Value From Buffer By Data Type:' + item.dataType + ' Register:' + item.registerAddress + ' Bits:' + Number(item.bits))\n  }\n\n  switch (item.dataType) {\n    case 'Boolean':\n      item.value = !!(responseBuffer.readUInt16BE(bufferOffset) & Math.pow(item.bitAddress[1], 2))\n      break\n    case 'Word':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset) // DWord\n          item.convertedValue = false\n      }\n      break\n    case 'Integer':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset)\n      }\n      break\n    case 'Real':\n    case 'Float':\n      item.value = responseBuffer.readFloatBE(bufferOffset, 4)\n      break\n    case 'Double':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 8)\n      break\n    case 'Long':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 10)\n      break\n    default:\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readUInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readUInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readUIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readUInt16BE(bufferOffset)\n          item.convertedValue = false\n      }\n      break\n  }\n\n  return item\n}\n\nde.biancoroyal.modbus.io.core.convertValuesByType = function (valueNames, register, responseBuffer, logging) {\n  let ioCore = de.biancoroyal.modbus.io.core\n  let bufferOffset = 0\n  let sixteenBitBufferLength = 2\n\n  let index = 0\n  for (index in valueNames) {\n    let item = valueNames[index]\n\n    if (!item || !item.hasOwnProperty('dataType') || !item.hasOwnProperty('registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Convert ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    if (responseBuffer.buffer instanceof Buffer) {\n      bufferOffset = Number(item.registerAddress) * sixteenBitBufferLength\n      try {\n        item = ioCore.getValueFromBufferByDataType(item, bufferOffset, responseBuffer.buffer, logging)\n      } catch (err) {\n        ioCore.internalDebug(err.message)\n      }\n    } else {\n      if (logging) {\n        ioCore.internalDebug('Response Buffer Is Not A Buffer')\n      }\n      break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.filterValueNames = function (node, valueNames, fc, adr, quantity) {\n  if (!valueNames.length || !valueNames.filter) {\n    return valueNames\n  }\n\n  let ioCore = de.biancoroyal.modbus.io.core\n  let functionType = 'input'\n\n  if (fc === 2 || fc === 4) {\n    functionType = 'output'\n  }\n\n  let startRegister = adr\n  let endRegister = Number(adr) + Number(quantity) - 1\n\n  if (node.logIOActivities) {\n    ioCore.internalDebug('adr:' + adr + ' quantity:' + quantity + ' startRegister:' + startRegister + ' endRegister:' + endRegister + ' functionType:' + functionType)\n  }\n\n  return valueNames.filter((valueName) => {\n    return (valueName.registerAddress >= 0 &&\n      valueName.addressStartIO >= startRegister &&\n      valueName.addressStartIO <= endRegister &&\n      valueName.type === functionType)\n  })\n}\n\nde.biancoroyal.modbus.io.core.isRegisterSizeWrong = function (register, start, bits) {\n  let sizeDivisor = Number(bits) || 16\n  let startRegister = Number(start)\n  let endRegister = startRegister\n\n  if (sizeDivisor > 16) {\n    endRegister = startRegister + (sizeDivisor / 16) - 1\n  }\n\n  return (startRegister < 0 || register.length < startRegister || endRegister > register.length)\n}\n\nde.biancoroyal.modbus.io.core.buildMessageWithIO = function (node, values, response, msg) {\n  let origMsg = this.core.getOriginalMessage(node.bufferMessageList, msg)\n  origMsg.payload = values\n  origMsg.topic = msg.topic\n  origMsg.responseBuffer = response\n  origMsg.input = msg\n\n  let rawMsg = Object.assign({}, origMsg)\n  rawMsg.payload = response\n  rawMsg.values = values\n  delete rawMsg['responseBuffer']\n\n  if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n    let allValueNames = this.nameValuesFromIOFile(node, msg, values, response, parseInt(msg.payload.address) || 0)\n    let valueNames = this.filterValueNames(node, allValueNames, parseInt(msg.payload.fc) || 3,\n      parseInt(msg.payload.address) || 0,\n      parseInt(msg.payload.quantity) || 1,\n      node.logIOActivities)\n\n    if (node.useIOForPayload) {\n      origMsg.payload = valueNames\n      origMsg.values = values\n    } else {\n      origMsg.payload = values\n      origMsg.valueNames = valueNames\n    }\n\n    rawMsg.valueNames = valueNames\n    return [origMsg, rawMsg]\n  } else {\n    return [origMsg, rawMsg]\n  }\n}\n\nmodule.exports = de.biancoroyal.modbus.io.core\n"]}