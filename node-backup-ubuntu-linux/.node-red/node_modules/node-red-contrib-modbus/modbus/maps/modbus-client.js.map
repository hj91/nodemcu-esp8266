{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusClient","nodes","registerType","config","createNode","this","timeoutTimeMS","clienttype","reconnectTimeMS","bufferCommands","stateLogEnabled","tcpType","tcpPort","parseInt","serialBaudrate","serialDatabits","serialPort","serialStopbits","serialConnectionDelay","serialType","clientTimeout","minCommandDelayMilliseconds","unit_id","reconnectTimeout","node","verboseWarn","logMessage","settings","verbose","serverInfo","verboseLog","stateLog","queueLog","closingModbus","isFirstInitOfConnection","Map","client","bufferCommandList","messagesAllowedStates","sendAllowed","messageAllowedStates","createStatelyMachine","statlyMachine","getMachineState","getMachineEvents","clear","initQueue","step","unitSendingAllowed","set","checkUnitId","unitid","setUnitIdFromPayload","msg","unit","payload","queueUnitId","defaultUnitId","Number","isNaN","command","noneCommandSent","sequentialDequeueCommand","shift","serialUnit","JSON","stringify","type","get","length","sendAllowedForNext","queueLength","push","callModbus","cb","cberr","empty","dequeueCommand","state","indexOf","commandDelay","checkQueuesAreEmpty","queueIsEmpty","updateServerinfo","tcpHost","onNEW","event","oldState","newState","onINIT","setTimeout","connectClient","serialConnectionDelayTimeMS","error","err","onCONNECTED","activate","onACTIVATED","emit","queue","onQUEUEING","onOPENED","onCLOSED","break","onFAILED","onBROKEN","init","close","message","ModbusRTU","Error","failure","connectC701","port","autoOpen","setTCPConnected","then","setTCPConnectionOptions","connectTelnet","catch","modbusTcpErrorHandling","connectTCP","baudRate","dataBits","stopBits","parity","serialParity","setSerialConnectionOptions","connectRTU","connectRTUBuffered","modbusSerialDebug","connect","openSerialClient","modbusErrorHandling","networkErrors","includes","errno","_port","on","onModbusClose","getQueueNumber","isInteger","pushToQueueByUnitId","info","queueUnit","queueNumber","readModbus","timeout","getTimeout","fc","readCoils","address","quantity","resp","activateSending","readDiscreteInputs","readHoldingRegisters","internalDebug","e","writeModbus","write","writeCoils","value","writeRegister","setMaxListeners","invalidPayloadIn","connectorType","unitId","done","stop","registeredNodeList","registerForModbus","modbusNode","id","Object","keys","deregisterForModbus","httpAdmin","auth","needsPermission","req","res","list","ports","console","log","json"],"mappings":"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","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018 Klaus Landsdorf (http://bianco-royal.de/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let coreModbusClient = require('./core/modbus-client-core')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    let ModbusRTU = require('modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n\n    this.clienttype = config.clienttype\n    this.bufferCommands = config.bufferCommands\n    this.stateLogEnabled = config.stateLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n\n    this.unit_id = parseInt(config.unit_id) || defaultUnitId\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n\n    let node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messagesAllowedStates\n    node.serverInfo = ''\n\n    node.statlyMachine = null\n    node.statlyMachine = coreModbusClient.createStatelyMachine()\n    stateLog('start: ' + node.statlyMachine.getMachineState())\n    stateLog('FSM events:' + node.statlyMachine.getMachineEvents())\n\n    node.initQueue = function () {\n      node.bufferCommandList.clear()\n      node.sendAllowed.clear()\n      node.unitSendingAllowed = []\n\n      for (let step = 0; step <= 255; step++) {\n        node.bufferCommandList.set(step, [])\n        node.sendAllowed.set(step, true)\n      }\n    }\n\n    node.checkUnitId = function (unitid) {\n      if (node.clienttype === 'tcp') {\n        return unitid >= 0 && unitid <= 255\n      } else {\n        return unitid >= 1 && unitid <= 247\n      }\n    }\n\n    node.setUnitIdFromPayload = function (msg) {\n      let unit = parseInt(msg.payload.unitid)\n\n      if (Number.isInteger(unit)) {\n        node.client.setID(unit)\n        msg.queueUnitId = unit\n      } else {\n        if (!node.checkUnitId(node.unit_id)) {\n          node.unit_id = defaultUnitId\n        }\n        node.client.setID(node.unit_id)\n        msg.queueUnitId = node.unit_id\n      }\n    }\n\n    if (Number.isNaN(node.unit_id) || !node.checkUnitId(node.unit_id)) {\n      node.unit_id = defaultUnitId\n    }\n\n    node.sequentialDequeueCommand = function () {\n      let command = null\n      let noneCommandSent = true\n      let serialUnit = parseInt(node.unitSendingAllowed.shift())\n\n      if (Number.isInteger(serialUnit) &&\n        node.bufferCommandList.get(serialUnit).length > 0) {\n        queueLog(JSON.stringify({\n          type: 'queue check',\n          unitid: serialUnit,\n          sendAllowed: node.sendAllowed.get(serialUnit),\n          queueLength: node.bufferCommandList.get(serialUnit).length\n        }))\n\n        if (node.sendAllowed.get(serialUnit)) {\n          command = node.bufferCommandList.get(serialUnit).shift()\n          if (command) {\n            node.sendAllowed.set(serialUnit, false)\n            queueLog(JSON.stringify({\n              type: 'serial sending and wait',\n              unitid: serialUnit,\n              // commandData: command,\n              queueLength: node.bufferCommandList.get(serialUnit).length,\n              sendAllowedForNext: node.sendAllowed.get(serialUnit),\n              delay: node.commandDelay\n            }))\n\n            if (node.bufferCommandList.get(serialUnit).length > 0) {\n              node.unitSendingAllowed.push(serialUnit)\n            }\n            noneCommandSent = false\n            command.callModbus(command.msg, command.cb, command.cberr)\n          }\n        }\n      } else {\n        queueLog(JSON.stringify({\n          type: 'queue check is not a unit',\n          unitid: serialUnit\n        }))\n      }\n\n      if (noneCommandSent) {\n        node.statlyMachine.empty()\n      }\n    }\n\n    node.dequeueCommand = function () {\n      let state = node.statlyMachine.getMachineState()\n\n      if (node.messageAllowedStates.indexOf(state) === -1) {\n        queueLog(JSON.stringify({\n          state: state,\n          message: 'dequeue command disallowed state',\n          delay: node.commandDelay\n        }))\n      } else {\n        queueLog(JSON.stringify({\n          state: state,\n          message: 'dequeue command ' + node.clienttype,\n          delay: node.commandDelay\n        }))\n\n        node.sequentialDequeueCommand()\n      }\n\n      if (node.checkQueuesAreEmpty()) {\n        node.statlyMachine.empty()\n      }\n    }\n\n    node.checkQueuesAreEmpty = function () {\n      let queueIsEmpty = true\n      for (let step = 0; step <= 255; step++) {\n        queueIsEmpty &= (node.bufferCommandList.get(step).length > 0)\n      }\n      return queueIsEmpty\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    function queueLog (logMessage) {\n      if (node.bufferCommands) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.statlyMachine.onNEW = function (event, oldState, newState) {\n      stateLog('after event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n    }\n\n    node.statlyMachine.onINIT = function (event, oldState, newState) {\n      stateLog('after event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.updateServerinfo()\n      node.initQueue()\n\n      try {\n        if (node.isFirstInitOfConnection) {\n          node.isFirstInitOfConnection = false\n          setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n        } else {\n          setTimeout(node.connectClient, node.reconnectTimeout)\n        }\n      } catch (err) {\n        node.error(err, {payload: 'client connection error'})\n      }\n\n      verboseWarn('reconnect in ' + node.reconnectTimeout + ' ms')\n      verboseLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbinit')\n    }\n\n    node.statlyMachine.onCONNECTED = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbconnected')\n      node.statlyMachine.activate()\n    }\n\n    node.statlyMachine.onACTIVATED = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbactive')\n      if (node.bufferCommands) {\n        node.statlyMachine.queue()\n      }\n    }\n\n    node.statlyMachine.onQUEUEING = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      setTimeout(node.dequeueCommand, node.commandDelay)\n      node.emit('mbqueue')\n    }\n\n    node.statlyMachine.onOPENED = function (event, oldState, newState) {\n      verboseLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbopen')\n    }\n\n    node.statlyMachine.onCLOSED = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbclosed')\n      node.statlyMachine.break()\n    }\n\n    node.statlyMachine.onFAILED = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mberror', 'FSM Reset On State ' + oldState)\n      node.statlyMachine.break()\n    }\n\n    node.statlyMachine.onBROKEN = function (event, oldState, newState) {\n      stateLog('event: ' + event + ' old: ' + oldState + ' new: ' + newState)\n      node.emit('mbbroken')\n      if (node.reconnectTimeout <= 0) {\n        node.reconnectTimeout = reconnectTimeMS\n      }\n      verboseWarn('try to reconnect by init in ' + node.reconnectTimeout + ' ms')\n      setTimeout(node.statlyMachine.init, node.reconnectTimeout)\n    }\n\n    node.connectClient = function () {\n      if (node.client) {\n        try {\n          node.client.close(function () {\n            verboseLog('connection closed')\n          })\n        } catch (err) {\n          verboseLog(err.message)\n        }\n      }\n      node.client = null\n      node.client = new ModbusRTU()\n\n      if (!node.clientTimeout) {\n        node.clientTimeout = timeoutTimeMS\n      }\n\n      if (!node.reconnectTimeout) {\n        node.reconnectTimeout = reconnectTimeMS\n      }\n\n      if (node.clienttype === 'tcp') {\n        if (!node.checkUnitId(node.unit_id)) {\n          node.error(new Error('wrong unit-id (0..255)'), {payload: node.unit_id})\n          node.statlyMachine.failure()\n          return\n        }\n\n        switch (node.tcpType) {\n          case 'C701':\n            verboseLog('C701 port UDP bridge')\n            node.client.connectC701(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .then(node.setTCPConnected)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TELNET':\n            verboseLog('Telnet port')\n            node.client.connectTelnet(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TPC-RTU-BUFFERED':\n            verboseLog('TCP RTU buffered port')\n            node.client.connectTcpRTUBuffered(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          default:\n            verboseLog('TCP port')\n            node.client.connectTCP(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n        }\n      } else {\n        if (!node.checkUnitId(node.unit_id)) {\n          node.error(new Error('wrong unit-id serial (1..247)'), {payload: node.unit_id})\n          node.statlyMachine.failure()\n          return\n        }\n\n        if (!node.serialConnectionDelay) {\n          node.serialConnectionDelay = serialConnectionDelayTimeMS\n        }\n\n        if (!node.serialPort) {\n          node.error(new Error('wrong serial port'), {payload: node.serialPort})\n          node.statlyMachine.failure()\n          return\n        }\n\n        switch (node.serialType) {\n          case 'ASCII':\n            verboseLog('ASCII port serial')\n            node.client.connectAsciiSerial(node.serialPort, {\n              baudRate: parseInt(node.serialBaudrate),\n              dataBits: parseInt(node.serialDatabits),\n              stopBits: parseInt(node.serialStopbits),\n              parity: node.serialParity,\n              autoOpen: false\n            }).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          case 'RTU':\n            verboseLog('RTU port serial')\n            node.client.connectRTU(node.serialPort, {\n              baudRate: parseInt(node.serialBaudrate),\n              dataBits: parseInt(node.serialDatabits),\n              stopBits: parseInt(node.serialStopbits),\n              parity: node.serialParity,\n              autoOpen: false\n            }).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          default:\n            verboseLog('RTU buffered port serial')\n            node.client.connectRTUBuffered(node.serialPort, {\n              baudRate: parseInt(node.serialBaudrate),\n              dataBits: parseInt(node.serialDatabits),\n              stopBits: parseInt(node.serialStopbits),\n              parity: node.serialParity,\n              autoOpen: false\n            }).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n        }\n      }\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.statlyMachine.connect()\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.statlyMachine.openserial()\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.statlyMachine.failure()\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.statlyMachine.failure()\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n      }\n      node.statlyMachine.failure()\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.statlyMachine.getMachineState() === 'OPENED') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.statlyMachine.connect()\n      } else {\n        verboseLog('wrong state on connect serial ' + node.statlyMachine.getMachineState())\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.statlyMachine.getMachineState())\n        node.statlyMachine.failure()\n      }\n    }\n\n    node.onModbusClose = function () {\n      verboseWarn('modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.statlyMachine.close()\n    }\n\n    node.getQueueNumber = function (msg) {\n      let unit = parseInt(msg.payload.unitid)\n\n      if (Number.isInteger(unit)) {\n        return node.bufferCommandList.get(unit).length\n      } else {\n        return node.bufferCommandList.get(node.unit_id).length\n      }\n    }\n\n    node.pushToQueueByUnitId = function (callModbus, msg, cb, cberr) {\n      let unit = parseInt(msg.payload.unitid)\n\n      if (Number.isInteger(unit)) {\n        msg.queueUnit = unit\n        queueLog(JSON.stringify({\n          info: 'push to Queue by Unit-Id',\n          message: msg.payload,\n          unit: unit\n        }))\n\n        if (node.unitSendingAllowed.indexOf(unit) === -1) {\n          node.unitSendingAllowed.push(unit)\n        }\n\n        node.bufferCommandList.get(unit).push({callModbus: callModbus, msg: msg, cb: cb, cberr: cberr})\n      } else {\n        msg.queueUnit = node.unit_id\n        queueLog(JSON.stringify({\n          info: 'push to Queue by default Unit-Id',\n          message: msg.payload,\n          unit: node.unit_id\n        }))\n\n        if (node.unitSendingAllowed.indexOf(node.unit_id) === -1) {\n          node.unitSendingAllowed.push(node.unit_id)\n        }\n\n        node.bufferCommandList.get(node.unit_id).push({callModbus: callModbus, msg: msg, cb: cb, cberr: cberr})\n      }\n    }\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      let state = node.statlyMachine.getMachineState()\n\n      if (node.messageAllowedStates.indexOf(state) === -1) {\n        cberr(new Error('FSM Not Ready To Read At State ' + state), msg)\n        return\n      }\n\n      if (node.bufferCommands) {\n        msg.queueNumber = node.getQueueNumber(msg)\n        node.pushToQueueByUnitId(node.readModbus, msg, cb, cberr)\n        node.statlyMachine.queue()\n\n        queueLog(JSON.stringify({\n          info: 'queue read msg',\n          message: msg.payload,\n          state: state,\n          queueLength: node.bufferCommandList.get(msg.queueUnit).length\n        }))\n      } else {\n        node.readModbus(msg, cb, cberr)\n      }\n    })\n\n    node.readModbus = function (msg, cb, cberr) {\n      if (!node.client) {\n        return\n      }\n\n      if (!node.bufferCommands) {\n        node.statlyMachine.read()\n      }\n\n      node.setUnitIdFromPayload(msg)\n      node.client.setTimeout(node.clientTimeout)\n\n      queueLog(JSON.stringify({\n        info: 'read msg',\n        message: msg.payload,\n        unitid: msg.queueUnitId,\n        timeout: node.client.getTimeout(),\n        state: node.statlyMachine.getMachineState()\n      }))\n\n      try {\n        switch (parseInt(msg.payload.fc)) {\n          case 1: // FC: 1\n            node.client.readCoils(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n              node.activateSending(msg)\n              cb(resp, msg)\n            }).catch(function (err) {\n              node.activateSending(msg)\n              cberr(err, msg)\n              node.modbusErrorHandling(err)\n            })\n            break\n          case 2: // FC: 2\n            node.client.readDiscreteInputs(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n              node.activateSending(msg)\n              cb(resp, msg)\n            }).catch(function (err) {\n              node.activateSending(msg)\n              cberr(err, msg)\n              node.modbusErrorHandling(err)\n            })\n            break\n          case 3: // FC: 3\n            node.client.readHoldingRegisters(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n              node.activateSending(msg)\n              cb(resp, msg)\n            }).catch(function (err) {\n              node.activateSending(msg)\n              cberr(err, msg)\n              node.modbusErrorHandling(err)\n            })\n            break\n          case 4: // FC: 4\n            node.client.readInputRegisters(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n              node.activateSending(msg)\n              cb(resp, msg)\n            }).catch(function (err) {\n              node.activateSending(msg)\n              cberr(err, msg)\n              node.modbusErrorHandling(err)\n            })\n            break\n          default:\n            node.activateSending(msg)\n            cberr(new Error('Function Code Unknown'), msg)\n            coreModbusClient.internalDebug('Function Code Unknown %s', msg.payload.fc)\n            break\n        }\n      } catch (e) {\n        coreModbusClient.internalDebug(e.message)\n        node.modbusErrorHandling(e)\n      }\n    }\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      let state = node.statlyMachine.getMachineState()\n\n      if (node.messageAllowedStates.indexOf(state) === -1) {\n        cberr(new Error('FSM Not Ready To Write At State ' + state), msg)\n        return\n      }\n\n      if (node.bufferCommands) {\n        msg.queueNumber = node.getQueueNumber(msg)\n        node.pushToQueueByUnitId(node.writeModbus, msg, cb, cberr)\n        node.statlyMachine.queue()\n\n        queueLog(JSON.stringify({\n          info: 'queue write msg',\n          message: msg.payload,\n          state: state,\n          queueLength: node.bufferCommandList.get(msg.queueUnit).length\n        }))\n      } else {\n        node.writeModbus(msg, cb, cberr)\n      }\n    })\n\n    node.writeModbus = function (msg, cb, cberr) {\n      if (!node.client) {\n        return\n      }\n\n      if (!node.bufferCommands) {\n        node.statlyMachine.write()\n      }\n\n      node.setUnitIdFromPayload(msg)\n      node.client.setTimeout(node.clientTimeout)\n\n      queueLog(JSON.stringify({\n        info: 'write msg',\n        message: msg.payload,\n        unitid: msg.queueUnitId,\n        timeout: node.client.getTimeout(),\n        state: node.statlyMachine.getMachineState()\n      }))\n\n      try {\n        switch (parseInt(msg.payload.fc)) {\n          case 15: // FC: 15\n            if (parseInt(msg.payload.value.length) !== parseInt(msg.payload.quantity)) {\n              node.activateSending(msg)\n              cberr(new Error('Quantity should be less or equal to coil payload array length: ' +\n              msg.payload.value.length + ' Addr: ' + msg.payload.address + ' Q: ' + msg.payload.quantity), msg)\n            } else {\n              node.client.writeCoils(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n                node.activateSending(msg)\n                cb(resp, msg)\n              }).catch(function (err) {\n                node.activateSending(msg)\n                cberr(err, msg)\n                node.modbusErrorHandling(err)\n              })\n            }\n            break\n          case 5: // FC: 5\n            if (msg.payload.value) {\n              msg.payload.value = true\n            } else {\n              msg.payload.value = false\n            }\n            node.client.writeCoil(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n              node.activateSending(msg)\n              cb(resp, msg)\n            }).catch(function (err) {\n              node.activateSending(msg)\n              cberr(err, msg)\n              node.modbusErrorHandling(err)\n            })\n            break\n          case 16: // FC: 16\n            if (parseInt(msg.payload.value.length) !== parseInt(msg.payload.quantity)) {\n              node.activateSending(msg)\n              cberr(new Error('Quantity should be less or equal to register payload array length: ' +\n              msg.payload.value.length + ' Addr: ' + msg.payload.address + ' Q: ' + msg.payload.quantity), msg)\n            } else {\n              node.client.writeRegisters(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n                node.activateSending(msg)\n                cb(resp, msg)\n              }).catch(function (err) {\n                node.activateSending(msg)\n                cberr(err, msg)\n                node.modbusErrorHandling(err)\n              })\n            }\n            break\n          case 6: // FC: 6\n            node.client.writeRegister(parseInt(msg.payload.address), parseInt(msg.payload.value)).then(function (resp) {\n              node.activateSending(msg)\n              cb(resp, msg)\n            }).catch(function (err) {\n              node.activateSending(msg)\n              cberr(err, msg)\n              node.modbusErrorHandling(err)\n            })\n            break\n          default:\n            node.activateSending(msg)\n            cberr(new Error('Function Code Unknown'), msg)\n            coreModbusClient.internalDebug('Function Code Unknown %s', msg.payload.fc)\n            break\n        }\n      } catch (e) {\n        coreModbusClient.internalDebug(e.message)\n        node.modbusErrorHandling(e)\n      }\n    }\n\n    node.activateSending = function (msg) {\n      if (node.bufferCommands) {\n        node.sendAllowed.set(msg.queueUnit, true)\n\n        queueLog(JSON.stringify({\n          info: 'queue response activate sending',\n          message: msg.payload,\n          queueLength: node.bufferCommandList.length\n        }))\n      }\n      node.statlyMachine.activate()\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.statlyMachine.failure().close()\n    })\n\n    node.on('dynamicReconnect', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n\n      switch (msg.payload.connectorType) {\n        case 'TCP':\n          node.tcpHost = msg.payload.tcpHost || node.tcpHost\n          node.tcpPort = msg.payload.tcpPort || node.tcpPort\n          node.tcpType = msg.payload.tcpType || node.tcpType\n\n          coreModbusClient.internalDebug('New Connection Data ' + node.tcpHost + ' ' + node.tcpPort + ' ' + node.tcpType)\n          break\n        case 'SERIAL':\n          if (msg.payload.serialPort) {\n            node.serialPort = parseInt(msg.payload.serialPort) || node.serialPort\n          }\n\n          if (msg.payload.serialBaudrate) {\n            node.serialBaudrate = parseInt(msg.payload.serialBaudrate) || node.serialBaudrate\n          }\n\n          node.serialDatabits = msg.payload.serialDatabits || node.serialDatabits\n          node.serialStopbits = msg.payload.serialStopbits || node.serialStopbits\n          node.serialParity = msg.payload.serialParity || node.serialParity\n          node.serialType = msg.payload.serialType || node.serialType\n\n          if (msg.payload.serialConnectionDelay) {\n            node.serialConnectionDelay = parseInt(msg.payload.serialConnectionDelay) || node.serialConnectionDelay\n          }\n          coreModbusClient.internalDebug('New Connection Data ' + node.serialPort + ' ' + node.serialBaudrate + ' ' + node.serialType)\n          break\n        default:\n          coreModbusClient.internalDebug('Unknown Dynamic Reconnect Type ' + msg.payload.connectorType)\n      }\n\n      if (msg.payload.unitId) {\n        node.unit_id = parseInt(msg.payload.unitId) || node.unit_id\n      }\n\n      if (msg.payload.commandDelay) {\n        node.commandDelay = parseInt(msg.payload.commandDelay) || node.commandDelay\n      }\n\n      if (msg.payload.clientTimeout) {\n        node.clientTimeout = parseInt(msg.payload.clientTimeout) || node.clientTimeout\n      }\n\n      if (msg.payload.reconnectTimeout) {\n        node.reconnectTimeout = parseInt(msg.payload.reconnectTimeout) || node.reconnectTimeout\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts')\n      node.statlyMachine.failure().close()\n    })\n\n    node.on('close', function (done) {\n      node.statlyMachine.failure().stop()\n      verboseLog('close node')\n      if (node.client) {\n        node.client.close(function () {\n          verboseLog('connection closed')\n          done()\n        }).catch(function (err) {\n          verboseLog(err.message)\n          done()\n        })\n      } else {\n        done()\n      }\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (modbusNode) {\n      node.registeredNodeList[modbusNode.id] = modbusNode\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.statlyMachine.init()\n      }\n    }\n\n    node.deregisterForModbus = function (modbusNode, done) {\n      delete node.registeredNodeList[modbusNode.id]\n\n      if (node.closingModbus) {\n        done()\n      }\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client) {\n          node.client.close(function () {\n            node.statlyMachine.close().break().stop()\n            done()\n          }).catch(function (err) {\n            node.statlyMachine.failure().stop()\n            verboseLog(err.message)\n            done()\n          })\n        } else {\n          done()\n        }\n      } else {\n        done()\n      }\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    let SerialPort = require('serialport')\n    SerialPort.list(function (err, ports) {\n      if (err) console.log(err)\n      res.json(ports)\n    })\n  })\n}\n"]}