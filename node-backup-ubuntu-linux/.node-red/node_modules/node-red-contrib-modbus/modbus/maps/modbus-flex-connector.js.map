{"version":3,"sources":["modbus-flex-connector.js"],"names":["module","exports","RED","install","mbBasics","require","internalDebugLog","nodes","registerType","config","this","name","ModbusFlexConnector","maxReconnectsPerMinute","emptyQueue","showStatusActivities","node","showErrors","modbusClient","getNode","server","registerForModbus","initModbusClientEvents","setNodeStatusTo","msg","client","statlyMachine","getMachineState","JSON","stringify","payload","emit","connectorType"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAA3BF,QAAOC,sBAAyBE,UAC9B,IAAAC,EAAAC,QAAA,mBAGIC,EAAmBD,QAAQ,QAARA,CAAiB,gCAsCrCH,EApBDK,MAAAC,aAAA,wBAnBF,SAAuBC,GACvBP,EAAII,MAAAA,WAAmBD,KAAAA,GAEvBK,KAAAC,KAASC,EAAAA,KACPV,KAAIK,uBAAuBE,EAA3BI,wBAAA,EAIAH,KAAKI,WAAaL,EAAOK,WAFzBJ,KAAKC,qBAALF,EAAAM,qBACAL,KAAKG,WAAAA,EAAAA,WACLH,KAAKI,WAAaL,KAElB,IAAAO,EAAKC,KACLC,EAAkBhB,EAAlBK,MAAAY,QAAAV,EAAAW,QAIAF,EAAaG,kBAAkBL,GAF/BZ,EAAIY,uBAAJA,EAAAE,GACAd,EAAIc,gBAAmBX,UAAJS,GAEnBZ,EAAAA,GAAAA,QAASkB,SAAAA,GACTlB,EAASmB,iBAAgBC,IAIrBN,EAAAO,SAIAT,EAAAD,sBACDX,EAAAmB,gBAAAL,EAAAQ,cAAAC,kBAAAX,GAGCZ,EAAAA,QAASmB,eACVjB,EAAA,qBAAAsB,KAAAC,UAAAL,EAAAM,UAICN,EAAIM,QAAQhB,WAAaE,EAAKF,WAFhCI,EAAIa,KAAYC,mBAAeR,IAE7BA,EAAIM,MAAJ,IAAYhB,MAAAA,sCAAZU","file":"../modbus-flex-connector.js","sourcesContent":["/**\n Copyright (c) 2017,2018 Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let internalDebugLog = require('debug')('contribModbus:flex:connector')\n\n  function ModbusFlexConnector (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.maxReconnectsPerMinute = config.maxReconnectsPerMinute || 4\n    this.emptyQueue = config.emptyQueue\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    let node = this\n    let modbusClient = RED.nodes.getNode(config.server)\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.statlyMachine.getMachineState(), node)\n      }\n\n      if (msg.payload.connectorType) {\n        internalDebugLog('dynamicReconnect: ' + JSON.stringify(msg.payload))\n        msg.payload.emptyQueue = node.emptyQueue\n        modbusClient.emit('dynamicReconnect', msg)\n      } else {\n        node.error(new Error('Payload Not Valid - Connector Type'), msg)\n      }\n    })\n  }\n\n  RED.nodes.registerType('modbus-flex-connector', ModbusFlexConnector)\n}\n"]}