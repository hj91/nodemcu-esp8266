{"version":3,"sources":["modbus-flex-getter.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","internalDebugLog","this","name","ModbusFlexGetter","showStatusActivities","showErrors","connection","getNode","ioFile","useIOForPayload","useIOFile","node","logIOActivities","modbusClient","server","registerForModbus","bufferMessageList","initModbusClientEvents","setNodeStatusTo","data","resp","msg","buildMessageWithIO","err","message","onModbusReadError","getOriginalMessage","setModbusError","invalidPayloadIn","client","payload","JSON","parse","fc","unitid","parseInt","address","quantity","Number","isInteger","error","getObjectId","topic","id","messageId","value","_msgid","emit","onModbusReadDone","statlyMachine","getMachineState","deregisterForModbus","clear","done"],"mappings":"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","file":"../modbus-flex-getter.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018 Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let mbCore = require('./core/modbus-core')\n  let mbIOCore = require('./core/modbus-io-core')\n  let internalDebugLog = require('debug')('contribModbus:flex:getter')\n\n  function ModbusFlexGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    let node = this\n    node.bufferMessageList = new Map()\n    let modbusClient = RED.nodes.getNode(config.server)\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg))\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      try {\n        if (typeof msg.payload === 'string') {\n          msg.payload = JSON.parse(msg.payload)\n        }\n\n        msg.payload.fc = parseInt(msg.payload.fc) || 3\n        msg.payload.unitid = parseInt(msg.payload.unitid)\n        msg.payload.address = parseInt(msg.payload.address) || 0\n        msg.payload.quantity = parseInt(msg.payload.quantity) || 1\n\n        if (!(Number.isInteger(msg.payload.fc) &&\n              msg.payload.fc >= 1 &&\n              msg.payload.fc <= 4)) {\n          node.error('FC Not Valid', msg)\n          return\n        }\n\n        if (!(Number.isInteger(msg.payload.address) &&\n              msg.payload.address >= 0 &&\n              msg.payload.address <= 65535)) {\n          node.error('Address Not Valid', msg)\n          return\n        }\n\n        if (!(Number.isInteger(msg.payload.quantity) &&\n              msg.payload.quantity >= 1 &&\n              msg.payload.quantity <= 65535)) {\n          node.error('Quantity Not Valid', msg)\n          return\n        }\n\n        msg.messageId = mbCore.getObjectId()\n        node.bufferMessageList.set(msg.messageId, msg)\n\n        msg = {\n          topic: msg.topic || node.id,\n          payload: {\n            value: msg.payload.value || msg.value,\n            unitid: msg.payload.unitid,\n            fc: msg.payload.fc,\n            address: msg.payload.address,\n            quantity: msg.payload.quantity,\n            messageId: msg.messageId\n          },\n          _msgid: msg._msgid\n        }\n\n        modbusClient.emit('readModbus', msg, node.onModbusReadDone, node.onModbusReadError)\n      } catch (err) {\n        internalDebugLog(err.message)\n        if (node.showErrors) {\n          node.error(err, msg)\n        }\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.statlyMachine.getMachineState(), node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-flex-getter', ModbusFlexGetter)\n}\n"]}