{"version":3,"sources":["modbus-queue-info.js"],"names":["module","exports","RED","install","mbBasics","require","internalDebugLog","nodes","registerType","config","this","name","ModbusQueueInfo","createNode","topic","unitid","parseInt","lowLowLevel","lowLevel","highLevel","node","errorOnHighLevel","modbusClient","getNode","server","registerForModbus","queueReadInterval","resetStates","lowLevelReached","lowLowLevelReached","readFromQueue","bufferCommands","unit","bufferCommandList","get","length","items","msg","payload","state","send","highLevelReached","error","Error","warn","highHighLevel","highHighLevelReached","modbusClientName","fillColor","fill","shape","status","text","setNodeStatusTo","onModbusInit","on","onModbusQueue","onModbusActive","setInterval","queueReadIntervalTime","isInteger","queueEnabled","queue","date","Date","now","lowlowLevel","initQueue","settings","verbose","resetQueue","queueOptions","done","clearInterval"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAA3BF,QAAOC,sBAAyBE,UAC9B,IAAAC,EAAAC,QAAA,mBAGIC,EAAmBD,QAAQ,QAARA,CAAiB,uBA4LrCH,EAPDK,MAAAC,aAAA,oBAtLF,SAAuBC,GACvBP,EAAII,MAAAA,WAAmBD,KAAAA,GAEvBK,KAAAC,KAASC,EAAAA,KACPV,KAAIK,MAAMM,EAAVC,MAIAJ,KAAKK,OAASC,SAASP,EAAOM,QAF9BL,KAAKC,YAAcA,SAAnBF,EAAAQ,aACAP,KAAKI,SAAQL,SAAbA,EAAAS,UACAR,KAAKK,UAASC,SAASP,EAAOM,WAC9BL,KAAKO,cAAcD,SAASP,EAAOQ,eACnCP,KAAKQ,iBAAWF,EAASP,iBACzBC,KAAKS,sBAAqBV,EAAOU,uBAAjC,IAEA,IAAAC,EAAKC,KAKDC,EAAepB,EAAIK,MAAMgB,QAAQd,EAAOe,QAF5CF,EAAWG,kBAAXL,GAIAA,EAAKM,kBAAoB,KADzBJ,EAAAA,gBAAaG,UAAbL,GAKAA,EAAKO,YAAc,WAFnBvB,EAAAA,oBAAyB,EAIvBgB,EAAKQ,iBAAkB,EAFzBR,EAAKO,kBAAc,EACjBP,EAAKS,sBAAqB,GAG1BT,EAAAA,cAKFA,EAAKU,cAAgB,WAFrBV,IAAKO,EAAAA,EAALZ,QAAA,EAEAK,GAAKU,EAALC,eAAiC,EAC3BC,EAAOZ,GAAA,IAAKL,KAIZiB,EAAO,GAAPA,IAAAA,EAAAV,EAAAW,kBAAAC,IAAAF,GAAAG,OAMAf,KADGgB,IAAWhB,EAAKS,oBAAsBO,EAAQhB,EAAKH,cAFxDG,EAAIgB,eAGFhB,EAAKO,iBAALS,EAAAhB,EAAAH,aAAAmB,EAAAhB,EAAAF,SAAA,CACDE,EAAAQ,iBAAA,EAIC,IAAIS,EAAM,CAFRC,QAAMV,KAAAA,MACRR,MAAKQ,EAAAA,MACLW,MAAIF,oBACFC,OAAAA,EACAxB,iBAFQQ,EAAAX,KAGR4B,MAAOH,GAGPA,EAAAA,KAAOA,GAGThB,IAAAA,EAAKoB,kBAALJ,EAAAhB,EAAAF,UAAAkB,EAAAhB,EAAAD,UAAA,CACDC,EAAAqB,kBAAA,EAIC,IAAIJ,EAAM,CAFRC,QAAMG,KAAAA,MACRrB,MAAKqB,EAAAA,MACLF,MAAIF,qBACFC,OAAAA,EACAxB,iBAFQQ,EAAAX,KAGR4B,UAAOnB,EAAAD,UACPJ,MAAAA,GAGAqB,EAAOA,iBAPThB,EAAAsB,MAAA,IAAAC,MAAA,4BAAAN,GAUAjB,EAAIA,KAAKC,GAGPD,EAAAA,KAAKwB,GAGPxB,IAAAA,EAAKoB,sBAALJ,EAAAhB,EAAAD,WAAAiB,EAAAhB,EAAAyB,cAAA,CACDzB,EAAA0B,sBAAA,EAIC,IAAIT,EAAM,CAFRC,QAAMQ,KAAAA,MACR1B,MAAK0B,EAAAA,MACLP,MAAIF,0BACFC,OAAAA,EACAxB,iBAFQQ,EAAAX,KAGR4B,UAAOnB,EAAAD,UACPJ,cAJQK,EAAAyB,cAKRE,MAAAA,GAEAF,EAAAA,MAAAA,IAAAA,MAAezB,iCAPPiB,GAQRD,EAAAA,KAAOA,GAGThB,IAAAA,EAAUiB,OACXjB,EAAAQ,kBAICoB,EAAY,SAAZA,EAAAA,mBAKEA,EAJH5B,EAAAC,iBAIe,MADLA,UAIRD,EAAA0B,uBACFE,EAAA,OAGCA,EAAAA,OAAAA,CACDC,KAAAD,EAICE,MAAO,OAFT9B,KAAK+B,eAAOnB,EAAA,iBAAAI,SAGVgB,EAAMC,gBAAiBrB,eAAOA,EAAxB,iBAA2CI,IAIpDhB,EAAAkC,aAAA,WAzFHlC,EAAAU,iBA6FEV,EAAAA,eAAA,WADFA,EAAAU,iBAKEV,EAAAA,cAAA,WADFA,EAAAU,iBAKEV,EAAKU,GAAAA,SAALV,EAAAkC,cACDhC,EAFDiC,GAAA,UAAAnC,EAAAoC,eAMAlC,EAAaiC,GAAG,WAAYnC,EAAKqC,gBADjCnC,EAAAA,kBAAAoC,YAAgCF,EAAAA,cAAhCpC,EAAAuC,uBAKAvC,EAAKmC,GAAG,QAAS,SAAUlB,GAiBvBQ,GAnBJzB,EAAKM,aAAAA,EAAoBgC,eAEpBH,OAAGK,UAASxC,EAAUiB,SACzBA,EAAIwB,MAAAA,EAAevC,kBAAaS,IAAhCX,EAAAL,QAIEsB,EAAItB,OAASK,EAAKL,QADlBsB,EAAIyB,OAAQxC,EAAaW,kBAGzBI,EAAAA,aAAaf,CACdyC,KAAAC,KAAAC,MAIC1B,MAAO,gBAFTF,iBAAmBf,EAAAX,KACjBoD,YAAWE,EADMC,YAEjB3B,SAAOnB,EAAAF,SACP6B,UAAAA,EAAAA,UACAmB,cAAa9C,EAAK8C,eAGlBrB,GAAAA,EAAAA,YAAoBA,EAAAA,eAAAA,CAKpB,GAZFvB,EAAA6C,YAYMjE,EAAIkE,SAASC,QAAS,CAFxBhC,IAAAA,EAAWiC,8BACbhD,EAAa6C,KAAAA,GACb7D,EAAiB+D,GAEf/C,EAAAA,cACAhB,EAAAA,OAAAA,CACD2C,KAAA,OACD7B,MAAKO,OACLP,KAAK+B,4BAEHD,EAAAA,aAFUX,MAAA,mBAKZF,EAAAA,KAAIkC,KAGNnD,EAAAA,GAAKoB,QAAL,SAAAgC,GApCFpE,EAAAiD,gBAAA,SAAAjC,GAyCMA,EAAKM,mBAFXN,cAAiBA,EAAAM,mBAEfN,EAAIA,kBAAKM,KACP+C,EAAAA,oBAAmB/C,EAAnB8C","file":"../modbus-queue-info.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018 Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let internalDebugLog = require('debug')('contribModbus:queue')\n\n  function ModbusQueueInfo (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = parseInt(config.unitid)\n    this.lowLowLevel = parseInt(config.lowLowLevel)\n    this.lowLevel = parseInt(config.lowLevel)\n    this.highLevel = parseInt(config.highLevel)\n    this.highHighLevel = parseInt(config.highHighLevel)\n    this.errorOnHighLevel = config.errorOnHighLevel\n    this.queueReadIntervalTime = config.queueReadIntervalTime || 1000\n\n    let node = this\n\n    let modbusClient = RED.nodes.getNode(config.server)\n    modbusClient.registerForModbus(node)\n    node.queueReadInterval = null\n\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    node.resetStates = function () {\n      node.lowLowLevelReached = true\n      node.lowLevelReached = false\n      node.highLevelReached = false\n      node.highHighLevelReached = false\n    }\n\n    node.resetStates()\n\n    node.readFromQueue = function () {\n      let unit = node.unitid || 1\n\n      if (modbusClient.bufferCommands) {\n        if (unit < 0 || unit > 255) {\n          unit = 1\n        }\n\n        let items = modbusClient.bufferCommandList.get(unit).length\n\n        if (!items || (!node.lowLowLevelReached && items < node.lowLowLevel)) {\n          node.resetStates()\n        }\n\n        if (!node.lowLevelReached && items > node.lowLowLevel && items < node.lowLevel) {\n          node.lowLevelReached = true\n          let msg = {\n            payload: Date.now(),\n            topic: node.topic,\n            state: 'low level reached',\n            unitid: unit,\n            modbusClientName: modbusClient.name,\n            items: items\n          }\n\n          node.send(msg)\n        }\n\n        if (!node.highLevelReached && items > node.lowLevel && items > node.highLevel) {\n          node.highLevelReached = true\n          let msg = {\n            payload: Date.now(),\n            topic: node.topic,\n            state: 'high level reached',\n            unitid: unit,\n            modbusClientName: modbusClient.name,\n            highLevel: node.highLevel,\n            items: items\n          }\n\n          if (node.errorOnHighLevel) {\n            node.error(new Error('Queue High Level Reached'), msg)\n          } else {\n            node.warn(msg)\n          }\n\n          node.send(msg)\n        }\n\n        if (!node.highHighLevelReached && items > node.highLevel && items > node.highHighLevel) {\n          node.highHighLevelReached = true\n          let msg = {\n            payload: Date.now(),\n            topic: node.topic,\n            state: 'high high level reached',\n            unitid: unit,\n            modbusClientName: modbusClient.name,\n            highLevel: node.highLevel,\n            highHighLevel: node.highHighLevel,\n            items: items\n          }\n          node.error(new Error('Queue High High Level Reached'), msg)\n          node.send(msg)\n        }\n\n        let fillColor = 'blue'\n        if (node.lowLevelReached) {\n          fillColor = 'green'\n        }\n\n        if (node.highLevelReached) {\n          if (node.errorOnHighLevel) {\n            fillColor = 'red'\n          } else {\n            fillColor = 'yellow'\n          }\n        }\n\n        if (node.highHighLevelReached) {\n          fillColor = 'red'\n        }\n\n        node.status({\n          fill: fillColor,\n          shape: 'ring',\n          text: 'active unit ' + unit + ' queue items: ' + items\n        })\n      } else {\n        mbBasics.setNodeStatusTo('active unit ' + unit + ' without queue', node)\n      }\n    }\n\n    node.onModbusInit = function () {\n      node.readFromQueue()\n    }\n\n    node.onModbusActive = function () {\n      node.readFromQueue()\n    }\n\n    node.onModbusQueue = function () {\n      node.readFromQueue()\n    }\n\n    modbusClient.on('mbinit', node.onModbusInit)\n    modbusClient.on('mbqueue', node.onModbusQueue)\n    modbusClient.on('mbactive', node.onModbusActive)\n\n    node.queueReadInterval = setInterval(node.readFromQueue, node.queueReadIntervalTime)\n\n    node.on('input', function (msg) {\n      msg.queueEnabled = modbusClient.bufferCommands\n\n      if (Number.isInteger(node.unitid)) {\n        msg.queue = modbusClient.bufferCommandList.get(node.unitid)\n        msg.unitid = node.unitid\n      } else {\n        msg.queues = modbusClient.bufferCommandList\n      }\n\n      msg.queueOptions = {\n        date: Date.now(),\n        state: 'queue request',\n        modbusClientName: modbusClient.name,\n        lowlowLevel: node.lowlowLevel,\n        lowLevel: node.lowLevel,\n        highLevel: node.highLevel,\n        highHighLevel: node.highHighLevel\n      }\n\n      if (msg && msg.resetQueue && modbusClient.bufferCommands) {\n        modbusClient.initQueue()\n        if (RED.settings.verbose) {\n          let infoText = 'Init Queue By External Node'\n          modbusClient.warn(infoText)\n          internalDebugLog(infoText)\n        }\n        node.resetStates()\n        node.status({\n          fill: 'blue',\n          shape: 'ring',\n          text: 'active empty unit queue'\n        })\n        msg.queueOptions.state = 'queue reset done'\n      }\n\n      node.send(msg)\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.queueReadInterval) {\n        clearInterval(node.queueReadInterval)\n      }\n      node.queueReadInterval = null\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-queue-info', ModbusQueueInfo)\n}\n"]}