{"version":3,"sources":["modbus-read.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","httpAdmin","internalDebugLog","this","name","ModbusRead","config","nodes","createNode","topic","unitid","quantity","adr","rate","delayOnStart","rateUnit","startDelayTime","parseInt","connection","showErrors","getNode","ioFile","useIOForPayload","useIOFile","node","modbusClient","logIOActivities","registerForModbus","setNodeStatusWithTimeTo","statusValue","timeoutOccurred","search","setNodeStatusProperties","showStatusActivities","fill","statusOptions","shape","text","status","get_timeUnit_name","delayTimerID","onModbusInit","setNodeStatusTo","clearTimeout","setTimeout","startIntervalReading","INPUT_TIMEOUT_MILLISECONDS","timerID","setInterval","modbusPollingRead","calc_rateByUnit","onModbusActive","failureMsg","clearInterval","warn","onModbusClose","reconnectTimeout","onModbusBroken","on","onModbusConnect","client","msg","from","payload","dataType","fc","functionCodeModbusRead","onModbusReadDone","onModbusReadError","deregisterForModbus","lastUpdatedAt","mbIOCore","sendMessage","response","internalDebug","nameValuesFromIOFile","values","valueNames","filterValueNames","allValueNames","responseBuffer","input","origMsg","send","resp","err","message","setModbusError","done","post","auth","needsPermission","req","res","params","id","sendStatus","error","_","toString"],"mappings":"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","file":"../modbus-read.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018 Klaus Landsdorf (http://bianco-royal.de/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n Copyright 2013, 2016 IBM Corp. (node-red)\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let mbCore = require('./core/modbus-core')\n  let mbIOCore = require('./core/modbus-io-core')\n  let internalDebugLog = require('debug')('contribModbus:read')\n\n  function ModbusRead (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = config.unitid\n\n    this.dataType = config.dataType\n    this.adr = config.adr\n    this.quantity = config.quantity || 1\n\n    this.rate = config.rate\n    this.rateUnit = config.rateUnit\n\n    this.delayOnStart = config.delayOnStart\n    this.startDelayTime = parseInt(config.startDelayTime) || 10\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    let node = this\n    let modbusClient = RED.nodes.getNode(config.server)\n    modbusClient.registerForModbus(node)\n    let delayTimerID = null\n    let timerID = null\n    let timeoutOccurred = false\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    node.onModbusInit = function () {\n      mbBasics.setNodeStatusTo('initialize', node)\n    }\n\n    node.onModbusConnect = function () {\n      if (node.delayOnStart) {\n        if (!delayTimerID) {\n          delayTimerID = setTimeout(node.startIntervalReading, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n        } else {\n          clearTimeout(delayTimerID)\n          delayTimerID = setTimeout(node.startIntervalReading, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n        }\n      } else {\n        if (delayTimerID) {\n          clearTimeout(delayTimerID)\n        }\n        node.startIntervalReading()\n      }\n\n      setNodeStatusWithTimeTo('connected')\n    }\n\n    node.startIntervalReading = function () {\n      if (!timerID) {\n        timerID = setInterval(node.modbusPollingRead, mbBasics.calc_rateByUnit(node.rate, node.rateUnit))\n      }\n    }\n\n    node.onModbusActive = function () {\n      setNodeStatusWithTimeTo('active')\n    }\n\n    node.onModbusError = function (failureMsg) {\n      mbBasics.setNodeStatusTo('failure', node)\n      if (timerID) {\n        clearInterval(timerID) // clear Timer from events\n      }\n      timerID = null\n      if (node.showErrors) {\n        node.warn(failureMsg)\n      }\n    }\n\n    node.onModbusClose = function () {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (timerID) {\n        clearInterval(timerID) // clear Timer from events\n      }\n      timerID = null\n    }\n\n    node.onModbusBroken = function () {\n      mbBasics.setNodeStatusTo('reconnecting after ' + modbusClient.reconnectTimeout + ' msec.', node)\n      if (timerID) {\n        clearInterval(timerID) // clear Timer from events\n      }\n      timerID = null\n    }\n\n    modbusClient.on('mbinit', node.onModbusInit)\n    modbusClient.on('mbconnected', node.onModbusConnect)\n    modbusClient.on('mbactive', node.onModbusActive)\n    modbusClient.on('mberror', node.onModbusError)\n    modbusClient.on('mbbroken', node.onModbusBroken)\n    modbusClient.on('mbclosed', node.onModbusClose)\n\n    node.modbusPollingRead = function () {\n      if (!modbusClient.client) {\n        setNodeStatusWithTimeTo('waiting')\n        return\n      }\n\n      let msg = {\n        topic: node.topic || 'polling',\n        from: node.name,\n        payload: {\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusRead(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId: mbCore.getObjectId()\n        }\n      }\n\n      if (node.showStatusActivities) {\n        setNodeStatusWithTimeTo('polling')\n      }\n\n      modbusClient.emit('readModbus', msg, node.onModbusReadDone, node.onModbusReadError)\n    }\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        setNodeStatusWithTimeTo('reading done')\n      }\n\n      sendMessage(resp.data, resp, msg)\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n      mbBasics.setModbusError(node, modbusClient, err, msg)\n    }\n\n    node.on('close', function (done) {\n      if (timerID) {\n        clearInterval(timerID)\n      }\n      timerID = null\n      mbBasics.setNodeStatusTo('closed', node)\n      modbusClient.deregisterForModbus(node, done)\n    })\n\n    function sendMessage (values, response, msg) {\n      if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n        if (node.logIOActivities) {\n          mbIOCore.internalDebug('node.adr:' + node.adr + ' node.quantity:' + node.quantity)\n        }\n\n        let allValueNames = mbIOCore.nameValuesFromIOFile(node, msg, values, response, node.adr)\n        let valueNames = mbIOCore.filterValueNames(node, allValueNames, mbCore.functionCodeModbusRead(node.dataType), node.adr, node.quantity)\n\n        let origMsg = {\n          topic: msg.topic,\n          responseBuffer: response,\n          input: msg\n        }\n\n        if (node.useIOForPayload) {\n          origMsg.payload = valueNames\n          origMsg.values = values\n        } else {\n          origMsg.payload = values\n          origMsg.valueNames = valueNames\n        }\n\n        node.send([\n          origMsg,\n          {\n            payload: response,\n            values: values,\n            input: msg,\n            valueNames: valueNames\n          }])\n      } else {\n        node.send([\n          {\n            payload: values,\n            responseBuffer: response,\n            input: msg\n          },\n          {\n            payload: response,\n            values: values,\n            input: msg\n          }\n        ])\n      }\n    }\n\n    function setNodeStatusWithTimeTo (statusValue) {\n      if (statusValue === 'polling' && timeoutOccurred) {\n        return\n      }\n\n      let statusOptions = mbBasics.setNodeStatusProperties(statusValue, node.showStatusActivities)\n\n      if (statusValue.search('active') !== -1 || statusValue === 'polling') {\n        timeoutOccurred = false\n        node.status({\n          fill: statusOptions.fill,\n          shape: statusOptions.shape,\n          text: statusOptions.status + getTimeInfo()\n        })\n      } else {\n        node.status({\n          fill: statusOptions.fill,\n          shape: statusOptions.shape,\n          text: statusOptions.status\n        })\n      }\n    }\n\n    function getTimeInfo () {\n      return ' ( ' + node.rate + ' ' + mbBasics.get_timeUnit_name(node.rateUnit) + ' ) '\n    }\n  }\n\n  RED.nodes.registerType('modbus-read', ModbusRead)\n\n  RED.httpAdmin.post('/modbus/read/inject/:id', RED.auth.needsPermission('modbus.inject.write'), function (req, res) {\n    let node = RED.nodes.getNode(req.params.id)\n\n    if (node) {\n      try {\n        node.modbusPollingRead()\n        res.sendStatus(200)\n      } catch (err) {\n        res.sendStatus(500)\n        node.error(RED._('modbusinject.failed', {error: err.toString()}))\n      }\n    } else {\n      res.sendStatus(404)\n    }\n  })\n}\n"]}