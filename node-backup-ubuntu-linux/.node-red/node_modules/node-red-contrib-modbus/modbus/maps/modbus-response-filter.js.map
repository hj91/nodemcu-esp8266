{"version":3,"sources":["modbus-response-filter.js"],"names":["module","exports","RED","install","mbCore","require","mbBasics","nodes","registerType","config","modbusIOFileValuNames","this","name","ModbusResponseFilter","createNode","filter","registers","parseInt","filterResponseBuffer","filterInput","filterValues","showStatusActivities","node","ioFile","configData","setNodeStatusTo","on","msg","payload","item","invalidPayloadIn","length","send","filterFromPayload","showErrors","Error","httpAdmin","get","auth","needsPermission","req","res"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAA3BF,QAAOC,sBAAyBE,UAC9B,IAAAC,EAAAC,QAAA,sBAGIC,EAAWD,QAAQ,mBAFvBA,EAAA,GAyEGH,EAFDK,MAAAC,aAAA,yBArEF,SAAuBC,GACvBP,EAAIQ,MAAAA,WAAAA,KAAwBD,GAE5BE,KAAAC,KAASC,EAAAA,KACPX,KAAIK,OAAMO,EAAWC,OAIrBJ,KAAKK,UAAYC,SAASR,EAAOO,YAAc,KAD/CL,KAAKI,qBAALN,EAAAS,qBACAP,KAAKK,aAAYC,EAASR,aAI1BE,KAAKQ,YAAcV,EAAOU,YAD1BR,KAAKS,qBAAsBA,EAAAA,qBAC3BT,KAAKQ,WAALV,EAAmBA,WAEnBE,KAAKU,OAAAA,EAAAA,MAAAA,QAAuBZ,EAAOY,QAKnC,IAAIC,EAAOX,KAEXD,EAAwBY,EAAKC,OAAOC,WAEpClB,EAASmB,gBAAgB,SAAUH,GAEnCA,EAAKC,OAAOG,GAAG,gBAAiB,SAAUF,GAF1ClB,EAAyBkB,IAGvBd,EAAAA,kBAAAA,SAAwBc,GAiBtB,OAlBJG,EAAAC,QAAAD,EAAAC,QAAAb,OAAA,SAAAc,GAMI,OAAOA,EAAKjB,OAASU,EAAKP,SAA1BO,EAAOO,6BADTF,EAAA,eAKEL,EAAOK,qBACRA,EAAA,OAGCL,EAAOK,oBACRA,EAAA,MAGCA,GAGFL,EAAAI,GAAA,QAAA,SAAAC,GAjBFrB,EAAAwB,iBAAAH,KAsBIL,EAAAN,WAAA,EAAAM,EAAAN,UACDW,EAAAC,QAAAG,QAAAJ,EAAAC,QAAAG,SAAAT,EAAAN,UAMIM,EAAAU,KAAAV,EAAAW,kBAAAN,KAFGL,EAAKY,YAFTZ,EAAKN,MAAAA,IAALmB,MAAuBnB,EAAAA,QAAYe,OAAG,mBAAAT,EAAAN,YAEtCZ,EAAIkB,cAAiBK,EAAAC,QAAAG,OAAA,mCAAAT,EAAAN,UAAA,oBAMtBM,EAAAU,KAAAV,EAAAW,kBAAAN,OAIFL,EAAAI,GAAA,QAAA,WAjBHpB,EAAAmB,gBAAA,SAAAH,OA2BFpB,EAAIkC,UAAUC,IAAI,4BAA6BnC,EAAIoC,KAAKC,gBAAgB,eAAgB,SAAUC,EAAKC,GAFvGvC,EAAIK,KAAMC","file":"../modbus-response-filter.js","sourcesContent":["/**\n Copyright (c) 2017,2018 Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbCore = require('./core/modbus-core')\n  let mbBasics = require('./modbus-basics')\n  var modbusIOFileValuNames = []\n\n  function ModbusResponseFilter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.filter = config.filter\n    this.registers = parseInt(config.registers) || null\n\n    this.filterResponseBuffer = config.filterResponseBuffer\n    this.filterValues = config.filterValues\n    this.filterInput = config.filterInput\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n\n    let node = this\n\n    modbusIOFileValuNames = node.ioFile.configData\n\n    mbBasics.setNodeStatusTo('active', node)\n\n    node.ioFile.on('updatedConfig', function (configData) {\n      modbusIOFileValuNames = configData\n    })\n\n    node.filterFromPayload = function (msg) {\n      msg.payload = msg.payload.filter((item) => {\n        return item.name === node.filter\n      })\n\n      if (node.filterResponseBuffer) {\n        delete msg['responseBuffer']\n      }\n\n      if (node.filterValues) {\n        delete msg['values']\n      }\n\n      if (node.filterInput) {\n        delete msg['input']\n      }\n\n      return msg\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (node.registers && node.registers > 0) {\n        if (!msg.payload.length || msg.payload.length !== node.registers) {\n          if (node.showErrors) {\n            node.error(new Error(msg.payload.length + ' does not match ' + node.registers))\n          }\n          mbCore.internalDebug(msg.payload.length + ' Registers And Filter Length Of ' + node.registers + ' Does Not Match')\n        } else {\n          node.send(node.filterFromPayload(msg))\n        }\n      } else {\n        // without register safety\n        node.send(node.filterFromPayload(msg))\n      }\n    })\n\n    node.on('close', function () {\n      mbBasics.setNodeStatusTo('closed', node)\n    })\n  }\n\n  RED.nodes.registerType('modbus-response-filter', ModbusResponseFilter)\n\n  RED.httpAdmin.get('/modbus/iofile/valuenames', RED.auth.needsPermission('iofile.read'), function (req, res) {\n    res.json(modbusIOFileValuNames)\n  })\n}\n"]}