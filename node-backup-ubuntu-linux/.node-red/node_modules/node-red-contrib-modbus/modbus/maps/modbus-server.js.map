{"version":3,"sources":["modbus-server.js"],"names":["module","exports","RED","install","modbus","require","net","console","log","config","internalDebugLog","nodes","createNode","this","bufferFactor","logEnabled","hostname","name","serverPort","responseDelay","parseInt","delayUnit","holdingBufferSize","inputBufferSize","coilsBufferSize","node","netServer","modbusLogLevel","mbBasics","setNodeStatusTo","Server","modbusServer","server","TCP","logLabel","calc_rateByUnit","coils","Buffer","holding","input","alloc","discrete","discreteBufferSize","client","socket","stringify","address","remoteAddress","remotePort","showErrors","err","msg","buildMessage","send","type","message","payload","on","done"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAA3BF,QAAOC,sBAAyBE,UAC9B,IAAAC,EAAAC,QAAA,YAGIC,EAAMD,QAAQ,OADdD,EAASC,QAAQ,mBACjBC,EAAMD,QAAV,QAAUA,CAAV,wBA+FC,IACCE,EAAAA,MAAQC,aAAR,gBA9FF,SAAuBC,GACvBP,EAAIQ,MAAAA,WAAmBL,KAAAA,GAGrBH,KAAIS,KAAMC,EAAAA,KACVC,KAAIC,WAAAA,EAAJC,WAIAF,KAAKG,SAAWP,EAAOO,UAAY,UAFnCH,KAAKI,WAAOR,SAAZA,EAAAS,YACAL,KAAKE,cAAaN,SAAOM,EAAzBI,eACAN,KAAKG,UAAWP,EAAOO,UAEvBH,KAAKM,gBAAgBC,SANF,EAMWX,EAAOU,iBACrCN,KAAKQ,kBAAmBA,SAPL,EAOnBZ,EAAAa,mBAIAT,KAAKU,gBAAkBH,SAXJ,EAWaX,EAAOc,iBAFvCV,KAAKW,mBAAkBJ,SATJ,EASaX,EAAOe,oBAEvCX,KAAKU,WAAAA,EAAkBH,WAKvB,IAAIK,EAAOZ,KAEXY,EAAKC,UAAY,KAFjBD,EAAIA,aAAJ,KAEAA,EAAKC,gBAAL,cAAAD,GAKA,IAAIE,EAAiB,OAFrBC,EAAAA,SAASC,UAIPF,EAAiB,SAAjBA,IACDF,EAAAC,UAAA,IAAApB,EAAAwB,OAICL,EAAKM,aAAe,IAAI3B,EAAO4B,OAAOC,IAAIR,EAAKC,UAAW,CAFxDQ,SAAA,eACFT,SAAAE,EACAF,WAAKM,EAAehB,WAClBI,cAAYS,EAD4CO,gBAAAV,EAAAN,cAAAM,EAAAJ,WAExDe,MAAAC,OAAYV,MAAAA,EAF4CH,gBAAA,GAGxDc,QAAAD,OAAcZ,MAAKV,EAHqCO,kBAAA,GAIxDiB,MAAAF,OAAAG,MAAiBZ,EAASO,gBAAgBV,GAC1CgB,SAASJ,OAAOG,MAAMf,EAAKD,mBAL6B,KAQxDC,EAAAM,aAAYM,GAAOG,aAAWE,SAAAA,GARhChC,EAAA,mCAaMiC,GAAUA,EAAOC,QAFvBnB,EAAqB,2BAAwBkB,KAAQE,UAAAF,EAAAC,OAAAE,WAAA,SAAAH,EAAAC,OAAAG,cAAA,IAAAJ,EAAAC,OAAAI,YAEnDpB,EAAIe,gBAAiBC,SAAQnB,KAG7BG,EAAAA,UAASC,OAAAA,EAAgBX,WAAUO,EAAnCT,SAAA,WALFN,EAAA,uCAAAe,EAAAT,SAAA,IAAAS,EAAAP,YAUEU,EAASC,gBAAgB,cAAeJ,KADxCf,MAAAA,GACAkB,EAASC,EAAAA,SAFXJ,EAAAwB,YAIAxB,EAAOyB,KAAKA,GAEZtB,EAASqB,gBAAY,QAAAxB,GAGrBG,EAAAA,GAAAA,QAASC,SAAgBsB,GAIzB1B,IAAU2B,EAHX3B,EAAA4B,KAED,CAMI,CAACC,KAAM,UAAWC,QALVH,EAHXD,EAQmCK,QAAS/B,EAAKM,aAAaO,SAF/D,CAAAgB,KAASF,QAAAA,QAAmBD,EAAAK,QAAA/B,EAAAM,aAAAK,OAC1B,CAAAkB,KACE,QAAOC,QAAWA,EAAAA,QAAcC,EAAAA,aAAczB,OAKjD,CAAAuB,KAAA,WAAAC,QAAAJ,EAAAK,QAAA/B,EAAAM,aAAAU,cAIChB,EAAAgC,GAAIhC,QAAKC,SAAWgC,GAClBjC,EAAKC,gBAAgB,SAAMD,GACzBf,EAAAA,WACAgD,EAAAA,UAAAA,MAAAA,WAFFhD,EAAA,wBAIDgD,MAGJjC,EAAAM,aAAA,SAMA,MAAAmB,GArGH3C,QAAAC,IAAA0C,EAAAK","file":"../modbus-server.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018 Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Server node.\n * @module NodeRedModbusServer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let modbus = require('jsmodbus')\n  let net = require('net')\n\n  let mbBasics = require('./modbus-basics')\n  let internalDebugLog = require('debug')('contribModbus:server')\n\n  function ModbusServer (config) {\n    RED.nodes.createNode(this, config)\n    let bufferFactor = 8\n\n    this.name = config.name\n    this.logEnabled = config.logEnabled\n    this.hostname = config.hostname || '0.0.0.0'\n    this.serverPort = parseInt(config.serverPort)\n    this.responseDelay = parseInt(config.responseDelay)\n    this.delayUnit = config.delayUnit\n\n    this.coilsBufferSize = parseInt(config.coilsBufferSize * bufferFactor)\n    this.holdingBufferSize = parseInt(config.holdingBufferSize * bufferFactor)\n    this.inputBufferSize = parseInt(config.inputBufferSize * bufferFactor)\n    this.discreteBufferSize = parseInt(config.discreteBufferSize * bufferFactor)\n\n    this.showErrors = config.showErrors\n\n    let node = this\n\n    node.netServer = null\n    node.modbusServer = null\n\n    mbBasics.setNodeStatusTo('initialized', node)\n\n    let modbusLogLevel = 'warn'\n    if (RED.settings.verbose) {\n      modbusLogLevel = 'debug'\n    }\n\n    try {\n      node.netServer = new net.Server()\n      node.modbusServer = new modbus.server.TCP(node.netServer, {\n        'logLabel': 'ModbusServer',\n        'logLevel': modbusLogLevel,\n        'logEnabled': node.logEnabled,\n        'responseDelay': mbBasics.calc_rateByUnit(node.responseDelay, node.delayUnit),\n        'coils': Buffer.alloc(node.coilsBufferSize, 0),\n        'holding': Buffer.alloc(node.holdingBufferSize, 0),\n        'input': Buffer.alloc(node.inputBufferSize, 0),\n        'discrete': Buffer.alloc(node.discreteBufferSize, 0)\n      })\n\n      node.modbusServer.on('connection', function (client) {\n        internalDebugLog('Modbus Server client connection')\n        if (client && client.socket) {\n          internalDebugLog('Modbus Server client to ' + JSON.stringify(client.socket.address()) + ' from ' + client.socket.remoteAddress + ' ' + client.socket.remotePort)\n        }\n        mbBasics.setNodeStatusTo('active', node)\n      })\n\n      node.netServer.listen(node.serverPort, node.hostname, () => {\n        internalDebugLog('Modbus Server listening on modbus://' + node.hostname + ':' + node.serverPort)\n        mbBasics.setNodeStatusTo('initialized', node)\n      })\n    } catch (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.warn(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    }\n\n    node.on('input', function (msg) {\n      node.send(buildMessage(msg))\n    })\n\n    function buildMessage (msg) {\n      return [\n        {type: 'holding', message: msg, payload: node.modbusServer.holding},\n        {type: 'coils', message: msg, payload: node.modbusServer.coils},\n        {type: 'input', message: msg, payload: node.modbusServer.input},\n        {type: 'discrete', message: msg, payload: node.modbusServer.discrete}\n      ]\n    }\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.netServer) {\n        node.netServer.close(() => {\n          internalDebugLog('Modbus Server closed')\n          done()\n        })\n      }\n      node.modbusServer = null\n    })\n  }\n\n  try {\n    RED.nodes.registerType('modbus-server', ModbusServer)\n  } catch (err) {\n    console.log(err.message)\n  }\n}\n"]}