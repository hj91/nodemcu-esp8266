{"version":3,"sources":["modbus-write.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","internalDebugLog","this","name","ModbusWrite","showStatusActivities","showErrors","adr","Number","unitid","node","modbusClient","quantity","server","registerForModbus","Map","bufferMessageList","initModbusClientEvents","setNodeStatusTo","msg","payload","resp","buildMessage","err","message","onModbusWriteError","getOriginalMessage","setModbusError","invalidPayloadIn","client","hasOwnProperty","value","indexOf","messageId","getObjectId","set","functionCodeModbusWrite","dataType","fc","_msgid","onModbusWriteDone","on","done","clear","deregisterForModbus"],"mappings":"aAeAA,OAAOC,QAAU,SAAUC,GAA3BF,QAAOC,sBAAyBE,UAC9B,IAAAC,EAAAC,QAAA,mBAGIC,EAASD,QAAQ,sBAFrBA,EAAQA,QAAsBF,QAAtBE,CAAR,uBAuFGH,EAJDK,MAAAC,aAAA,eAjFF,SAAqBC,GACrBP,EAAIQ,MAAAA,WAAmBL,KAAAA,GAEvBM,KAAAC,KAASC,EAAaJ,KACpBP,KAAIK,qBAAuBE,EAA3BK,qBAIAH,KAAKI,WAAaN,EAAOM,WADzBJ,KAAKG,OAAAA,EAAAA,OACLH,KAAKI,SAALN,EAAkBA,SAIlBE,KAAKK,IAAMC,OAAOR,EAAOO,KAFzBL,KAAKO,SAAST,EAAOS,SAErB,IAAAC,EAAWF,KACXG,EAAgBX,EAAOY,MAAAA,QAAvBZ,EAAAa,QAIAF,EAAaG,kBAAkBJ,GAF/BA,EAAIA,kBAAJ,IAAAK,IAEAJ,EAAAA,uBAA+BD,EAA/BC,GACAD,EAAKM,gBAAoB,UAAzBN,GAEAf,EAAAA,kBAASsB,SAAuBP,EAAMC,GACtChB,EAASuB,sBAILvB,EAASuB,gBAAgB,aAAcR,GAAvCf,EAAAA,KAAAA,EAASuB,aAAgBR,EAAAM,kBAAzBG,EAAAC,QAAAC,EAAAF,KAGFT,EAAAA,mBAAiBY,SAAaZ,EAAKM,GALrCf,EAAAsB,EAAAC,SAUMd,EAAKJ,YAFXI,EAAKe,MAAAA,EAAAA,GAEH9B,EAASW,eAAYI,EAAAC,EAAAY,EAAA1B,EAAA6B,mBAAAhB,EAAAM,kBAAAG,KAGrBxB,EAAAA,GAAAA,QAASgC,SAAejB,GAL1Bf,EAAAiC,iBAAAT,IAUIR,EAAAkB,SAKDV,EAAAC,QAAAU,eAAA,UAAA,iBAAAX,EAAAC,QAAAW,QAI2B,SAAtBZ,EAAIC,QAAQW,OAA0C,UAAtBZ,EAAIC,QAAQW,MAFlDZ,EAAAC,QAAAW,MAAA,SAAAZ,EAAAC,QAAAW,OAE0CX,EAApCD,EAAIC,QAAQW,MAAZC,QAAA,OACFb,EAAIC,QAAQW,MAASZ,KAAIC,MAAQW,EAAZX,QAAsBW,SAK5CZ,EAAAc,UAAApC,EAAAqC,cACFxB,EAAAM,kBAAAmB,IAAAhB,EAAAc,UAAAd,GAEDA,EAAIc,CACJvB,QAAKM,CAIDe,MAAOZ,EAAIC,QAAQW,OAASZ,EAAIC,QAFpCD,OAAMT,EAAAD,OACJW,GAAAA,EAASgB,wBAAA1B,EAAA2B,UACPN,QAAOZ,EAAIC,IACXX,SAAQC,EAAKD,SACb6B,UAAWF,EAAAA,WAEXxB,OAAAA,EAAUF,QAGZ6B,EAAQpB,KAAIoB,cAAAA,EAAAA,EAAAA,kBAAAA,EAAAA,oBAKV7B,EAAKL,sBAFTM,EAAAA,gBAAkBA,EAAoBD,cAAK8B,kBAAwBf,MAIlEf,EAAA+B,GAAA,QAAA,SAAAC,GAvCH/C,EAAAuB,gBAAA,SAAAR,GA4CEA,EAAKM,kBAAkB2B,QAFzBjC,EAAAkC,oBAAiClC,EAAAgC","file":"../modbus-write.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018 Klaus Landsdorf (http://bianco-royal.de/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Write node.\n * @module NodeRedModbusWrite\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  let mbBasics = require('./modbus-basics')\n  let mbCore = require('./core/modbus-core')\n  let internalDebugLog = require('debug')('contribModbus:write')\n\n  function ModbusWrite (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n\n    this.unitid = config.unitid\n    this.dataType = config.dataType\n    this.adr = Number(config.adr)\n    this.quantity = config.quantity\n\n    let node = this\n    let modbusClient = RED.nodes.getNode(config.server)\n    modbusClient.registerForModbus(node)\n    node.bufferMessageList = new Map()\n\n    mbBasics.initModbusClientEvents(node, modbusClient)\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    node.onModbusWriteDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('write done', node)\n      }\n\n      node.send(mbCore.buildMessage(node.bufferMessageList, msg.payload, resp, msg))\n    }\n\n    node.onModbusWriteError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg))\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      /* HTTP requests for boolean and multiple data string [1,2,3,4,5] */\n      if (msg.payload.hasOwnProperty('value') && typeof msg.payload.value === 'string') {\n        if (msg.payload.value === 'true' || msg.payload.value === 'false') {\n          msg.payload.value = (msg.payload.value === 'true')\n        } else {\n          if (msg.payload.value.indexOf(',') > -1) {\n            msg.payload.value = JSON.parse(msg.payload.value)\n          }\n        }\n      }\n\n      msg.messageId = mbCore.getObjectId()\n      node.bufferMessageList.set(msg.messageId, msg)\n\n      msg = {\n        payload: {\n          value: msg.payload.value || msg.payload,\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusWrite(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId: msg.messageId\n        },\n        _msgid: msg._msgid\n      }\n\n      modbusClient.emit('writeModbus', msg, node.onModbusWriteDone, node.onModbusWriteError)\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.statlyMachine.getMachineState(), node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-write', ModbusWrite)\n}\n"]}