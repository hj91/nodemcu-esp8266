"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:variable-name
// tslint:disable:no-shadowed-variable
Error.stackTraceLimit = Infinity;
const async = require("async");
const fs = require("fs");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const path = require("path");
const should = require("should");
const pki = require("../lib/index");
// ------------------------------------------------- some useful dates
function get_offset_date(date, nb_days) {
    const d = new Date(date.getTime());
    d.setDate(d.getDate() + nb_days);
    return d;
}
const today = new Date();
const lastYear = get_offset_date(today, -365);
const nextYear = get_offset_date(today, 365);
const yesterday = get_offset_date(today, -1);
describe("test certificate validation", function () {
    let certificate_out_of_date;
    let certificate_not_yet_active;
    let certificate_valid;
    let certificate_valid_untrusted;
    function prepare_test(done) {
        const optionsCA = {
            keySize: 2048,
            location: path.join(test.tmpFolder, "TEST_CA")
        };
        certificateAuthority = new pki.CertificateAuthority(optionsCA);
        const optionsPKI = { location: path.join(test.tmpFolder, "TEST_PKI") };
        certificateManager = new pki.CertificateManager(optionsPKI);
        async.series([
            (callback) => {
                certificateAuthority.initialize(callback);
            },
            (callback) => {
                certificateManager.initialize(callback);
            },
            (callback) => {
                certificate_out_of_date = path.join(test.tmpFolder, "certificate_out_of_date.pem");
                createCertificate(certificate_out_of_date, { applicationUri: "SOMEURI", startDate: lastYear, validity: 300 }, callback);
            },
            (callback) => {
                certificate_not_yet_active = path.join(test.tmpFolder, "certificate_notyetactive.pem");
                createCertificate(certificate_not_yet_active, { applicationUri: "SOMEURI", startDate: nextYear, validity: 10000 }, callback);
            },
            (callback) => {
                certificate_valid = path.join(test.tmpFolder, "certificate_valid.pem");
                createCertificate(certificate_valid, { applicationUri: "SOMEURI", startDate: yesterday, validity: 10 }, callback);
            },
            (callback) => {
                certificate_valid_untrusted = path.join(test.tmpFolder, "certificate_valid_untrusted.pem");
                createCertificate(certificate_valid_untrusted, { applicationUri: "SOMEURI", startDate: yesterday, validity: 10 }, callback);
            },
        ], done);
    }
    const test = require("./helpers").beforeTest(this, prepare_test);
    let certificateManager;
    let certificateAuthority;
    /**
     * @method createCertificate
     * @param params
     * @param params.applicationUri {String}
     * @param params.dns            {String[]}
     * @param callback
     */
    function createCertificate(certificate, params, callback) {
        let theCertificateRequest;
        async.series([
            (callback) => {
                // lets create
                certificateManager.createCertificateRequest(params, (err, csr_file) => {
                    if (err) {
                        return callback(err);
                    }
                    theCertificateRequest = csr_file;
                    callback();
                });
            },
            (callback) => {
                fs.existsSync(certificate).should.eql(false);
                fs.existsSync(theCertificateRequest).should.eql(true);
                certificateAuthority.signCertificateRequest(certificate, theCertificateRequest, params, (err) => {
                    fs.existsSync(theCertificateRequest).should.eql(true);
                    fs.existsSync(certificate).should.eql(true);
                    callback(err);
                });
            }
        ], callback);
    }
    describe("should verify ", () => {
        let localCertificateManager;
        let cert1;
        let cert2;
        let cert3;
        let certificate_valid_untrusted_A;
        before((done) => {
            const optionsPKI2 = { location: path.join(test.tmpFolder, "TEST_PKI2") };
            localCertificateManager = new pki.CertificateManager(optionsPKI2);
            // get certificate
            cert1 = node_opcua_crypto_1.readCertificate(certificate_out_of_date);
            cert2 = node_opcua_crypto_1.readCertificate(certificate_not_yet_active);
            cert3 = node_opcua_crypto_1.readCertificate(certificate_valid);
            certificate_valid_untrusted_A = node_opcua_crypto_1.readCertificate(certificate_valid_untrusted);
            async.series([
                (callback) => {
                    localCertificateManager.trustCertificate(cert3, callback);
                },
                (callback) => {
                    localCertificateManager.rejectCertificate(certificate_valid_untrusted_A, callback);
                }
            ], done);
        });
        it("should detect null certificate", (done) => {
            localCertificateManager.verifyCertificate(null, (err) => {
                should.exist(err);
                err.message.should.match("BadSecurityChecksFailed");
                done();
            });
        });
        it("should detect out of date certificate", (done) => {
            localCertificateManager.verifyCertificate(cert1, (err) => {
                err.message.should.match("BadCertificateTimeInvalid");
                done();
            });
        });
        it("should detect 'not active yet' certificate", (done) => {
            localCertificateManager.verifyCertificate(cert2, (err) => {
                err.message.should.match("BadCertificateTimeInvalid");
                done();
            });
        });
        it("should detect a valid certificate", (done) => {
            localCertificateManager.verifyCertificate(cert3, (err) => {
                should(err).eql(null);
                done();
            });
        });
        it("should detect untrusted certificate", (done) => {
            localCertificateManager.verifyCertificate(certificate_valid_untrusted_A, (err) => {
                err.message.should.match("BadCertificateUntrusted");
                done();
            });
        });
    });
});
//# sourceMappingURL=test_certificate_validation.js.map