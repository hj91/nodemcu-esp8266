{"version":3,"sources":["opcua-iiot-method-caller.js"],"names":["module","exports","RED","require","install","coreMethod","nodes","catch","err","config","this","objectId","methodId","OPCUAIIoTMethodCaller","createNode","methodType","value","showStatusActivities","justValue","name","inputArguments","getNode","node","core","initClientNode","internalDebugLog","handleMethodError","error","isSessionBad","connector","resetBadSession","handleMethodWarn","message","showErrors","warn","session","msg","checkSessionNotValid","getArgumentDefinition","opcuaSession","then","results","detailDebugLog","JSON","stringify","callMethod","Error","definitionResults","callMethods","data","result","Object","assign","outputArguments","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","push","statusCode","_iterator","return","dataValuesString","definition","util","setMessageProperty","parse","readResult","_typeof","payload","buildCallMessage","invalidMessage","callMethodOnSession","registerToConnector","done"],"mappings":"AAOA,8PAOAA,OAAOC,QAAU,SAAUC,GACzBC,QAAQ,sBAAsBC,UADhCJ,IAAMK,EAAWF,QAAUD,iCA4FpBA,EAAAI,MAAEC,aAAgBC,2BAxFvB,SAAgCC,GAFhCP,EAAIG,MAAAA,WAAaF,KAAQM,GAIvBC,KAAKC,SAAWF,EAAOE,SAFzBD,KAAAE,SAASC,EAAAA,SACPX,KAAII,WAAMQ,EAAVC,WACAL,KAAKC,MAALF,EAAgBA,MAChBC,KAAKE,UAAWH,EAAOG,UACvBF,KAAKK,KAAAA,EAAaN,KAClBC,KAAKM,qBAALP,EAAAQ,qBACAP,KAAKQ,WAAYT,EAAOS,WACxBR,KAAKS,eAAcA,EAAnBC,eACAV,KAAKO,UAAAA,EAAAA,MAALI,QAAmCJ,EAAAA,WAEnC,IAAAK,EAAKF,EAAiBX,KAAAA,eAAOW,MAG7BE,EAAIA,kBAAkBC,SAAKC,EAAAA,GAGzBnB,EAAWoB,iBAAiBjB,GADzBkB,EAAAA,YACHrB,EAAAA,MAAWoB,EAAAA,GAETH,EAAKK,WAALtB,EAAAkB,KAAAK,aAAApB,IACDc,EAAAO,UAAAC,mBAIAR,EAAAS,iBAAA,SAAAC,GARHV,EAAAW,YAaIX,EAAKY,KAAKF,GAAVV,EAAAG,iBAAAO,IAGF3B,EAAAA,oBAAWoB,SAAXU,EAAAC,GALF/B,EAAAkB,KAAAc,qBAAAF,EAAA,kBAUIC,EAAAxB,UAAAwB,EAAAhB,eACDf,EAAAiC,sBAAAhB,EAAAiB,aAAAH,GAAAI,KAAA,SAAAC,GAIGpC,EAAWqC,eAAe,qCAAuCC,KAAKC,UAAUH,IAFhFL,EAAIxB,WAAYwB,EAAIhB,KACtBf,MAAAA,EAAWiC,mBAEThB,EAAKuB,iBAAgBJ,IAArBK,MAAA,qCAIHxB,EAAAuB,WAAA,SAAAT,EAAAW,GAZH1C,EAAA2C,YAAA1B,EAAAiB,aAAAH,GAAAI,KAAA,SAAAS,GAiBI5C,EAAWqC,eAAe,yBAA2BC,KAAKC,UAAUK,IADtE5C,IAAAA,EAAW2C,KACT3C,EAAWqC,GAEPQ,EAASC,OAAbC,OAAA,GAAAH,EAAAb,KACAJ,EAAIqB,SAAe,SACnBrB,EAAIA,WAAiBoB,EAAAA,IAAPrC,WArBlB,IAAAuC,GAAA,EAAAC,GAAA,EAAAC,OAAAC,EAAA,IAuBIzB,IAAAA,IAAAA,EAAAA,EAAQjB,EAAR0B,QAAAT,OAAAA,cAAAA,GAAAA,EAAAA,EAAAA,QAAAA,MAAAA,GAAAA,EAAAA,EAAqB0B,EAAA1C,MAP6CqC,EAAAM,KAAA,CAAAC,WAAAV,EAAAU,WAAAP,gBAAAH,EAAAG,kBAhBtE,MAAA7C,GAAA+C,GAAA,EAAAC,EAAAhD,EAAA,QAAA,IAAA8C,GAAA,MAAAO,EAAAC,QAAAD,EAAAC,SAAA,QAAA,GAAAP,EAAA,MAAAC,GA6BI,IAAIO,EAAmB,GAHCH,EAV0CtC,EAAAJ,WASlEc,EAAAZ,uBAA6BY,EAAA,eACOkB,KAAOU,UAApBP,EAAA,KAAA,IAArBV,KAAAC,UAAA,CACDH,QAAAQ,EAAAR,QAXiEuB,WAAAjB,GAAA,KAAA,GAAA,IAAA7C,EAAA+D,KAAAC,mBAAAlC,EAAA,UAAAW,KAAAwB,MAAAJ,IAAA,MAAAvD,GAAAc,EAAAW,aAAAX,EAAAY,KAAA,sDAAA,oBAAAkC,WAAA,YAAAC,QAAAD,cAAA9C,EAAAK,MAAAnB,EAAA4B,IAAAJ,EAAAsC,QAAAP,EAAA/B,EAAAL,MAAAnB,EAAAwB,QAalEV,EAAIyC,KAAAA,KAyBHxD,MAAM,SAAUC,GAxBjBH,EAASa,iBAAWV,GAClBc,EAAIU,YACFV,EAAAK,MAAOK,EAAOI,MAIhB2B,EAAAA,GAAAA,QAAAA,SAAmBpB,GACjBF,GAAAA,EAASQ,KAAKR,oBADkBnB,EAAAc,EAAA,gBAChCK,CA8BN,IAAMT,EAAU3B,EAAWkE,iBAAiBjD,EAAMc,GAzBhD/B,EAAImE,eAAAlD,EAAAU,IAGFV,EAAAmD,oBAAqBnD,EAAAiB,aAAAP,MAGpB3B,EAAAkB,KAAAmD,oBAAApD,GACDU,EAAAA,GAAAA,QAAQsC,SAAAA,GACRtC,EAAOT,KAACI,sBAARL,EAAAqD","file":"../opcua-iiot-method-caller.js","sourcesContent":["/*\n The BSD 3-Clause License\n\n Copyright 2017,2018 - Klaus Landsdorf (http://bianco-royal.de/)\n All rights reserved.\n node-red-contrib-iiot-opcua\n */\n'use strict'\n\n/**\n * OPC UA node representation for Node-RED OPC UA IIoT method call.\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  require('source-map-support').install()\n  let coreMethod = require('./core/opcua-iiot-core-method')\n\n  function OPCUAIIoTMethodCaller (config) {\n    RED.nodes.createNode(this, config)\n    this.objectId = config.objectId\n    this.methodId = config.methodId\n    this.methodType = config.methodType\n    this.value = config.value\n    this.justValue = config.justValue\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.inputArguments = config.inputArguments\n    this.connector = RED.nodes.getNode(config.connector)\n\n    let node = coreMethod.core.initClientNode(this)\n\n    node.handleMethodError = function (err, msg) {\n      coreMethod.internalDebugLog(err)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n\n      if (node.connector && coreMethod.core.isSessionBad(err)) {\n        node.connector.resetBadSession()\n      }\n    }\n\n    node.handleMethodWarn = function (message) {\n      if (node.showErrors) {\n        node.warn(message)\n      }\n\n      coreMethod.internalDebugLog(message)\n    }\n\n    node.callMethodOnSession = function (session, msg) {\n      if (coreMethod.core.checkSessionNotValid(session, 'MethodCaller')) {\n        return\n      }\n\n      if (msg.methodId && msg.inputArguments) {\n        coreMethod.getArgumentDefinition(node.opcuaSession, msg).then(function (results) {\n          coreMethod.detailDebugLog('Call Argument Definition Results: ' + JSON.stringify(results))\n          node.callMethod(msg, results)\n        }).catch(node.handleMethodError)\n      } else {\n        coreMethod.internalDebugLog(new Error('No Method Id And/Or Parameters'))\n      }\n    }\n\n    node.callMethod = function (msg, definitionResults) {\n      coreMethod.callMethods(node.opcuaSession, msg).then(function (data) {\n        coreMethod.detailDebugLog('Methods Call Results: ' + JSON.stringify(data))\n\n        let result = null\n        let outputArguments = []\n        let message = Object.assign({}, data.msg)\n        message.nodetype = 'method'\n        message.methodType = data.msg.methodType\n\n        for (result of data.results) {\n          outputArguments.push({statusCode: result.statusCode, outputArguments: result.outputArguments})\n        }\n\n        let dataValuesString = {}\n        if (node.justValue) {\n          if (message.inputArguments) {\n            delete message['inputArguments']\n          }\n          dataValuesString = JSON.stringify(outputArguments, null, 2)\n        } else {\n          dataValuesString = JSON.stringify({\n            results: data.results,\n            definition: definitionResults\n          }, null, 2)\n        }\n\n        try {\n          RED.util.setMessageProperty(message, 'payload', JSON.parse(dataValuesString))\n        } catch (err) {\n          if (node.showErrors) {\n            node.warn('JSON not to parse from string for dataValues type ' + typeof readResult)\n            node.error(err, msg)\n          }\n          message.payload = dataValuesString\n          message.error = err.message\n        }\n\n        node.send(message)\n      }).catch(function (err) {\n        coreMethod.internalDebugLog(err)\n        if (node.showErrors) {\n          node.error(err, msg)\n        }\n      })\n    }\n\n    node.on('input', function (msg) {\n      if (!coreMethod.core.checkConnectorState(node, msg, 'MethodCaller')) {\n        return\n      }\n\n      const message = coreMethod.buildCallMessage(node, msg)\n      if (coreMethod.invalidMessage(node, message)) {\n        return\n      }\n      node.callMethodOnSession(node.opcuaSession, message)\n    })\n\n    coreMethod.core.registerToConnector(node)\n\n    node.on('close', (done) => {\n      coreMethod.core.deregisterToConnector(node, done)\n    })\n  }\n\n  RED.nodes.registerType('OPCUA-IIoT-Method-Caller', OPCUAIIoTMethodCaller)\n}\n"]}