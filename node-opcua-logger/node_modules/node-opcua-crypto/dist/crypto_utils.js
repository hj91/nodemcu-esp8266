"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module node_opcua_crypto
 */
const constants = require("constants");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const buffer_utils_1 = require("./buffer_utils");
const crypto_explore_certificate_1 = require("./crypto_explore_certificate");
const hexy = require("hexy");
const assert = require("better-assert");
const jsrsasign = require("jsrsasign");
const sshKeyToPEM = require("ssh-key-to-pem");
const PEM_REGEX = /^(-----BEGIN (.*)-----\r?\n([\/+=a-zA-Z0-9\r\n]*)\r?\n-----END \2-----\r?\n)/mg;
const PEM_TYPE_REGEX = /^(-----BEGIN (.*)-----)/m;
// Copyright 2012 The Obvious Corporation.
// identifyPemType
/*=
 * Extract and identify the PEM file type represented in the given
 * buffer. Returns the extracted type string or undefined if the
 * buffer doesn't seem to be any sort of PEM format file.
 */
function identifyPemType(rawKey) {
    if (rawKey instanceof Buffer) {
        rawKey = rawKey.toString("utf8");
    }
    const match = PEM_TYPE_REGEX.exec(rawKey);
    return !match ? undefined : match[2];
}
exports.identifyPemType = identifyPemType;
function convertPEMtoDER(raw_key) {
    let match;
    let pemType;
    let base64str;
    const parts = [];
    // tslint:disable-next-line:no-conditional-assignment
    while ((match = PEM_REGEX.exec(raw_key)) !== null) {
        pemType = match[2];
        // pemType shall be "RSA PRIVATE KEY" , "PUBLIC KEY", "CERTIFICATE"
        base64str = match[3];
        base64str = base64str.replace(/\r?\n/g, "");
        parts.push(Buffer.from(base64str, "base64"));
    }
    return crypto_explore_certificate_1.combine_der(parts);
}
exports.convertPEMtoDER = convertPEMtoDER;
function _readPemFile(filename) {
    assert(typeof filename === "string");
    return fs.readFileSync(filename, "ascii");
}
function _readPemFileAsDER(filename) {
    if (filename.match(/.*\.der/)) {
        return fs.readFileSync(filename);
    }
    const raw_key = _readPemFile(filename);
    return convertPEMtoDER(raw_key);
}
function readCertificate(filename) {
    return _readPemFileAsDER(filename);
}
exports.readCertificate = readCertificate;
function readPublicKey(filename) {
    return _readPemFileAsDER(filename);
}
exports.readPublicKey = readPublicKey;
function readPrivateKey(filename) {
    return _readPemFileAsDER(filename);
}
exports.readPrivateKey = readPrivateKey;
function readCertificatePEM(filename) {
    return _readPemFile(filename);
}
exports.readCertificatePEM = readCertificatePEM;
function readPublicKeyPEM(filename) {
    return _readPemFile(filename);
}
exports.readPublicKeyPEM = readPublicKeyPEM;
function readPrivateKeyPEM(filename) {
    return _readPemFile(filename);
}
exports.readPrivateKeyPEM = readPrivateKeyPEM;
/**
 * @method readKeyPem
 * @param filename
 */
function readKeyPem(filename) {
    const raw_key = fs.readFileSync(filename, "utf8");
    const pemType = identifyPemType(raw_key);
    assert(typeof pemType === "string"); // must have a valid pem type
    return raw_key;
}
exports.readKeyPem = readKeyPem;
/**
 * @method toPem
 * @param raw_key
 * @param pem
 * @return
 */
function toPem(raw_key, pem) {
    assert(raw_key, "expecting a key");
    assert(typeof pem === "string");
    let pemType = identifyPemType(raw_key);
    if (pemType) {
        return raw_key;
    }
    else {
        pemType = pem;
        assert(["CERTIFICATE REQUEST", "CERTIFICATE", "RSA PRIVATE KEY", "PUBLIC KEY"].indexOf(pemType) >= 0);
        let b = raw_key.toString("base64");
        let str = "-----BEGIN " + pemType + "-----\n";
        while (b.length) {
            str += b.substr(0, 64) + "\n";
            b = b.substr(64);
        }
        str += "-----END " + pemType + "-----";
        str += "\n";
        return str;
    }
}
exports.toPem = toPem;
// istanbul ignore next
function hexDump(buffer, width) {
    if (!buffer) {
        return "<>";
    }
    width = width || 32;
    if (buffer.length > 1024) {
        return hexy.hexy(buffer.slice(0, 1024), { width, format: "twos" }) + "\n .... ( " + buffer.length + ")";
    }
    else {
        return hexy.hexy(buffer, { width, format: "twos" });
    }
}
exports.hexDump = hexDump;
/**
 * @method makeMessageChunkSignature
 * @param chunk
 * @param options
 * @param options.signatureLength
 * @param options.algorithm   for example "RSA-SHA256"
 * @param options.privateKey
 * @return - the signature
 */
function makeMessageChunkSignature(chunk, options) {
    assert(options.hasOwnProperty("algorithm"));
    assert(chunk instanceof Buffer);
    assert(["RSA PRIVATE KEY", "PRIVATE KEY"].indexOf(identifyPemType(options.privateKey)) >= 0);
    // signature length = 128 bytes
    const signer = crypto.createSign(options.algorithm);
    signer.update(chunk);
    const signature = signer.sign(options.privateKey);
    assert(!options.signatureLength || signature.length === options.signatureLength);
    return signature; // Buffer
}
exports.makeMessageChunkSignature = makeMessageChunkSignature;
/**
 * @method verifyMessageChunkSignature
 *
 *     const signer = {
 *           signatureLength : 128,
 *           algorithm : "RSA-SHA256",
 *           publicKey: "qsdqsdqsd"
 *     };
 * @param blockToVerify
 * @param signature
 * @param options
 * @param options.signatureLength
 * @param options.algorithm    for example "RSA-SHA256"
 * @param options.publicKey
 * @return true if the signature is valid
 */
function verifyMessageChunkSignature(blockToVerify, signature, options) {
    assert(blockToVerify instanceof Buffer);
    assert(signature instanceof Buffer);
    assert(typeof options.publicKey === "string");
    assert(identifyPemType(options.publicKey));
    const verify = crypto.createVerify(options.algorithm);
    verify.update(blockToVerify);
    return verify.verify(options.publicKey, signature);
}
exports.verifyMessageChunkSignature = verifyMessageChunkSignature;
function makeSHA1Thumbprint(buffer) {
    return crypto.createHash("sha1").update(buffer).digest();
}
exports.makeSHA1Thumbprint = makeSHA1Thumbprint;
let __certificate_store = path.join(__dirname, "../../certificates/");
function setCertificateStore(store) {
    const old_store = __certificate_store;
    __certificate_store = store;
    return old_store;
}
exports.setCertificateStore = setCertificateStore;
function read_sshkey_as_pem(filename) {
    if (filename.substr(0, 1) !== ".") {
        filename = __certificate_store + filename;
    }
    let key = fs.readFileSync(filename, "ascii");
    key = sshKeyToPEM(key);
    return key;
}
exports.read_sshkey_as_pem = read_sshkey_as_pem;
/**
 *
 * @param filename
 */
function read_private_rsa_key(filename) {
    if (filename.substr(0, 1) !== "." && !fs.existsSync(filename)) {
        filename = __certificate_store + filename;
    }
    return fs.readFileSync(filename, "ascii");
}
exports.read_private_rsa_key = read_private_rsa_key;
function read_public_rsa_key(filename) {
    return read_private_rsa_key(filename);
}
exports.read_public_rsa_key = read_public_rsa_key;
// Basically when you =encrypt something using an RSA key (whether public or private), the encrypted value must
// be smaller than the key (due to the maths used to do the actual encryption). So if you have a 1024-bit key,
// in theory you could encrypt any 1023-bit value (or a 1024-bit value smaller than the key) with that key.
// However, the PKCS#1 standard, which OpenSSL uses, specifies a padding scheme (so you can encrypt smaller
// quantities without losing security), and that padding scheme takes a minimum of 11 bytes (it will be longer
// if the value you're encrypting is smaller). So the highest number of bits you can encrypt with a 1024-bit
// key is 936 bits because of this (unless you disable the padding by adding the OPENSSL_NO_PADDING flag,
// in which case you can go up to 1023-1024 bits). With a 2048-bit key it's 1960 bits instead.
exports.RSA_PKCS1_OAEP_PADDING = constants.RSA_PKCS1_OAEP_PADDING;
exports.RSA_PKCS1_PADDING = constants.RSA_PKCS1_PADDING;
var PaddingAlgorithm;
(function (PaddingAlgorithm) {
    PaddingAlgorithm[PaddingAlgorithm["RSA_PKCS1_OAEP_PADDING"] = 4] = "RSA_PKCS1_OAEP_PADDING";
    PaddingAlgorithm[PaddingAlgorithm["RSA_PKCS1_PADDING"] = 1] = "RSA_PKCS1_PADDING";
})(PaddingAlgorithm = exports.PaddingAlgorithm || (exports.PaddingAlgorithm = {}));
assert(PaddingAlgorithm.RSA_PKCS1_OAEP_PADDING === constants.RSA_PKCS1_OAEP_PADDING);
assert(PaddingAlgorithm.RSA_PKCS1_PADDING === constants.RSA_PKCS1_PADDING);
// publicEncrypt and  privateDecrypt only work with
// small buffer that depends of the key size.
function publicEncrypt_native(buffer, publicKey, algorithm) {
    if (algorithm === undefined) {
        algorithm = PaddingAlgorithm.RSA_PKCS1_PADDING;
    }
    assert(algorithm === exports.RSA_PKCS1_PADDING || algorithm === exports.RSA_PKCS1_OAEP_PADDING);
    assert(buffer instanceof Buffer, "Expecting a buffer");
    return crypto.publicEncrypt({
        key: publicKey,
        padding: algorithm
    }, buffer);
}
exports.publicEncrypt_native = publicEncrypt_native;
function privateDecrypt_native(buffer, privateKey, algorithm) {
    if (algorithm === undefined) {
        algorithm = PaddingAlgorithm.RSA_PKCS1_PADDING;
    }
    assert(algorithm === exports.RSA_PKCS1_PADDING || algorithm === exports.RSA_PKCS1_OAEP_PADDING);
    assert(buffer instanceof Buffer, "Expecting a buffer");
    try {
        return crypto.privateDecrypt({
            key: privateKey,
            padding: algorithm
        }, buffer);
    }
    catch (err) {
        return Buffer.alloc(1);
    }
}
exports.privateDecrypt_native = privateDecrypt_native;
function publicEncrypt_long(buffer, publicKey, blockSize, padding, algorithm) {
    if (algorithm === undefined) {
        algorithm = PaddingAlgorithm.RSA_PKCS1_PADDING;
    }
    assert(algorithm === exports.RSA_PKCS1_PADDING || algorithm === exports.RSA_PKCS1_OAEP_PADDING);
    const chunk_size = blockSize - padding;
    const nbBlocks = Math.ceil(buffer.length / (chunk_size));
    const outputBuffer = buffer_utils_1.createFastUninitializedBuffer(nbBlocks * blockSize);
    for (let i = 0; i < nbBlocks; i++) {
        const currentBlock = buffer.slice(chunk_size * i, chunk_size * (i + 1));
        const encrypted_chunk = exports.publicEncrypt(currentBlock, publicKey, algorithm);
        assert(encrypted_chunk.length === blockSize);
        encrypted_chunk.copy(outputBuffer, i * blockSize);
    }
    return outputBuffer;
}
exports.publicEncrypt_long = publicEncrypt_long;
function privateDecrypt_long(buffer, privateKey, blockSize, algorithm) {
    algorithm = algorithm || exports.RSA_PKCS1_PADDING;
    assert(algorithm === exports.RSA_PKCS1_PADDING || algorithm === exports.RSA_PKCS1_OAEP_PADDING);
    const nbBlocks = Math.ceil(buffer.length / (blockSize));
    const outputBuffer = buffer_utils_1.createFastUninitializedBuffer(nbBlocks * blockSize);
    let total_length = 0;
    for (let i = 0; i < nbBlocks; i++) {
        const currentBlock = buffer.slice(blockSize * i, Math.min(blockSize * (i + 1), buffer.length));
        const decrypted_buf = exports.privateDecrypt(currentBlock, privateKey, algorithm);
        decrypted_buf.copy(outputBuffer, total_length);
        total_length += decrypted_buf.length;
    }
    return outputBuffer.slice(0, total_length);
}
exports.privateDecrypt_long = privateDecrypt_long;
exports.publicEncrypt = publicEncrypt_native;
exports.privateDecrypt = privateDecrypt_native;
function coerceCertificatePem(certificate) {
    if (certificate instanceof Buffer) {
        certificate = toPem(certificate, "CERTIFICATE");
    }
    assert(typeof certificate === "string");
    return certificate;
}
exports.coerceCertificatePem = coerceCertificatePem;
function coercePublicKeyPem(publicKey) {
    if (publicKey instanceof Buffer) {
        publicKey = toPem(publicKey, "PUBLIC KEY");
    }
    assert(typeof publicKey === "string");
    return publicKey;
}
exports.coercePublicKeyPem = coercePublicKeyPem;
/***
 * @method rsa_length
 * A very expensive way to determine the rsa key length ( i.e 2048bits or 1024bits)
 * @param key  a PEM public key or a PEM rsa private key
 * @return { the key length in bytes.
 */
function rsa_length(key) {
    key = coercePublicKeyPem(key);
    assert(typeof key === "string");
    const a = jsrsasign.KEYUTIL.getKey(key);
    return a.n.toString(16).length / 2;
}
exports.rsa_length = rsa_length;
function extractPublicKeyFromCertificateSync(certificate) {
    certificate = coerceCertificatePem(certificate);
    const key = jsrsasign.KEYUTIL.getKey(certificate);
    const publicKeyAsPem = jsrsasign.KEYUTIL.getPEM(key);
    assert(typeof publicKeyAsPem === "string");
    return publicKeyAsPem;
}
exports.extractPublicKeyFromCertificateSync = extractPublicKeyFromCertificateSync;
// https://github.com/kjur/jsrsasign/blob/master/x509-1.1.js
// tool to analyse asn1 base64 blocks : http://lapo.it/asn1js
/**
 * extract the publickey from a certificate
 * @async
 */
function extractPublicKeyFromCertificate(certificate, callback) {
    let err1 = null;
    let keyPem;
    try {
        keyPem = extractPublicKeyFromCertificateSync(certificate);
    }
    catch (err) {
        err1 = err;
    }
    setImmediate(() => {
        callback(err1, keyPem);
    });
}
exports.extractPublicKeyFromCertificate = extractPublicKeyFromCertificate;
//# sourceMappingURL=crypto_utils.js.map