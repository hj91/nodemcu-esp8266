"use strict";
/**
 * @module node_opcua_crypto
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_explore_certificate_1 = require("./crypto_explore_certificate");
const crypto_utils_1 = require("./crypto_utils");
const assert = require("better-assert");
function coerceCertificate(certificate) {
    if (typeof certificate === "string") {
        certificate = crypto_utils_1.convertPEMtoDER(certificate);
    }
    assert(certificate instanceof Buffer);
    return certificate;
}
exports.coerceCertificate = coerceCertificate;
/**
 * @method exploreCertificateInfo
 * returns useful information about the certificate such as public key length, start date and end of validity date,
 * and CN
 * @param certificate the certificate to explore
 */
function exploreCertificateInfo(certificate) {
    certificate = coerceCertificate(certificate);
    const certInfo = crypto_explore_certificate_1.exploreCertificate(certificate);
    const data = {
        publicKeyLength: certInfo.tbsCertificate.subjectPublicKeyInfo.keyLength,
        notBefore: certInfo.tbsCertificate.validity.notBefore,
        notAfter: certInfo.tbsCertificate.validity.notAfter,
        publicKey: certInfo.tbsCertificate.subjectPublicKeyInfo.subjectPublicKey,
        subject: certInfo.tbsCertificate.subject
    };
    if (!(data.publicKeyLength === 512 || data.publicKeyLength === 384 || data.publicKeyLength === 256 || data.publicKeyLength === 128)) {
        throw new Error("Invalid public key length (expecting 128,256,384 or 512)" + data.publicKeyLength);
    }
    return data;
}
exports.exploreCertificateInfo = exploreCertificateInfo;
//# sourceMappingURL=explore_certificate.js.map