"use strict";
// ---------------------------------------------------------------------------------------------------------------------
// node-opcua
// ---------------------------------------------------------------------------------------------------------------------
// Copyright (c) 2014-2018 - Etienne Rossignon - etienne.rossignon (at) gadz.org
// ---------------------------------------------------------------------------------------------------------------------
//
// This  project is licensed under the terms of the MIT license.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so,  subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ---------------------------------------------------------------------------------------------------------------------
// tslint:disable:no-shadowed-variable
// tslint:disable:member-ordering
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const async = require("async");
const chalk_1 = require("chalk");
const fs = require("fs");
const path = require("path");
const _ = require("underscore");
const util_1 = require("util");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const toolbox_1 = require("./toolbox");
const fsFileExists = util_1.promisify(fs.exists);
const fsWriteFile = util_1.promisify(fs.writeFile);
const fsReadFile = util_1.promisify(fs.readFile);
const fsRemoveFile = util_1.promisify(fs.unlink);
// tslint:disable-next-line:no-var-requires
const walk = require("walk");
class CertificateManager {
    constructor(options) {
        this.untrustUnknownCertificate = true;
        options.keySize = options.keySize || 2048;
        assert(options.hasOwnProperty("location"));
        assert(options.hasOwnProperty("keySize"));
        this.location = toolbox_1.make_path(options.location, "");
        this.keySize = options.keySize;
        toolbox_1.mkdir(options.location);
        // istanbul ignore next
        if (!fs.existsSync(this.location)) {
            throw new Error("CertificateManager cannot access location " + this.location);
        }
        this._thumbs = {
            rejected: {},
            trusted: {},
        };
    }
    get configFile() {
        return path.join(this.rootDir, "own/openssl.cnf");
    }
    get rootDir() {
        return this.location;
    }
    get privateKey() {
        return path.join(this.rootDir, "own/private/private_key.pem");
    }
    get randomFile() {
        return path.join(this.rootDir, "own/private/random.rnd");
    }
    getCertificateStatus(certificate, ...args) {
        const callback = args[0];
        this.initialize(() => {
            this._getCertificateStatus(certificate, (err, status) => {
                if (err) {
                    return callback(err);
                }
                if (status === "unknown") {
                    assert(certificate instanceof Buffer);
                    const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
                    const certificateName = path.join(this.rootDir, "rejected", thumbprint + ".pem");
                    const pem = node_opcua_crypto_1.toPem(certificate, "CERTIFICATE");
                    fs.writeFile(certificateName, pem, (err) => {
                        if (err) {
                            return callback(err);
                        }
                        status = "rejected";
                        return callback(null, status);
                    });
                    return;
                }
                return callback(null, status);
            });
        });
    }
    rejectCertificate(certificate, ...args) {
        const callback = args[0];
        this._moveCertificate(certificate, "rejected", callback);
    }
    trustCertificate(certificate, ...args) {
        const callback = args[0];
        this._moveCertificate(certificate, "trusted", callback);
    }
    get rejectedFolder() {
        return path.join(this.rootDir, "rejected");
    }
    get trustedFolder() {
        return path.join(this.rootDir, "trusted");
    }
    isCertificateTrusted(certificate) {
        return __awaiter(this, void 0, void 0, function* () {
            const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate);
            const certificateFilenameInTrusted = path.join(this.trustedFolder, thumbprint.toString("hex") + ".pem");
            const fileExistInTrustedFolder = yield fsFileExists(certificateFilenameInTrusted);
            if (fileExistInTrustedFolder) {
                const content = yield node_opcua_crypto_1.readCertificate(certificateFilenameInTrusted);
                if (content.toString("base64") !== certificate.toString("base64")) {
                    return "BadCertificateInvalid";
                }
                return "Good";
            }
            else {
                const certificateFilenameInRejected = path.join(this.rejectedFolder, thumbprint.toString("hex") + ".pem");
                if (!(yield fsFileExists(certificateFilenameInRejected))) {
                    if (this.untrustUnknownCertificate) {
                        // Certificate should be mark as untrusted
                        // let's first verify that certificate is valid ,as we don't want to write invalid data
                        try {
                            const info = node_opcua_crypto_1.exploreCertificateInfo(certificate);
                        }
                        catch (err) {
                            return "BadCertificateInvalid";
                        }
                        yield fsWriteFile(certificateFilenameInRejected, node_opcua_crypto_1.toPem(certificate, "CERTIFICATE"));
                    }
                    else {
                        return "Good";
                    }
                }
                toolbox_1.debugLog("certificate has never been seen before and is rejected untrusted ", certificateFilenameInRejected);
                return "BadCertificateUntrusted";
            }
        });
    }
    verifyCertificate(certificate, callback) {
        // Is the  signature on the SoftwareCertificate valid .?
        if (!certificate) {
            // missing certificate
            return callback(null, "BadSecurityChecksFailed");
        }
        // -- var split_der = require("lib/misc/crypto_explore_certificate").split_der;
        // -- var chain = split_der(securityHeader.senderCertificate);
        // -- //xx console.log("xxx NB CERTIFICATE IN CHAIN = ".red,chain.length);
        // Has SoftwareCertificate passed its issue date and has it not expired ?
        // check dates
        const cert = node_opcua_crypto_1.exploreCertificateInfo(certificate);
        const now = new Date();
        // check that certificate is active
        if (cert.notBefore.getTime() > now.getTime()) {
            // certificate is not active yet
            toolbox_1.debugLog(chalk_1.default.red("certificate is invalid : certificate is not active yet !") +
                "  not before date =" + cert.notBefore);
            return callback(null, "BadCertificateTimeInvalid");
        }
        //  check that certificate has not expired
        if (cert.notAfter.getTime() <= now.getTime()) {
            // certificate is obsolete
            toolbox_1.debugLog(chalk_1.default.red("certificate is invalid : certificate has expired !")
                + " not after date =" + cert.notAfter);
            return callback(null, "BadCertificateTimeInvalid");
        }
        // _check_that_certificate_has_not_been_revoked_by_issuer
        // Has SoftwareCertificate has  been revoked by the issuer ?
        // TODO: check if certificate is revoked or not ...
        // BadCertificateRevoked
        // check that issuer certificate has not been revoked by the CA authority
        // is issuer Certificate valid and has not been revoked by the CA that issued it. ?
        // TODO : check validity of issuer certificate
        // BadCertificateIssuerRevoked
        // check that ApplicationDescription matches URI in certificate
        // does the URI specified in the ApplicationDescription  match the URI in the Certificate ?
        // TODO : check ApplicationDescription of issuer certificate
        // return BadCertificateUriInvalid
        this._getCertificateStatus(certificate, (err, status) => {
            // istanbul ignore next
            if (err) {
                return callback(err);
            }
            if (status === "rejected") {
                return callback(null, "BadCertificateUntrusted");
            }
            else if (status === "trusted") {
                return callback(null, "Good"); // OK
            }
            assert(status === "unknown");
            return callback(null, "BadCertificateUntrusted");
        });
    }
    initialize(...args) {
        const callback = args[0];
        const pkiDir = this.location;
        toolbox_1.mkdir(pkiDir);
        toolbox_1.mkdir(path.join(pkiDir, "own"));
        toolbox_1.mkdir(path.join(pkiDir, "own/certs"));
        toolbox_1.mkdir(path.join(pkiDir, "own/private"));
        toolbox_1.mkdir(path.join(pkiDir, "trusted"));
        toolbox_1.mkdir(path.join(pkiDir, "rejected"));
        toolbox_1.ensure_openssl_installed(() => {
            // if (1 || !fs.existsSync(this.configFile)) {
            //    var data = toolbox.configurationFileTemplate;
            //    data = data.replace(/%%ROOT_FOLDER%%/, toolbox.make_path(pkiDir,"own"));
            //    fs.writeFileSync(this.configFile, data);
            // }
            //
            fs.writeFileSync(this.configFile, toolbox_1.configurationFileSimpleTemplate);
            // note : openssl 1.1.1 has a bug that causes a failure if
            // random file cannot be found. (should be fixed in 1.1.1.a)
            // if this issue become important we may have to consider checking that rndFile exists and recreate
            // it if not . this could be achieved with the command :
            //      "openssl rand -writerand ${this.randomFile}"
            //
            // cf: https://github.com/node-opcua/node-opcua/issues/554
            fs.exists(this.privateKey, (exists) => {
                if (!exists) {
                    toolbox_1.debugLog("generating private key ...");
                    toolbox_1.setEnv("RANDFILE", this.randomFile);
                    toolbox_1.createPrivateKey(this.privateKey, this.keySize, (err) => {
                        return callback(err);
                    });
                }
                else {
                    toolbox_1.debugLog("private key already exists ... skipping");
                    return callback();
                }
            });
        });
    }
    createSelfSignedCertificate(params, ...args) {
        const callback = args[0];
        const self = this;
        assert(_.isString(params.applicationUri), "expecting applicationUri");
        if (!fs.existsSync(self.privateKey)) {
            return callback(new Error("Cannot find private key " + self.privateKey));
        }
        let certificateFilename = path.join(self.rootDir, "own/certs/self_signed_certificate.pem");
        certificateFilename = params.outputFile || certificateFilename;
        const _params = params;
        _params.rootDir = self.rootDir;
        _params.configFile = self.configFile;
        _params.privateKey = self.privateKey;
        toolbox_1.createSelfSignCertificate(certificateFilename, _params, callback);
    }
    createCertificateRequest(params, callback) {
        assert(params);
        assert(_.isFunction(callback));
        const _params = params;
        if (_params.hasOwnProperty("rootDir")) {
            throw new Error("rootDir should not be specified ");
        }
        assert(!_params.rootDir);
        assert(!_params.configFile);
        assert(!_params.privateKey);
        _params.rootDir = this.rootDir;
        _params.configFile = this.configFile;
        _params.privateKey = this.privateKey;
        // compose a file name for the request
        const now = new Date();
        const today = now.toISOString().slice(0, 10) + "_" + now.getTime();
        const certificateSigningRequestFilename = path.join(this.rootDir, "own/certs", "certificate_" + today + ".csr");
        toolbox_1.createCertificateSigningRequest(certificateSigningRequestFilename, _params, (err) => {
            return callback(err, certificateSigningRequestFilename);
        });
    }
    /**
     * @internal
     * @param certificate
     * @param callback
     * @private
     */
    _getCertificateStatus(certificate, callback) {
        assert(certificate instanceof Buffer);
        const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
        toolbox_1.debugLog("thumbprint ", thumbprint);
        this._readCertificates((err) => {
            if (err) {
                return callback(err);
            }
            if (this._thumbs.rejected.hasOwnProperty(thumbprint)) {
                return callback(null, "rejected");
            }
            if (this._thumbs.trusted.hasOwnProperty(thumbprint)) {
                return callback(null, "trusted");
            }
            return callback(null, "unknown");
        });
    }
    _moveCertificate(certificate, newStatus, callback) {
        assert(certificate instanceof Buffer);
        const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
        this.getCertificateStatus(certificate, (err, status) => {
            if (err) {
                return callback(err);
            }
            if (status !== newStatus) {
                const certificateSrc = path.join(this.rootDir, status, thumbprint + ".pem");
                const certificateDest = path.join(this.rootDir, newStatus, thumbprint + ".pem");
                fs.rename(certificateSrc, certificateDest, (err) => {
                    delete this._thumbs[status][thumbprint];
                    this._thumbs[newStatus][thumbprint] = 1;
                    return callback(err);
                });
            }
            else {
                return callback();
            }
        });
    }
    _readCertificates(callback) {
        function readThumbprint(certificateFilename) {
            const certificate = node_opcua_crypto_1.readCertificate(certificateFilename);
            //noinspection UnnecessaryLocalVariableJS
            const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
            return thumbprint;
        }
        function _f(folder, index, callback) {
            const walker = walk.walk(folder, { followLinks: false });
            walker.on("file", (root, stat, next) => {
                const filename = path.join(root, stat.name);
                try {
                    const thumbprint = readThumbprint(filename);
                    index[thumbprint] = 1;
                }
                catch (err) {
                    toolbox_1.debugLog("err : ", err.message);
                }
                next();
            });
            walker.on("end", () => {
                return callback();
            });
        }
        async.series([
            (callback) => {
                _f.bind(this, path.join(this.rootDir, "trusted"), this._thumbs.trusted)
                    .call(null, callback);
            },
            (callback) => {
                _f.bind(this, path.join(this.rootDir, "rejected"), this._thumbs.rejected)
                    .call(null, callback);
            }
        ], (err) => callback(err));
    }
}
exports.CertificateManager = CertificateManager;
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
const opts = { multiArgs: false };
CertificateManager.prototype.rejectCertificate = thenify.withCallback(CertificateManager.prototype.rejectCertificate, opts);
CertificateManager.prototype.trustCertificate = thenify.withCallback(CertificateManager.prototype.trustCertificate, opts);
CertificateManager.prototype.createSelfSignedCertificate = thenify.withCallback(CertificateManager.prototype.createSelfSignedCertificate, opts);
CertificateManager.prototype.createCertificateRequest = thenify.withCallback(CertificateManager.prototype.createCertificateRequest, opts);
CertificateManager.prototype.initialize = thenify.withCallback(CertificateManager.prototype.initialize, opts);
CertificateManager.prototype.getCertificateStatus = thenify.withCallback(CertificateManager.prototype.getCertificateStatus, opts);
CertificateManager.prototype.verifyCertificate = thenify.withCallback(CertificateManager.prototype.verifyCertificate, opts);
CertificateManager.prototype.isCertificateTrusted = thenify.withCallback(util_1.callbackify(CertificateManager.prototype.isCertificateTrusted), opts);
//# sourceMappingURL=certificate_manager.js.map