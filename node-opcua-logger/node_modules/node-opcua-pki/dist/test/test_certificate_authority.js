"use strict";
// tslint:disable:no-console
// tslint:disable:no-shadowed-variable
Object.defineProperty(exports, "__esModule", { value: true });
const async = require("async");
const fs = require("fs");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const path = require("path");
const should = require("should");
const pki = require("..");
const __1 = require("..");
const helpers_1 = require("./helpers");
const _should = should;
describe("Certificate Authority", function () {
    const testData = helpers_1.beforeTest(this);
    let options = {};
    before(() => {
        options = {
            keySize: 2048,
            location: path.join(testData.tmpFolder, "CA"),
        };
    });
    it("should read openssl version", (done) => {
        __1.execute_openssl("version", { cwd: "." }, (err, output) => {
            if (err) {
                return done(err);
            }
            output = output.trim();
            __1.g_config.opensslVersion.should.eql(output);
            done(err);
        });
    });
    it("should create a CertificateAuthority", (done) => {
        const ca = new pki.CertificateAuthority(options);
        ca.initialize((err) => {
            done(err);
        });
    });
});
describe("Signing Certificate with Certificate Authority", function () {
    const testData = helpers_1.beforeTest(this);
    let ca;
    let cm;
    before((done) => {
        ca = new pki.CertificateAuthority({
            keySize: 2048,
            location: path.join(testData.tmpFolder, "CA")
        });
        cm = new pki.CertificateManager({
            location: path.join(testData.tmpFolder, "PI")
        });
        async.series([
            (callback) => {
                cm.initialize(callback);
            },
            (callback) => {
                ca.initialize(callback);
            }
        ], done);
    });
    function createCertificateRequest(callback) {
        // let create a certificate request
        const params = {
            applicationUri: "MY:APPLICATION:URI",
            dns: [
                "localhost",
                "my.domain.com"
            ],
            ip: [
                "192.123.145.121"
            ],
            subject: "/CN=MyCommonName",
            // can only be TODAY due to openssl limitation : startDate: new Date(2010,2,2),
            validity: 365 * 7,
        };
        cm.createCertificateRequest(params, (err, certificateSigningRequestFilename) => {
            callback(err, certificateSigningRequestFilename);
        });
    }
    it("T0 - should have a CA Certificate", (done) => {
        fs.existsSync(ca.caCertificate).should.eql(true);
        done();
    });
    it("T1 - should have a CA Certificate with a CRL", (done) => {
        ca.constructCACertificateWithCRL(() => {
            fs.existsSync(ca.caCertificateWithCrl).should.eql(true);
            done();
        });
    });
    it("T2 - should sign a Certificate Request", (done) => {
        const self = {
            certificateRequest: ""
        };
        async.series([
            (callback) => {
                // create a Certificate Signing Request
                createCertificateRequest((err, certificateSigningRequestFilename) => {
                    self.certificateRequest = certificateSigningRequestFilename;
                    fs.existsSync(self.certificateRequest).should.eql(true);
                    callback(err);
                });
            },
            (callback) => {
                fs.existsSync(self.certificateRequest).should.eql(true);
                const certificateFilename = path.join(testData.tmpFolder, "sample_certificate.pem");
                const params = {
                    applicationUri: "BAD SHOULD BE IN REQUEST",
                    startDate: new Date(2011, 25, 12),
                    validity: 10 * 365
                };
                ca.signCertificateRequest(certificateFilename, self.certificateRequest, params, (err, certificate) => {
                    if (err) {
                        return callback(err);
                    }
                    fs.existsSync(certificate).should.eql(true, "certificate file " + certificate + " must exist");
                    // Serial Number: 4096 (0x1000)
                    const certificateChain = node_opcua_crypto_1.readCertificate(certificate);
                    const elements = node_opcua_crypto_1.split_der(certificateChain);
                    elements.length.should.eql(2);
                    // should have 2 x -----BEGIN CERTIFICATE----- in the chain
                    callback(err ? err : undefined);
                });
            },
            (callback) => {
                // should verify that certificate is valid
                // todo
                callback();
            }
        ], done);
    });
    function sign(certificateRequest, startDate, validity, callback) {
        const a = __1.x509Date(startDate) + "_" + validity;
        fs.existsSync(certificateRequest).should.eql(true, "certificate request " + certificateRequest + " must exist");
        const certificateFilename = path.join(testData.tmpFolder, "sample_certificate" + a + ".pem");
        const params = {
            applicationUri: "BAD SHOULD BE IN REQUEST",
            startDate,
            validity
        };
        ca.signCertificateRequest(certificateFilename, certificateRequest, params, (err, certificate) => {
            // xx console.log("Certificate = ",certificate);
            if (!err) {
                fs.existsSync(certificate).should.eql(true);
            }
            // Serial Number: 4096 (0x1000)
            // should have 2 x -----BEGIN CERTIFICATE----- in the chain
            callback(err, certificateFilename);
        });
    }
    const now = new Date();
    const lastYear = new Date();
    lastYear.setFullYear(now.getFullYear() - 1);
    const nextYear = (new Date());
    nextYear.setFullYear(now.getFullYear() + 1);
    it("T3 - should create various Certificates signed by the CA authority", (done) => {
        let certificateRequest = "";
        async.series([
            (callback) => {
                // create a Certificate Signing Request
                createCertificateRequest((err, _certificateRequest) => {
                    certificateRequest = _certificateRequest;
                    fs.existsSync(certificateRequest).should.eql(true, "certificate request " + certificateRequest + " must exist");
                    callback(err);
                });
            },
            (callback) => {
                sign(certificateRequest, lastYear, 200, (err) => callback(err)); // outdated
            },
            (callback) => {
                sign(certificateRequest, lastYear, 10 * 365, // valid
                (err) => callback(err));
            },
            (callback) => {
                sign(certificateRequest, nextYear, 365, // not started yet
                (err) => callback(err));
            }
        ], done);
    });
    it("T4 - should create various self-signed Certificates using the CA", (done) => {
        // using a CA to construct self-signed certificates provides the following benefits:
        //    - startDate can be easily specified in the past or the future
        //    - certificate can be revoked ??? to be checked.
        const privateKey = cm.privateKey;
        const certificate = path.join(testData.tmpFolder, "sample_self_signed_certificate.pem");
        fs.existsSync(certificate).should.eql(false);
        ca.createSelfSignedCertificate(certificate, privateKey, {
            applicationUri: "SomeUri"
        }, (err) => {
            fs.existsSync(certificate).should.eql(true);
            done(err);
        });
    });
    /**
     *
     * @param certificate  {String} certificate to create
     * @param privateKey
     * @param callback
     */
    function createSelfSignedCertificate(certificate, privateKey, callback) {
        const startDate = new Date();
        const validity = 1000;
        const params = {
            applicationUri: "BAD SHOULD BE IN REQUEST",
            startDate,
            validity
        };
        ca.createSelfSignedCertificate(certificate, privateKey, params, (err) => {
            console.log("signed_certificate = signed_certificate", certificate);
            callback(err, certificate);
        });
    }
    it("T5 - should revoke a self-signed certificate", (done) => {
        const privateKey = cm.privateKey;
        const certificate = path.join(testData.tmpFolder, "certificate_to_be_revoked1.pem");
        const tasks = [
            (callback) => {
                createSelfSignedCertificate(certificate, privateKey, (err) => {
                    fs.existsSync(certificate).should.eql(true);
                    callback(err);
                });
            },
            (callback) => {
                ca.revokeCertificate(certificate, {}, callback);
            }
        ];
        async.series(tasks, done);
    });
    function createCertificateFromCA(callback) {
        let certificateRequest = "";
        let signedCertificate = "";
        async.series([
            (callback) => {
                // create a Certificate Signing Request
                createCertificateRequest((err, _certificateRequest) => {
                    certificateRequest = _certificateRequest;
                    callback(err);
                });
            },
            (callback) => {
                sign(certificateRequest, lastYear, 10 * 365 + 10, (err, _signedCertificate) => {
                    signedCertificate = _signedCertificate;
                    callback(err);
                });
            }
        ], (err) => {
            callback(err, signedCertificate);
        });
    }
    it("T6 - should revoke a certificate emitted by the CA", (done) => {
        let certificate = "";
        const tasks = [
            (callback) => {
                createCertificateFromCA((err, _certificate) => {
                    certificate = _certificate;
                    fs.existsSync(certificate).should.eql(true);
                    callback(err);
                });
            },
            (callback) => {
                ca.revokeCertificate(certificate, {}, callback);
            }
        ];
        async.series(tasks, done);
    });
});
//# sourceMappingURL=test_certificate_authority.js.map