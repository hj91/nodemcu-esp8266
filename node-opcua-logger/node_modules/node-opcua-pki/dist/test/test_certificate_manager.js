"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
Error.stackTraceLimit = Infinity;
// tslint:disable:variable-name
// tslint:disable:no-shadowed-variable
const async = require("async");
const fs = require("fs");
const path = require("path");
const util_1 = require("util");
const helpers_1 = require("./helpers");
const should = require("should");
const pki = require("..");
const lib_1 = require("../lib");
const _should = should;
const q = lib_1.quote;
const n = lib_1.make_path;
describe("CertificateManager", function () {
    this.timeout(400000);
    const test = helpers_1.beforeTest(this);
    it("should create a certificateManager", (done) => {
        const options = {
            location: path.join(test.tmpFolder, "PKI")
        };
        const cm = new pki.CertificateManager(options);
        cm.initialize((err) => {
            fs.existsSync(path.join(options.location)).should.eql(true);
            fs.existsSync(path.join(options.location, "trusted")).should.eql(true);
            fs.existsSync(path.join(options.location, "rejected")).should.eql(true);
            fs.existsSync(path.join(options.location, "own")).should.eql(true);
            fs.existsSync(path.join(options.location, "own/certs")).should.eql(true);
            fs.existsSync(path.join(options.location, "own/private")).should.eql(true);
            fs.existsSync(path.join(options.location, "own/openssl.cnf")).should.eql(true);
            fs.existsSync(path.join(options.location, "own/private/private_key.pem")).should.eql(true);
            const data = fs.readFileSync(path.join(options.location, "own/openssl.cnf"), "ascii");
            // config file must have a distinguish name section
            helpers_1.grep(data, /distinguished_name/).should.match(/distinguished_name/);
            done(err);
        });
    });
    it("should create its own self-signed certificate", () => __awaiter(this, void 0, void 0, function* () {
        function get_days(date1, date2) {
            const ms_in_one_day = 24 * 3600000;
            const diff = date1.getTime() - date2.getTime();
            return Math.round(diff / ms_in_one_day);
        }
        const options = {
            location: path.join(test.tmpFolder, "PKI1")
        };
        const cm = new pki.CertificateManager(options);
        yield cm.initialize();
        const now = new Date();
        const endDate = new Date(now.getFullYear() + 7, 10, 10);
        const duration = get_days(endDate, now);
        const params = {
            applicationUri: "MY:APPLICATION:URI",
            dns: [
                "some.other.domain.com",
                "my.domain.com"
            ],
            ip: [
                "192.123.145.121"
            ],
            subject: "/CN=MyCommonName",
            // can only be TODAY due to openssl limitation : startDate: new Date(2010,2,2),
            validity: duration,
            startDate: now,
        };
        yield cm.createSelfSignedCertificate(params);
        const expectedCertificate = path.join(options.location, "own/certs/self_signed_certificate.pem");
        fs.existsSync(expectedCertificate).should.eql(true);
        const data = (yield util_1.promisify(lib_1.dumpCertificate)(expectedCertificate));
        fs.writeFileSync(path.join(test.tmpFolder, "dump_cert1.txt"), data);
        helpers_1.grep(data, /URI/).should.match(/URI:MY:APPLICATION:URI/);
        helpers_1.grep(data, /DNS/).should.match(/DNS:some.other.domain.com/);
        helpers_1.grep(data, /DNS/).should.match(/DNS:my.domain.com/);
        if (lib_1.g_config.opensslVersion.match(/1.0.2/)) {
            // note openssl version 1.0.1 does support sha256 signature
            helpers_1.grep(data, /Signature Algorithm/).should.match(/Signature Algorithm: sha256WithRSAEncryption/);
        }
        helpers_1.grep(data, /Self-signed/).should.match(/Self-signed/);
        // the self-signed certificate should contain
        //     Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment, Key Agreement
        helpers_1.grep(data, /Digital Signature/).should.match(/Digital Signature/);
        helpers_1.grep(data, /Key Encipherment/).should.match(/Key Encipherment/);
        helpers_1.grep(data, /Data Encipherment/).should.match(/Data Encipherment/);
        // the self-signed certificate should not contain CRL Sing
        helpers_1.grep(data, /CRL Sign/).should.eql("");
        const y = (new Date()).getFullYear();
        helpers_1.grep(data, /Not Before/).should.match(new RegExp(y.toString() + " GMT"));
        helpers_1.grep(data, /Not After/).should.match(new RegExp((y + 7).toString() + " GMT"));
    }));
});
describe("CertificateManager managing certificate", function () {
    this.timeout(400000);
    const test = helpers_1.beforeTest(this);
    let cm;
    function createSampleCertificateDer(certificate, callback) {
        lib_1.processAltNames({ applicationUri: "T" });
        const defaultOpensslConfPath = path.join(__dirname, "../tmp/PKI2/own/openssl.cnf");
        const defaultOpensslConf = lib_1.generateStaticConfig(defaultOpensslConfPath);
        certificate = lib_1.make_path(certificate);
        // openssl req -x509 -days 365 -nodes -newkey rsa:1024 \
        //         -keyout private_key.pem -outform der -out certificate.der"
        lib_1.execute_openssl("req " +
            "-x509 -days 365 -nodes -newkey rsa:1024 " +
            "-batch -keyout private_key.pem " +
            "-outform der -out " + q(n(certificate)) +
            " -config " + q(n(defaultOpensslConf)), {}, (err) => {
            callback(err);
        });
    }
    const sample_certificate1_der = path.join(__dirname, "fixtures/sample_certificate1.der");
    const sample_certificate2_der = path.join(__dirname, "fixtures/sample_certificate2.der");
    const sample_certificate3_der = path.join(__dirname, "fixtures/sample_certificate3.der");
    const sample_certificate4_der = path.join(__dirname, "fixtures/sample_certificate4.der");
    before((done) => {
        const options = {
            location: path.join(test.tmpFolder, "PKI2")
        };
        cm = new pki.CertificateManager(options);
        async.series([
            (callback) => {
                cm.initialize(callback);
            },
            (callback) => {
                createSampleCertificateDer(sample_certificate1_der, (err) => callback(err));
            },
            (callback) => {
                createSampleCertificateDer(sample_certificate2_der, (err) => callback(err));
            },
            (callback) => {
                createSampleCertificateDer(sample_certificate3_der, (err) => callback(err));
            },
            (callback) => {
                createSampleCertificateDer(sample_certificate4_der, (err) => callback(err));
            },
        ], done);
    });
    it("Q1 - CertificateManager#_getCertificateStatus should return 'unknown' if the certificate is first seen", (done) => {
        const certificate = fs.readFileSync(sample_certificate1_der);
        certificate.should.be.instanceOf(Buffer);
        async.series([
            (callback) => {
                lib_1.execute_openssl("x509 -inform der -in " + q(n(sample_certificate1_der)) + " " +
                    "-fingerprint -noout ", {}, (err) => {
                    callback(err);
                });
            },
            (callback) => {
                cm._getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("unknown");
                    callback();
                });
            }
        ], done);
    });
    it("Q2 - CertificateManager#getCertificateStatus should store unknown certificate into the untrusted folder", (done) => {
        const certificate = fs.readFileSync(sample_certificate2_der);
        async.series([
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("rejected");
                    callback();
                });
            },
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("rejected");
                    callback();
                });
            }
        ], done);
    });
    it("Q3 - CertificateManager#trustCertificate  should store in trusted folder", (done) => {
        const certificate = fs.readFileSync(sample_certificate3_der);
        async.series([
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("rejected");
                    callback();
                });
            },
            (callback) => {
                cm.trustCertificate(certificate, (err) => {
                    should(err).eql(null);
                    callback();
                });
            },
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("trusted");
                    callback();
                });
            },
            (callback) => {
                cm.rejectCertificate(certificate, (err) => {
                    should(err).eql(null);
                    callback();
                });
            },
            (callback) => {
                cm.getCertificateStatus(certificate, (err, status) => {
                    status.should.eql("rejected");
                    callback();
                });
            },
            (callback) => {
                cm.rejectCertificate(certificate, (err) => {
                    // already rejectied
                    should(err).eql(undefined);
                    callback();
                });
            }
        ], done);
    });
    it("Q4 - Async CertificateManager#trustCertificate  should store in trusted folder", () => __awaiter(this, void 0, void 0, function* () {
        const fsReadFile = util_1.promisify(fs.readFile);
        const certificate = yield fsReadFile(sample_certificate3_der);
        const status = yield cm.getCertificateStatus(certificate);
        status.should.eql("rejected");
        yield cm.trustCertificate(certificate);
        const status1 = yield cm.getCertificateStatus(certificate);
        status1.should.eql("trusted");
        const status1_a = yield cm.isCertificateTrusted(certificate);
        status1_a.should.eql("Good");
        yield cm.rejectCertificate(certificate);
        const status2 = yield cm.getCertificateStatus(certificate);
        status2.should.eql("rejected");
        const status2_a = yield cm.isCertificateTrusted(certificate);
        status2_a.should.eql("BadCertificateUntrusted");
        yield cm.rejectCertificate(certificate);
    }));
    it("Q5 - isCertificateTrusted with invalid certificate", () => __awaiter(this, void 0, void 0, function* () {
        const badCertificate = Buffer.from("bad certificate");
        const status2_a = yield cm.isCertificateTrusted(badCertificate);
        status2_a.should.eql("BadCertificateInvalid");
    }));
    it("Q6 - isCertificateTrusted", () => __awaiter(this, void 0, void 0, function* () {
        const fsReadFile = util_1.promisify(fs.readFile);
        const certificate = yield fsReadFile(sample_certificate3_der);
        const status = yield cm.isCertificateTrusted(certificate);
        status.should.eql("BadCertificateUntrusted");
        yield cm.trustCertificate(certificate);
        const status1 = yield cm.isCertificateTrusted(certificate);
        status1.should.eql("Good");
        yield cm.rejectCertificate(certificate);
        const status2 = yield cm.isCertificateTrusted(certificate);
        status2.should.eql("BadCertificateUntrusted");
        yield cm.rejectCertificate(certificate);
    }));
});
//# sourceMappingURL=test_certificate_manager.js.map