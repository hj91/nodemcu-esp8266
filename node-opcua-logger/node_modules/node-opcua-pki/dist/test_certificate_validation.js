"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:variable-name
// tslint:disable:no-shadowed-variable
const __1 = require("..");
Error.stackTraceLimit = Infinity;
const async = require("async");
const fs = require("fs");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const path = require("path");
// ------------------------------------------------- some useful dates
function get_offset_date(date, nb_days) {
    const d = new Date(date.getTime());
    d.setDate(d.getDate() + nb_days);
    return d;
}
const today = new Date();
const lastYear = get_offset_date(today, -365);
const nextYear = get_offset_date(today, 365);
const yesterday = get_offset_date(today, -1);
describe("test certificate validation", function () {
    let certificate_out_of_date;
    let certificate_not_yet_active;
    let certificate_valid;
    let certificate_valid_untrusted;
    function prepare_test(done) {
        const optionsCA = {
            keySize: 2048,
            location: path.join(test.tmpFolder, "TEST_CA")
        };
        certificateAuthority = new __1.CertificateAuthority(optionsCA);
        const optionsPKI = { location: path.join(test.tmpFolder, "TEST_PKI") };
        certificateManager = new __1.CertificateManager(optionsPKI);
        async.series([
            (callback) => {
                certificateAuthority.initialize(callback);
            },
            (callback) => {
                certificateManager.initialize(callback);
            },
            (callback) => {
                certificate_out_of_date = path.join(test.tmpFolder, "certificate_out_of_date.pem");
                createCertificate(certificate_out_of_date, { applicationUri: "SOMEURI", startDate: lastYear, validity: 300 }, callback);
            },
            (callback) => {
                certificate_not_yet_active = path.join(test.tmpFolder, "certificate_notyetactive.pem");
                createCertificate(certificate_not_yet_active, { applicationUri: "SOMEURI", startDate: nextYear, validity: 10000 }, callback);
            },
            (callback) => {
                certificate_valid = path.join(test.tmpFolder, "certificate_valid.pem");
                createCertificate(certificate_valid, { applicationUri: "SOMEURI", startDate: yesterday, validity: 10 }, callback);
            },
            (callback) => {
                certificate_valid_untrusted = path.join(test.tmpFolder, "certificate_valid_untrusted.pem");
                createCertificate(certificate_valid_untrusted, { applicationUri: "SOMEURI", startDate: yesterday, validity: 10 }, callback);
            },
        ], done);
    }
    const test = require("./helpers").beforeTest(this, prepare_test);
    let certificateManager;
    let certificateAuthority;
    /**
     * @method createCertificate
     * @param params
     * @param params.applicationUri
     * @param params.dns
     * @param callback
     */
    function createCertificate(certificate, params, callback) {
        let theCertificateRequest;
        async.series([
            (callback) => {
                // lets create
                certificateManager.createCertificateRequest(params, (err, csr_file) => {
                    if (err) {
                        return callback(err);
                    }
                    theCertificateRequest = csr_file;
                    callback();
                });
            },
            (callback) => {
                fs.existsSync(certificate).should.eql(false);
                fs.existsSync(theCertificateRequest).should.eql(true);
                certificateAuthority.signCertificateRequest(certificate, theCertificateRequest, params, (err) => {
                    fs.existsSync(theCertificateRequest).should.eql(true);
                    fs.existsSync(certificate).should.eql(true);
                    callback(err);
                });
            }
        ], callback);
    }
    describe("should verify ", () => {
        let localCertificateManager;
        let cert1;
        let cert2;
        let cert3;
        let certificate_valid_untrusted_A;
        before((done) => {
            const optionsPKI2 = { location: path.join(test.tmpFolder, "TEST_PKI2") };
            localCertificateManager = new __1.CertificateManager(optionsPKI2);
            // get certificate
            cert1 = node_opcua_crypto_1.readCertificate(certificate_out_of_date);
            cert2 = node_opcua_crypto_1.readCertificate(certificate_not_yet_active);
            cert3 = node_opcua_crypto_1.readCertificate(certificate_valid);
            certificate_valid_untrusted_A = node_opcua_crypto_1.readCertificate(certificate_valid_untrusted);
            async.series([
                (callback) => {
                    localCertificateManager.trustCertificate(cert3, callback);
                },
                (callback) => {
                    localCertificateManager.rejectCertificate(certificate_valid_untrusted_A, callback);
                }
            ], done);
        });
        it("should detect null certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(null);
            status.toString().should.eql("BadSecurityChecksFailed");
        }));
        it("should detect out of date certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(cert1);
            status.toString().should.eql("BadCertificateTimeInvalid");
        }));
        it("should detect 'not active yet' certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(cert2);
            status.toString().should.eql("BadCertificateTimeInvalid");
        }));
        it("should detect a valid certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(cert3);
            status.toString().should.eql("Good");
        }));
        it("should detect untrusted certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(certificate_valid_untrusted_A);
            status.toString().should.eql("BadCertificateUntrusted");
        }));
    });
});
//# sourceMappingURL=test_certificate_validation.js.map